
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Complexity, Fractals, and Entropy &#8212; NeuroKit2 0.2.11 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=a64840b6"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'functions/complexity';</script>
    <link rel="icon" href="../_static/icon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Markov Chains" href="markov.html" />
    <link rel="prev" title="Data" href="data.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/neurokit.png" class="logo__image only-light" alt="NeuroKit2 0.2.11 documentation - Home"/>
    <script>document.write(`<img src="../_static/neurokit.png" class="logo__image only-dark" alt="NeuroKit2 0.2.11 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Menu</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite_us.html">Cite us</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codebook.html">Codebook</a></li>

<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/index.html">Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/bio_eventrelated/bio_eventrelated.html">Event-related Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/bio_intervalrelated/bio_intervalrelated.html">Interval-related Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/bio_custom/bio_custom.html">Customize your Processing Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ecg_hrv/ecg_hrv.html">Heart Rate Variability (HRV)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ecg_heartbeats/ecg_heartbeats.html">Extract and Visualize Individual Heartbeats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ecg_delineate/ecg_delineate.html">Locate P, Q, S and T waves in ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ecg_edr/ecg_edr.html">ECG-Derived Respiration (EDR)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ecg_generate_12leads/ecg_generate_12leads.html">Generating Abnormal 12-leads ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/eda_peaks/eda_peaks.html">Analyze Electrodermal Activity (EDA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/rsp_rrv/rsp_rrv.html">Respiratory Rate Variability (RRV)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/eog_analyze/eog_analyze.html">Analyze Electrooculography (EOG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/signal_simulation/signal_simulation.html">Simulate Artificial Physiological Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/ppg_report/ppg_report.html">Save Preprocessing Reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/eeg_power/eeg_power.html">EEG Power in Frequency Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/eeg_complexity/eeg_complexity.html">EEG Complexity Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/eeg_microstates/eeg_microstates.html">EEG Microstates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/misc_fit_function/misc_fit_function.html">Fit a function to a non-linear pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/misc_epochs_create/misc_epochs_create.html">Create epochs</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Functions</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="bio.html">Bio</a></li>
<li class="toctree-l2"><a class="reference internal" href="ecg.html">ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="ppg.html">PPG</a></li>
<li class="toctree-l2"><a class="reference internal" href="hrv.html">HRV</a></li>
<li class="toctree-l2"><a class="reference internal" href="rsp.html">RSP</a></li>
<li class="toctree-l2"><a class="reference internal" href="eda.html">EDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="emg.html">EMG</a></li>
<li class="toctree-l2"><a class="reference internal" href="eog.html">EOG</a></li>
<li class="toctree-l2"><a class="reference internal" href="eeg.html">EEG</a></li>
<li class="toctree-l2"><a class="reference internal" href="video.html">Video Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="microstates.html">Microstates</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal.html">Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="events.html">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="epochs.html">Epochs</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="markov.html">Markov Chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="stats.html">Stats</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Misc</a></li>
<li class="toctree-l2"><a class="reference internal" href="benchmark.html">Benchmarking</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../resources/index.html">Resources</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../resources/learn_python.html">Learn Python in 10 minutes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resources/contributing.html">Contributing guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resources/recording.html">Recording good quality signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resources/resources.html">Additional Resources</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../studies/index.html">Studies</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference external" href="https://www.mdpi.com/1424-8220/21/12/3998">HRV Review</a></li>
<li class="toctree-l2"><a class="reference external" href="https://psyarxiv.com/mwa6x/">HRV Indices</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9307944/">HRV Tutorial</a></li>
<li class="toctree-l2"><a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1111/ejn.15800">Complexity Review</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.mdpi.com/1099-4300/24/8/1036">Complexity Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../studies/complexity_eeg.html">EEG Complexity: Parameters Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../studies/erp_gam.html">EEG Analysis with GAMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../studies/ecg_benchmark.html">ECG Benchmark</a></li>
<li class="toctree-l2"><a class="reference internal" href="../studies/eog_blinktemplate.html">EOG blink template</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/neuropsychology/NeuroKit">Repository</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/neuropsychology/NeuroKit" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/neuropsychology/NeuroKit/edit/dev/docs/functions/complexity.rst" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/neuropsychology/NeuroKit/issues/new?title=Issue%20on%20page%20%2Ffunctions/complexity.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/functions/complexity.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Complexity, Fractals, and Entropy</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main">Main</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity"><em>complexity()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity"><code class="docutils literal notranslate"><span class="pre">complexity()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters-choice">Parameters Choice</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-delay"><em>complexity_delay()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_delay"><code class="docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-dimension"><em>complexity_dimension()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_dimension"><code class="docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-tolerance"><em>complexity_tolerance()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_tolerance"><code class="docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-k"><em>complexity_k()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_k"><code class="docutils literal notranslate"><span class="pre">complexity_k()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-dimension">Fractal Dimension</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-katz"><em>fractal_katz()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_katz"><code class="docutils literal notranslate"><span class="pre">fractal_katz()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-linelength"><em>fractal_linelength()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_linelength"><code class="docutils literal notranslate"><span class="pre">fractal_linelength()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-petrosian"><em>fractal_petrosian()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_petrosian"><code class="docutils literal notranslate"><span class="pre">fractal_petrosian()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-sevcik"><em>fractal_sevcik()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_sevcik"><code class="docutils literal notranslate"><span class="pre">fractal_sevcik()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-nld"><em>fractal_nld()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_nld"><code class="docutils literal notranslate"><span class="pre">fractal_nld()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-psdslope"><em>fractal_psdslope()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_psdslope"><code class="docutils literal notranslate"><span class="pre">fractal_psdslope()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-higuchi"><em>fractal_higuchi()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_higuchi"><code class="docutils literal notranslate"><span class="pre">fractal_higuchi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-density"><em>fractal_density()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_density"><code class="docutils literal notranslate"><span class="pre">fractal_density()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-hurst"><em>fractal_hurst()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_hurst"><code class="docutils literal notranslate"><span class="pre">fractal_hurst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-correlation"><em>fractal_correlation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_correlation"><code class="docutils literal notranslate"><span class="pre">fractal_correlation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-dfa"><em>fractal_dfa()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_dfa"><code class="docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-tmf"><em>fractal_tmf()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_tmf"><code class="docutils literal notranslate"><span class="pre">fractal_tmf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy">Entropy</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-shannon"><em>entropy_shannon()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_shannon"><code class="docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-maximum"><em>entropy_maximum()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_maximum"><code class="docutils literal notranslate"><span class="pre">entropy_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-differential"><em>entropy_differential()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_differential"><code class="docutils literal notranslate"><span class="pre">entropy_differential()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-power"><em>entropy_power()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_power"><code class="docutils literal notranslate"><span class="pre">entropy_power()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-tsallis"><em>entropy_tsallis()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_tsallis"><code class="docutils literal notranslate"><span class="pre">entropy_tsallis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-renyi"><em>entropy_renyi()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_renyi"><code class="docutils literal notranslate"><span class="pre">entropy_renyi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-approximate"><em>entropy_approximate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_approximate"><code class="docutils literal notranslate"><span class="pre">entropy_approximate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-sample"><em>entropy_sample()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_sample"><code class="docutils literal notranslate"><span class="pre">entropy_sample()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-quadratic"><em>entropy_quadratic()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_quadratic"><code class="docutils literal notranslate"><span class="pre">entropy_quadratic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-cumulativeresidual"><em>entropy_cumulativeresidual()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_cumulativeresidual"><code class="docutils literal notranslate"><span class="pre">entropy_cumulativeresidual()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-rate"><em>entropy_rate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_rate"><code class="docutils literal notranslate"><span class="pre">entropy_rate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-svd"><em>entropy_svd()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_svd"><code class="docutils literal notranslate"><span class="pre">entropy_svd()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-kl"><em>entropy_kl()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_kl"><code class="docutils literal notranslate"><span class="pre">entropy_kl()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-spectral"><em>entropy_spectral()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_spectral"><code class="docutils literal notranslate"><span class="pre">entropy_spectral()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-phase"><em>entropy_phase()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_phase"><code class="docutils literal notranslate"><span class="pre">entropy_phase()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-grid"><em>entropy_grid()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_grid"><code class="docutils literal notranslate"><span class="pre">entropy_grid()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-attention"><em>entropy_attention()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_attention"><code class="docutils literal notranslate"><span class="pre">entropy_attention()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-increment"><em>entropy_increment()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_increment"><code class="docutils literal notranslate"><span class="pre">entropy_increment()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-slope"><em>entropy_slope()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_slope"><code class="docutils literal notranslate"><span class="pre">entropy_slope()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-symbolicdynamic"><em>entropy_symbolicdynamic()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_symbolicdynamic"><code class="docutils literal notranslate"><span class="pre">entropy_symbolicdynamic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-dispersion"><em>entropy_dispersion()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_dispersion"><code class="docutils literal notranslate"><span class="pre">entropy_dispersion()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-ofentropy"><em>entropy_ofentropy()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_ofentropy"><code class="docutils literal notranslate"><span class="pre">entropy_ofentropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-permutation"><em>entropy_permutation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_permutation"><code class="docutils literal notranslate"><span class="pre">entropy_permutation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-bubble"><em>entropy_bubble()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_bubble"><code class="docutils literal notranslate"><span class="pre">entropy_bubble()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-range"><em>entropy_range()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_range"><code class="docutils literal notranslate"><span class="pre">entropy_range()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-fuzzy"><em>entropy_fuzzy()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_fuzzy"><code class="docutils literal notranslate"><span class="pre">entropy_fuzzy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-multiscale"><em>entropy_multiscale()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_multiscale"><code class="docutils literal notranslate"><span class="pre">entropy_multiscale()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-hierarchical"><em>entropy_hierarchical()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_hierarchical"><code class="docutils literal notranslate"><span class="pre">entropy_hierarchical()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-indices">Other indices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fisher-information"><em>fisher_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fisher_information"><code class="docutils literal notranslate"><span class="pre">fisher_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fishershannon-information"><em>fishershannon_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fishershannon_information"><code class="docutils literal notranslate"><span class="pre">fishershannon_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mutual-information"><em>mutual_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.mutual_information"><code class="docutils literal notranslate"><span class="pre">mutual_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-hjorth"><em>complexity_hjorth()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_hjorth"><code class="docutils literal notranslate"><span class="pre">complexity_hjorth()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-decorrelation"><em>complexity_decorrelation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_decorrelation"><code class="docutils literal notranslate"><span class="pre">complexity_decorrelation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-lempelziv"><em>complexity_lempelziv()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_lempelziv"><code class="docutils literal notranslate"><span class="pre">complexity_lempelziv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-relativeroughness"><em>complexity_relativeroughness()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_relativeroughness"><code class="docutils literal notranslate"><span class="pre">complexity_relativeroughness()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-lyapunov"><em>complexity_lyapunov()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_lyapunov"><code class="docutils literal notranslate"><span class="pre">complexity_lyapunov()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-rqa"><em>complexity_rqa()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_rqa"><code class="docutils literal notranslate"><span class="pre">complexity_rqa()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#utilities">Utilities</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-mandelbrot"><em>fractal_mandelbrot()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_mandelbrot"><code class="docutils literal notranslate"><span class="pre">fractal_mandelbrot()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-simulate"><em>complexity_simulate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_simulate"><code class="docutils literal notranslate"><span class="pre">complexity_simulate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-embedding"><em>complexity_embedding()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_embedding"><code class="docutils literal notranslate"><span class="pre">complexity_embedding()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-attractor"><em>complexity_attractor()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_attractor"><code class="docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-symbolize"><em>complexity_symbolize</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_symbolize"><code class="docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-coarsegraining"><em>complexity_coarsegraining()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_coarsegraining"><code class="docutils literal notranslate"><span class="pre">complexity_coarsegraining()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-ordinalpatterns"><em>complexity_ordinalpatterns()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_ordinalpatterns"><code class="docutils literal notranslate"><span class="pre">complexity_ordinalpatterns()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recurrence-matrix"><em>recurrence_matrix()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.recurrence_matrix"><code class="docutils literal notranslate"><span class="pre">recurrence_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joint-multivariate">Joint/Multivariate</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-shannon-joint"><em>entropy_shannon_joint()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_shannon_joint"><code class="docutils literal notranslate"><span class="pre">entropy_shannon_joint()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="complexity-fractals-and-entropy">
<h1>Complexity, Fractals, and Entropy<a class="headerlink" href="#complexity-fractals-and-entropy" title="Link to this heading">#</a></h1>
<section id="main">
<h2>Main<a class="headerlink" href="#main" title="Link to this heading">#</a></h2>
<section id="complexity">
<h3><em>complexity()</em><a class="headerlink" href="#complexity" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity">
<span class="sig-name descname"><span class="pre">complexity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">which</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'makowski2022'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity.html#complexity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity" title="Link to this definition">#</a></dt>
<dd><p><strong>Complexity and Chaos Analysis</strong></p>
<p>Measuring the complexity of a signal refers to the quantification of various aspects related to
concepts such as <strong>chaos</strong>, <strong>entropy</strong>, <strong>unpredictability</strong>, and <strong>fractal dimension</strong>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>We recommend checking our open-access <a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1111/ejn.15800">review</a> for an
introduction to <strong>fractal physiology</strong> and its application in neuroscience.</p>
</div>
<p>There are many indices that have been developed and used to assess the complexity of signals,
and all of them come with different specificities and limitations. While they should be used in
an informed manner, it is also convenient to have a single function that can compute multiple
indices at once.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nk.complexity()</span></code> function can be used to compute a useful subset of complexity metrics
and features. While this is great for exploratory analyses, we recommend running each function
separately, to gain more control over the parameters and information that you get.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The indices included in this function will be subjected to change in future versions,
depending on what the literature suggests. We recommend using this function only for quick
exploratory analyses, but then replacing it by the calls to the individual functions.</p>
<p>Check-out our <a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1111/ejn.15800">open-access study</a>
explaining the selection of indices.</p>
</div>
<p>The categorization by “computation time” is based on <a class="reference external" href="https://www.mdpi.com/1099-4300/24/8/1036">our study</a> results:</p>
<figure class="align-default">
<a class="reference external image-reference" href="https://www.mdpi.com/1099-4300/24/8/1036"><img alt="Complexity Benchmark (Makowski)." src="https://raw.githubusercontent.com/DominiqueMakowski/ComplexityStructure/main/figures/time1-1.png" />
</a>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>which</strong> (<em>list</em>) – What metrics to compute. Can be “makowski2022”.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>df</strong> (<em>pd.DataFrame</em>) – A dataframe with one row containing the results for each metric as columns.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_tolerance</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<ul class="simple">
<li><p><strong>Example 1</strong>: Compute fast and medium-fast complexity metrics</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a signal of 3 seconds</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="go"># Compute selection of complexity metrics (Makowski et al., 2022)</span>
<span class="gp">In [3]: </span><span class="n">df</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">which</span> <span class="o">=</span> <span class="s2">&quot;makowski2022&quot;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">df</span>
<span class="gh">Out[4]: </span>
<span class="go">      AttEn    BubbEn     CWPEn  ...  MFDFA_Width     MSPEn     SVDEn</span>
<span class="go">0  0.519414  0.089258  0.000168  ...     0.905873  0.947385  0.164543</span>

<span class="go">[1 rows x 15 columns]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Example 2</strong>: Compute complexity over time</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="gp">In [6]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="gp">In [7]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Create dynamically varying noise</span>
<span class="gp">In [8]: </span><span class="n">amount_noise</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">amount_noise</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">amount_noise</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="gp">In [10]: </span><span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">amount_noise</span><span class="p">))</span> <span class="o">*</span> <span class="n">amount_noise</span>

<span class="go"># Add to simple signal</span>
<span class="gp">In [11]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity1.png"><img alt="../_images/p_complexity1.png" src="../_images/p_complexity1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Create function-wrappers that only return the index value</span>
<span class="gp">In [13]: </span><span class="n">pfd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_petrosian</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">In [14]: </span><span class="n">kfd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_katz</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">In [15]: </span><span class="n">sfd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_sevcik</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">In [16]: </span><span class="n">svden</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_svd</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">In [17]: </span><span class="n">fisher</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">nk</span><span class="o">.</span><span class="n">fisher_information</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># FI is anticorrelated with complexity</span>

<span class="go"># Use them in a rolling window</span>
<span class="gp">In [18]: </span><span class="n">rolling_kfd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">kfd</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">rolling_pfd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pfd</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">rolling_sfd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">sfd</span><span class="p">)</span>

<span class="gp">In [21]: </span><span class="n">rolling_svden</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">svden</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">rolling_fisher</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">fisher</span><span class="p">)</span>

<span class="gp">In [23]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">([</span><span class="n">signal</span><span class="p">,</span>
<span class="gp">   ....: </span>                <span class="n">rolling_kfd</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   ....: </span>                <span class="n">rolling_pfd</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   ....: </span>                <span class="n">rolling_sfd</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   ....: </span>                <span class="n">rolling_svden</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   ....: </span>                <span class="n">rolling_fisher</span><span class="p">],</span>
<span class="gp">   ....: </span>                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Signal&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s2">&quot;Petrosian Fractal Dimension&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s2">&quot;Katz Fractal Dimension&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s2">&quot;Sevcik Fractal Dimension&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s2">&quot;SVD Entropy&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s2">&quot;Fisher Information&quot;</span><span class="p">],</span>
<span class="gp">   ....: </span>               <span class="n">sampling_rate</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">   ....: </span>               <span class="n">standardize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity2.png"><img alt="../_images/p_complexity2.png" src="../_images/p_complexity2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lau, Z. J., Pham, T., Chen, S. H. A., &amp; Makowski, D. (2022). Brain entropy, fractal
dimensions and predictability: A review of complexity measures for EEG in healthy and
neuropsychiatric populations. European Journal of Neuroscience, 1-23.</p></li>
<li><p>Makowski, D., Te, A. S., Pham, T., Lau, Z. J., &amp; Chen, S. H. (2022). The Structure of Chaos:
An Empirical Comparison of Fractal Physiology Complexity Indices Using NeuroKit2. Entropy, 24
(8), 1036.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="parameters-choice">
<h2>Parameters Choice<a class="headerlink" href="#parameters-choice" title="Link to this heading">#</a></h2>
<section id="complexity-delay">
<h3><em>complexity_delay()</em><a class="headerlink" href="#complexity-delay" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_delay">
<span class="sig-name descname"><span class="pre">complexity_delay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fraser1986'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/optim_complexity_delay.html#complexity_delay"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_delay" title="Link to this definition">#</a></dt>
<dd><p><strong>Automated selection of the optimal Delay (Tau)</strong></p>
<p>The time delay (Tau <span class="math notranslate nohighlight">\(\tau\)</span>, also referred to as <em>Lag</em>) is one of the two critical
parameters (the other being the <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dimension</span></code></a> <em>m</em>) involved in the
construction of the time-delay embedding of a signal. It corresponds to the delay in samples
between the original signal and its delayed version(s). In other words, how many samples do we
consider between a given state of the signal and its closest past state.</p>
<p>When <span class="math notranslate nohighlight">\(\tau\)</span> is smaller than the optimal theoretical value, consecutive coordinates of the
system’s state are correlated and the attractor is not sufficiently unfolded. Conversely, when
<span class="math notranslate nohighlight">\(\tau\)</span> is larger than it should be, successive coordinates are almost independent,
resulting in an uncorrelated and unstructured cloud of points.</p>
<p>The selection of the parameters <em>delay</em> and <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">*dimension*</span></code></a> is a
challenge. One approach is to select them (semi) independently (as dimension selection often
requires the delay), using <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> and <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a>. However,
some joint-estimation methods do exist, that attempt at finding the optimal delay and dimension
at the same time.</p>
<p>Note also that some authors (e.g., Rosenstein, 1994) suggest identifying the
optimal embedding dimension first, and that the optimal delay value should then be considered
as the optimal delay between the first and last delay coordinates (in other words, the actual
delay should be the optimal delay divided by the optimal embedding dimension minus 1).</p>
<p>Several authors suggested different methods to guide the choice of the delay:</p>
<ul class="simple">
<li><p><strong>Fraser and Swinney (1986)</strong> suggest using the first local minimum of the mutual information
between the delayed and non-delayed time series, effectively identifying a value of Tau for
which they share the least information (and where the attractor is the least redundant).
Unlike autocorrelation, mutual information takes into account also nonlinear correlations.</p></li>
<li><p><strong>Theiler (1990)</strong> suggested to select Tau where the autocorrelation between the signal and
its lagged version at Tau first crosses the value <span class="math notranslate nohighlight">\(1/e\)</span>. The autocorrelation-based
methods have the advantage of short computation times when calculated via the fast Fourier
transform (FFT) algorithm.</p></li>
<li><p><strong>Casdagli (1991)</strong> suggests instead taking the first zero-crossing of the autocorrelation.</p></li>
<li><p><strong>Rosenstein (1993)</strong> suggests to approximate the point where the autocorrelation function
drops to <span class="math notranslate nohighlight">\((1 - 1/e)\)</span> of its maximum value.</p></li>
<li><p><strong>Rosenstein (1994)</strong> suggests to the point close to 40% of the slope of the average
displacement from the diagonal (ADFD).</p></li>
<li><p><strong>Kim (1999)</strong> suggests estimating Tau using the correlation integral, called the C-C method,
which has shown to agree with those obtained using the Mutual Information. This method
makes use of a statistic within the reconstructed phase space, rather than analyzing the
temporal evolution of the time series. However, computation times are significantly long for
this method due to the need to compare every unique pair of pairwise vectors within the
embedded signal per delay.</p></li>
<li><p><strong>Lyle (2021)</strong> describes the “Symmetric Projection Attractor Reconstruction” (SPAR), where
<span class="math notranslate nohighlight">\(1/3\)</span> of the the dominant frequency (i.e., of the length of the average “cycle”) can be
a suitable value for approximately periodic data, and makes the attractor sensitive to
morphological changes. See also <a class="reference external" href="https://youtu.be/GGrOJtcTcHA?t=730">Aston’s talk</a>. This
method is also the fastest but might not be suitable for aperiodic signals.
The <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> argument (default to <code class="docutils literal notranslate"><span class="pre">&quot;fft&quot;</span></code>) and will be passed as the <code class="docutils literal notranslate"><span class="pre">method</span></code>
argument of  <code class="docutils literal notranslate"><span class="pre">signal_psd()</span></code>.</p></li>
</ul>
<p><strong>Joint-Methods for Delay and Dimension</strong></p>
<ul class="simple">
<li><p><strong>Gautama (2003)</strong> mentions that in practice, it is common to have a fixed time lag and to
adjust the embedding dimension accordingly. As this can lead to large <em>m</em> values (and thus to
embedded data of a large size) and thus, slow processing, they describe an optimisation
method to jointly determine <em>m</em> and <span class="math notranslate nohighlight">\(\tau\)</span>, based on the <strong>entropy ratio</strong>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We would like to implement the joint-estimation by <a class="reference external" href="https://www.mdpi.com/1099-4300/23/2/221">Matilla-García et al. (2021)</a>, please get in touch if you can help us!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay_max</strong> (<em>int</em>) – The maximum time delay (Tau or lag) to test.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The method that defines what to compute for each tested value of Tau. Can be one of
<code class="docutils literal notranslate"><span class="pre">&quot;fraser1986&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;theiler1990&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;casdagli1991&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;rosenstein1993&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;rosenstein1994&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;kim1999&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;lyle2021&quot;</span></code>.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – The method used to find the optimal value of Tau given the values computed by the method.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), will select the algorithm according to the method. Modify only if you
know what you are doing.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will plot the metric values for each value of tau.</p></li>
<li><p><strong>silent</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, silence possible warnings.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Additional arguments to be passed for C-C method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>delay</strong> (<em>int</em>) – Optimal time delay.</p></li>
<li><p><strong>parameters</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute optimal time-delay embedding.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity" title="neurokit2.complexity.complexity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embedding</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_tolerance</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<ul class="simple">
<li><p><strong>Example 1</strong>: Comparison of different methods for estimating the optimal delay of an simple
artificial signal.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay1.png"><img alt="../_images/p_complexity_delay1.png" src="../_images/p_complexity_delay1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fraser1986&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay2.png"><img alt="../_images/p_complexity_delay2.png" src="../_images/p_complexity_delay2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;theiler1990&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay3.png"><img alt="../_images/p_complexity_delay3.png" src="../_images/p_complexity_delay3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;casdagli1991&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay4.png"><img alt="../_images/p_complexity_delay4.png" src="../_images/p_complexity_delay4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rosenstein1993&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay5.png"><img alt="../_images/p_complexity_delay5.png" src="../_images/p_complexity_delay5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rosenstein1994&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay6.png"><img alt="../_images/p_complexity_delay6.png" src="../_images/p_complexity_delay6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">   ...: </span>                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lyle2021&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay7.png"><img alt="../_images/p_complexity_delay7.png" src="../_images/p_complexity_delay7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<ul class="simple">
<li><p><strong>Example 2</strong>: Optimizing the delay and the dimension using joint-estimation methods.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span>
<span class="gp">   ....: </span>    <span class="n">signal</span><span class="p">,</span>
<span class="gp">   ....: </span>    <span class="n">delay_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># Can be an int or a list</span>
<span class="gp">   ....: </span>    <span class="n">dimension_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  <span class="c1"># Can be an int or a list</span>
<span class="gp">   ....: </span>    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gautama2003&quot;</span><span class="p">,</span>
<span class="gp">   ....: </span>    <span class="n">surrogate_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># Number of surrogate signals to generate</span>
<span class="gp">   ....: </span>    <span class="n">surrogate_method</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>  <span class="c1"># can be IAAFT, see nk.signal_surrogate()</span>
<span class="gp">   ....: </span>    <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay8.png"><img alt="../_images/p_complexity_delay8.png" src="../_images/p_complexity_delay8.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Optimal dimension</span>
<span class="gp">In [11]: </span><span class="n">dimension</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;Dimension&quot;</span><span class="p">]</span>

<span class="gp">In [12]: </span><span class="n">dimension</span>
<span class="gh">Out[12]: </span><span class="go">np.int64(20)</span>
</pre></div>
</div>
<p><strong>Note</strong>: A double-checking of that method would be appreciated! Please help us improve.</p>
<ul class="simple">
<li><p><strong>Example 3</strong>: Using a realistic signal.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">ecg</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">ecg_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">60</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">ecg_rate</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">ecg_peaks</span><span class="p">(</span><span class="n">ecg</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">),</span>
<span class="gp">   ....: </span>                     <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
<span class="gp">   ....: </span>                     <span class="n">desired_length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ecg</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [15]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay9.png"><img alt="../_images/p_complexity_delay9.png" src="../_images/p_complexity_delay9.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [16]: </span><span class="n">delay</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_delay</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_delay10.png"><img alt="../_images/p_complexity_delay10.png" src="../_images/p_complexity_delay10.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lyle, J. V., Nandi, M., &amp; Aston, P. J. (2021). Symmetric Projection Attractor Reconstruction:
Sex Differences in the ECG. Frontiers in cardiovascular medicine, 1034.</p></li>
<li><p>Gautama, T., Mandic, D. P., &amp; Van Hulle, M. M. (2003, April). A differential entropy based
method for determining the optimal embedding parameters of a signal. In 2003 IEEE
International Conference on Acoustics, Speech, and Signal Processing, 2003. Proceedings.
(ICASSP’03). (Vol. 6, pp. VI-29). IEEE.</p></li>
<li><p>Camplani, M., &amp; Cannas, B. (2009). The role of the embedding dimension and time delay in time
series forecasting. IFAC Proceedings Volumes, 42(7), 316-320.</p></li>
<li><p>Rosenstein, M. T., Collins, J. J., &amp; De Luca, C. J. (1993). A practical method for calculating
largest Lyapunov exponents from small data sets. Physica D: Nonlinear Phenomena, 65(1-2),
117-134.</p></li>
<li><p>Rosenstein, M. T., Collins, J. J., &amp; De Luca, C. J. (1994). Reconstruction expansion as a
geometry-based framework for choosing proper delay times. Physica-Section D, 73(1), 82-98.</p></li>
<li><p>Kim, H., Eykholt, R., &amp; Salas, J. D. (1999). Nonlinear dynamics, delay times, and embedding
windows. Physica D: Nonlinear Phenomena, 127(1-2), 48-60.</p></li>
<li><p>Gautama, T., Mandic, D. P., &amp; Van Hulle, M. M. (2003, April). A differential entropy based
method for determining the optimal embedding parameters of a signal. In 2003 IEEE
International Conference on Acoustics, Speech, and Signal Processing, 2003. Proceedings.
(ICASSP’03). (Vol. 6, pp. VI-29). IEEE.</p></li>
<li><p>Camplani, M., &amp; Cannas, B. (2009). The role of the embedding dimension and time delay in time
series forecasting. IFAC Proceedings Volumes, 42(7), 316-320.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-dimension">
<h3><em>complexity_dimension()</em><a class="headerlink" href="#complexity-dimension" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_dimension">
<span class="sig-name descname"><span class="pre">complexity_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'afnn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/optim_complexity_dimension.html#complexity_dimension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_dimension" title="Link to this definition">#</a></dt>
<dd><p><strong>Automated selection of the optimal Embedding Dimension (m)</strong></p>
<p>The Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>) is the second
critical parameter (the first being the <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">delay</span></code></a> <span class="math notranslate nohighlight">\(\tau\)</span>)
involved in the construction of the time-delay embedding of a signal. It corresponds to the
number of delayed states (versions of the signals lagged by <span class="math notranslate nohighlight">\(\tau\)</span>) that we include in
the embedding.</p>
<p>Though one can commonly find values of 2 or 3 used in practice, several authors suggested
different numerical methods to guide the choice of <em>m</em>:</p>
<ul class="simple">
<li><p><strong>Correlation Dimension</strong> (CD): One of the earliest method to estimate the optimal <em>m</em>
was to calculate the <a class="reference internal" href="#neurokit2.complexity.fractal_correlation" title="neurokit2.complexity.fractal_correlation"><code class="xref py py-func docutils literal notranslate"><span class="pre">correlation</span> <span class="pre">dimension</span></code></a> for embeddings of
various sizes and look for a saturation (i.e., a plateau) in its value as the embedding
dimension increases. One of the limitation is that a saturation will also occur when there is
not enough data to adequately fill the high-dimensional space (note that, in general, having
such large embeddings that it significantly shortens the length of the signal is not
recommended).</p></li>
<li><p><strong>FNN</strong> (False Nearest Neighbour): The method, introduced by Kennel et al. (1992), is based
on the assumption that two points that are near to each other in the sufficient embedding
dimension should remain close as the dimension increases. The algorithm checks the neighbours
in increasing embedding dimensions until it finds only a negligible number of false
neighbours when going from dimension <span class="math notranslate nohighlight">\(m\)</span> to <span class="math notranslate nohighlight">\(m+1\)</span>. This corresponds to the lowest
embedding dimension, which is presumed to give an unfolded space-state reconstruction. This
method can fail in noisy signals due to the futile attempt of unfolding the noise (and in
purely random signals, the amount of false neighbors does not substantially drops as <em>m</em>
increases). The <strong>figure</strong> below show how projections to higher-dimensional spaces can be
used to detect false nearest neighbours. For instance, the red and the yellow points are
neighbours in the 1D space, but not in the 2D space.</p></li>
</ul>
<figure class="align-default">
<img alt="Illustration of FNN (Douglas et al., 2022)." src="../_images/douglas2022b.png" />
</figure>
<ul class="simple">
<li><p><strong>AFN</strong> (Average False Neighbors): This modification by Cao (1997) of the FNN method
addresses one of its main drawback, the need for a heuristic choice for the tolerance
thresholds <em>r</em>. It uses the maximal Euclidian distance to represent nearest neighbors, and
averages all ratios of the distance in <span class="math notranslate nohighlight">\(m+1\)</span> to <span class="math notranslate nohighlight">\(m\)</span> dimension and defines <em>E1</em> and
<em>E2</em> as parameters. The optimal dimension corresponds to when <em>E1</em> stops changing (reaches a
plateau). E1 reaches a plateau at a dimension <em>d0</em> if the signal comes from an attractor.
Then <em>d0*+1 is the optimal minimum embedding dimension. *E2</em> is a useful quantity to
distinguish deterministic signals from stochastic signals. A constant <em>E2</em> close to 1 for any
embedding dimension <em>d</em> suggests random data, since the future values are independent of the
past values.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted Tau <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as Lag) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to choose the optimal value for this parameter.</p></li>
<li><p><strong>dimension_max</strong> (<em>int</em>) – The maximum embedding dimension to test.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Can be <code class="docutils literal notranslate"><span class="pre">&quot;afn&quot;</span></code> (Average False Neighbor), <code class="docutils literal notranslate"><span class="pre">&quot;fnn&quot;</span></code> (False Nearest Neighbour), or <code class="docutils literal notranslate"><span class="pre">&quot;cd&quot;</span></code>
(Correlation Dimension).</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualize the result.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments, such as <code class="docutils literal notranslate"><span class="pre">R=10.0</span></code> or <code class="docutils literal notranslate"><span class="pre">A=2.0</span></code> (relative and absolute tolerance, only for
<code class="docutils literal notranslate"><span class="pre">'fnn'</span></code> method).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dimension</strong> (<em>int</em>) – Optimal embedding dimension.</p></li>
<li><p><strong>parameters</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute the optimal dimension.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity" title="neurokit2.complexity.complexity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_tolerance</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="go"># Correlation Dimension</span>
<span class="gp">In [3]: </span><span class="n">optimal_dimension</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_dimension</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">dimension_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cd&#39;</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_dimension1.png"><img alt="../_images/p_complexity_dimension1.png" src="../_images/p_complexity_dimension1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># FNN</span>
<span class="gp">In [4]: </span><span class="n">optimal_dimension</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_dimension</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">dimension_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fnn&#39;</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_dimension2.png"><img alt="../_images/p_complexity_dimension2.png" src="../_images/p_complexity_dimension2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># AFNN</span>
<span class="gp">In [5]: </span><span class="n">optimal_dimension</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_dimension</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">dimension_max</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">method</span><span class="o">=</span><span class="s1">&#39;afnn&#39;</span><span class="p">,</span>
<span class="gp">   ...: </span>                                                  <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_dimension3.png"><img alt="../_images/p_complexity_dimension3.png" src="../_images/p_complexity_dimension3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Kennel, M. B., Brown, R., &amp; Abarbanel, H. D. (1992). Determining embedding dimension for
phase-space reconstruction using a geometrical construction. Physical review A, 45(6), 3403.</p></li>
<li><p>Cao, L. (1997). Practical method for determining the minimum embedding dimension of a scalar
time series. Physica D: Nonlinear Phenomena, 110(1-2), 43-50.</p></li>
<li><p>Rhodes, C., &amp; Morari, M. (1997). The false nearest neighbors algorithm: An overview.
Computers &amp; Chemical Engineering, 21, S1149-S1154.</p></li>
<li><p>Krakovská, A., Mezeiová, K., &amp; Budáčová, H. (2015). Use of false nearest neighbours for
selecting variables and embedding parameters for state space reconstruction. Journal of
Complex Systems, 2015.</p></li>
<li><p>Gautama, T., Mandic, D. P., &amp; Van Hulle, M. M. (2003, April). A differential entropy based
method for determining the optimal embedding parameters of a signal. In 2003 IEEE
International Conference on Acoustics, Speech, and Signal Processing, 2003. Proceedings.
(ICASSP’03). (Vol. 6, pp. VI-29). IEEE.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-tolerance">
<h3><em>complexity_tolerance()</em><a class="headerlink" href="#complexity-tolerance" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_tolerance">
<span class="sig-name descname"><span class="pre">complexity_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'maxApEn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/optim_complexity_tolerance.html#complexity_tolerance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_tolerance" title="Link to this definition">#</a></dt>
<dd><p><strong>Automated selection of tolerance (r)</strong></p>
<p>Estimate and select the optimal tolerance (<em>r</em>) parameter used by other entropy and other
complexity algorithms.</p>
<p>Many complexity algorithms are built on the notion of self-similarity and recurrence, and how
often a system revisits its past states. Considering two states as identical is straightforward
for discrete systems (e.g., a sequence of <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code> states), but for
continuous signals, we cannot simply look for when the two numbers are exactly the same.
Instead, we have to pick a threshold by which to consider two points as similar.</p>
<p>The tolerance <em>r</em> is essentially this threshold value (the numerical difference between two
similar points that we “tolerate”). This parameter has a critical impact and is a major
source of inconsistencies in the literature.</p>
<p>Different methods have been described to estimate the most appropriate tolerance value:</p>
<ul class="simple">
<li><p><strong>maxApEn</strong>: Different values of tolerance will be tested and the one where the approximate
entropy (ApEn) is maximized will be selected and returned (Chen, 2008).</p></li>
<li><p><strong>recurrence</strong>: The tolerance that yields a recurrence rate (see <code class="docutils literal notranslate"><span class="pre">RQA</span></code>) close to 1% will
be returned. Note that this method is currently not suited for very long signals, as it is
based on a recurrence matrix, which size is close to n^2. Help is needed to address this
limitation.</p></li>
<li><p><strong>neighbours</strong>: The tolerance that yields a number of nearest neighbours (NN) close to 2% will
be returned.</p></li>
</ul>
<p>As these methods are computationally expensive, other fast heuristics are available:</p>
<ul class="simple">
<li><p><strong>sd</strong>: r = 0.2 * standard deviation (SD) of the signal will be returned. This is the most
commonly used value in the literature, though its appropriateness is questionable.</p></li>
<li><p><strong>makowski</strong>: Adjusted value based on the SD, the embedding dimension and the signal’s
length. See our <a class="reference external" href="https://github.com/DominiqueMakowski/ComplexityTolerance">study</a>.</p></li>
<li><p><strong>nolds</strong>: Adjusted value based on the SD and the dimension. The rationale is that
the chebyshev distance (used in various metrics) rises logarithmically with increasing
dimension. <code class="docutils literal notranslate"><span class="pre">0.5627</span> <span class="pre">*</span> <span class="pre">np.log(dimension)</span> <span class="pre">+</span> <span class="pre">1.3334</span></code> is the logarithmic trend line for the
chebyshev distance of vectors sampled from a univariate normal distribution. A constant of
<code class="docutils literal notranslate"><span class="pre">0.1164</span></code> is used so that <code class="docutils literal notranslate"><span class="pre">tolerance</span> <span class="pre">=</span> <span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">SDs</span></code> for <code class="docutils literal notranslate"><span class="pre">dimension</span> <span class="pre">=</span> <span class="pre">2</span></code> (originally in
<a class="github reference external" href="https://github.com/CSchoel/nolds">CSchoel/nolds</a>).</p></li>
<li><p><strong>singh2016</strong>: Makes a histogram of the Chebyshev distance matrix and returns the upper bound
of the modal bin.</p></li>
<li><p><strong>chon2009</strong>: Acknowledging that computing multiple ApEns is computationally expensive, Chon
(2009) suggested an approximation based a heuristic algorithm that takes into account the
length of the signal, its short-term and long-term variability, and the embedding dimension
<em>m</em>. Initially defined only for <em>m</em> in [2-7], we expanded this to work with value of <em>m</em>
(though the accuracy is not guaranteed beyond <em>m</em> = 4).</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Can be <code class="docutils literal notranslate"><span class="pre">&quot;maxApEn&quot;</span></code> (default), <code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;recurrence&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;neighbours&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;nolds&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;chon2009&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;neurokit&quot;</span></code>.</p></li>
<li><p><strong>r_range</strong> (<em>Union[list, int]</em>) – The range of tolerance values (or the number of values) to test. Only used if <code class="docutils literal notranslate"><span class="pre">method</span></code> is
<code class="docutils literal notranslate"><span class="pre">&quot;maxApEn&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;recurrence&quot;</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the default range will be used;
<code class="docutils literal notranslate"><span class="pre">np.linspace(0.02,</span> <span class="pre">0.8,</span> <span class="pre">r_range)</span> <span class="pre">*</span> <span class="pre">np.std(signal,</span> <span class="pre">ddof=1)</span></code> for <code class="docutils literal notranslate"><span class="pre">&quot;maxApEn&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">np.</span>
<span class="pre">linspace(0,</span> <span class="pre">np.max(d),</span> <span class="pre">30</span> <span class="pre">+</span> <span class="pre">1)[1:]</span></code> for <code class="docutils literal notranslate"><span class="pre">&quot;recurrence&quot;</span></code>. You can set a lower number for
faster results.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Only used if <code class="docutils literal notranslate"><span class="pre">method=&quot;maxApEn&quot;</span></code>. See <a class="reference internal" href="#neurokit2.complexity.entropy_approximate" title="neurokit2.complexity.entropy_approximate"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_approximate()</span></code></a>.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Only used if <code class="docutils literal notranslate"><span class="pre">method=&quot;maxApEn&quot;</span></code>. See <a class="reference internal" href="#neurokit2.complexity.entropy_approximate" title="neurokit2.complexity.entropy_approximate"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_approximate()</span></code></a>.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> and method is <code class="docutils literal notranslate"><span class="pre">&quot;maxApEn&quot;</span></code>, will plot the ApEn values for each value of r.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity" title="neurokit2.complexity.complexity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embedding</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> – The optimal tolerance value.</p></li>
<li><p><em>dict</em> – A dictionary containing additional information.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<ul class="simple">
<li><p><strong>Example 1</strong>: The method based on the SD of the signal is fast. The plot shows the d
distribution of the values making the signal, and the width of the arrow represents the
chosen <code class="docutils literal notranslate"><span class="pre">r</span></code> parameter.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>

<span class="go"># Fast method (based on the standard deviation)</span>
<span class="gp">In [3]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;sd&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance1.png"><img alt="../_images/p_complexity_tolerance1.png" src="../_images/p_complexity_tolerance1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">r</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.1581534263085267)</span>
</pre></div>
</div>
<p>The dimension can be taken into account:
.. ipython:: python</p>
<blockquote>
<div><p># nolds method
&#64;savefig p_complexity_tolerance2.png scale=100%
r, info = nk.complexity_tolerance(signal, method = “nolds”, dimension=3, show=True)
&#64;suppress
plt.close()</p>
</div></blockquote>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">r</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.1581534263085267)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Example 2</strong>: The method based on the recurrence rate will display the rates according to
different values of tolerance. The horizontal line indicates 5%.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">   ...: </span>                                  <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;recurrence&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance3.png"><img alt="../_images/p_complexity_tolerance3.png" src="../_images/p_complexity_tolerance3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">r</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(0.2662934154435781)</span>
</pre></div>
</div>
<p>An alternative, better suited for long signals is to use nearest neighbours.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">   ...: </span>                                  <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;neighbours&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance4.png"><img alt="../_images/p_complexity_tolerance4.png" src="../_images/p_complexity_tolerance4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Another option is to use the density of distances.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">   ...: </span>                                  <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;bin&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance5.png"><img alt="../_images/p_complexity_tolerance5.png" src="../_images/p_complexity_tolerance5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<ul class="simple">
<li><p><strong>Example 3</strong>: The default method selects the tolerance at which <em>ApEn</em> is maximized.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Slow method</span>
<span class="gp">In [10]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
<span class="gp">   ....: </span>                                  <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;maxApEn&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance6.png"><img alt="../_images/p_complexity_tolerance6.png" src="../_images/p_complexity_tolerance6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">r</span>
<span class="gh">Out[11]: </span><span class="go">np.float64(0.4902756215564327)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Example 4</strong>: The tolerance values that are tested can be modified to get a more precise
estimate.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Narrower range</span>
<span class="gp">In [12]: </span><span class="n">r</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;maxApEn&#39;</span><span class="p">,</span>
<span class="gp">   ....: </span>                                  <span class="n">r_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.002</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_tolerance7.png"><img alt="../_images/p_complexity_tolerance7.png" src="../_images/p_complexity_tolerance7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">r</span>
<span class="gh">Out[13]: </span><span class="go">np.float64(0.4973103448275862)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Chon, K. H., Scully, C. G., &amp; Lu, S. (2009). Approximate entropy for all signals. IEEE
engineering in medicine and biology magazine, 28(6), 18-23.</p></li>
<li><p>Lu, S., Chen, X., Kanters, J. K., Solomon, I. C., &amp; Chon, K. H. (2008). Automatic selection of
the threshold value r for approximate entropy. IEEE Transactions on Biomedical Engineering,
55(8), 1966-1972.</p></li>
<li><p>Chen, X., Solomon, I. C., &amp; Chon, K. H. (2008). Parameter selection criteria in approximate
entropy and sample entropy with application to neural respiratory signals. Am. J. Physiol.
Regul. Integr. Comp. Physiol.</p></li>
<li><p>Singh, A., Saini, B. S., &amp; Singh, D. (2016). An alternative approach to approximate entropy
threshold value (r) selection: application to heart rate variability and systolic blood
pressure variability under postural challenge. Medical &amp; biological engineering &amp; computing,
54(5), 723-732.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-k">
<h3><em>complexity_k()</em><a class="headerlink" href="#complexity-k" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_k">
<span class="sig-name descname"><span class="pre">complexity_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/optim_complexity_k.html#complexity_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_k" title="Link to this definition">#</a></dt>
<dd><p><strong>Automated selection of k for Higuchi Fractal Dimension (HFD)</strong></p>
<p>The optimal <em>k-max</em> is computed based on the point at which HFD values plateau for a range of
<em>k-max</em> values (see Vega, 2015).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>k_max</strong> (<em>Union[int, str, list], optional</em>) – Maximum number of interval times (should be greater than or equal to 3) to be tested. If
<code class="docutils literal notranslate"><span class="pre">max</span></code>, it selects the maximum possible value corresponding to half the length of the
signal.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualise the slope of the curve for the selected kmax value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>k</strong> (<em>float</em>) – The optimal kmax of the time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute optimal kmax.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_higuchi" title="neurokit2.complexity.fractal_higuchi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_higuchi</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">k_max</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_k</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k_max</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_k1.png"><img alt="../_images/p_complexity_k1.png" src="../_images/p_complexity_k1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">k_max</span>
<span class="gh">Out[4]: </span><span class="go">np.int64(34)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Higuchi, T. (1988). Approach to an irregular time series on the basis of the fractal theory.
Physica D: Nonlinear Phenomena, 31(2), 277-283.</p></li>
<li><p>Vega, C. F., &amp; Noel, J. (2015, June). Parameters analyzed of Higuchi’s fractal dimension for
EEG brain signals. In 2015 Signal Processing Symposium (SPSympo) (pp. 1-5). IEEE. <a class="reference external" href="https://">https://</a>
ieeexplore.ieee.org/document/7168285</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="fractal-dimension">
<h2>Fractal Dimension<a class="headerlink" href="#fractal-dimension" title="Link to this heading">#</a></h2>
<section id="fractal-katz">
<h3><em>fractal_katz()</em><a class="headerlink" href="#fractal-katz" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_katz">
<span class="sig-name descname"><span class="pre">fractal_katz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_katz.html#fractal_katz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_katz" title="Link to this definition">#</a></dt>
<dd><p><strong>Katz’s Fractal Dimension (KFD)</strong></p>
<p>Computes Katz’s Fractal Dimension (KFD). The euclidean distances between successive points in
the signal are summed and averaged, and the maximum distance between the starting point and any
other point in the sample.</p>
<p>Fractal dimensions range from 1.0 for straight lines, through approximately 1.15 for
random-walks, to approaching 1.5 for the most convoluted waveforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>kfd</strong> (<em>float</em>) – Katz’s fractal dimension of the single time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information (currently empty, but returned nonetheless
for consistency with other functions).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_linelength" title="neurokit2.complexity.fractal_linelength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_linelength</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<ul class="simple">
<li><p><strong>Step 1.</strong> Simulate different kinds of signals</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="go"># Simulate straight line</span>
<span class="gp">In [3]: </span><span class="n">straight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>

<span class="go"># Simulate random</span>
<span class="gp">In [4]: </span><span class="n">random</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;randomwalk&quot;</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">random</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">random</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="go"># Simulate simple</span>
<span class="gp">In [6]: </span><span class="n">simple</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="go"># Simulate complex</span>
<span class="gp">In [7]: </span><span class="nb">complex</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">   ...: </span>                             <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
<span class="gp">   ...: </span>                             <span class="n">noise</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">   ...: </span>

<span class="gp">In [8]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">([</span><span class="n">straight</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">simple</span><span class="p">,</span> <span class="nb">complex</span><span class="p">])</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_katz.png"><img alt="../_images/p_katz.png" src="../_images/p_katz.png" style="width: 640.0px; height: 480.0px;" />
</a>
<ul class="simple">
<li><p><strong>Step 2.</strong> Compute KFD for each of them</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">KFD</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_katz</span><span class="p">(</span><span class="n">straight</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">KFD</span>
<span class="gh">Out[10]: </span><span class="go">np.float64(1.0)</span>

<span class="gp">In [11]: </span><span class="n">KFD</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_katz</span><span class="p">(</span><span class="n">random</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">KFD</span>
<span class="gh">Out[12]: </span><span class="go">np.float64(1.6682622252349646)</span>

<span class="gp">In [13]: </span><span class="n">KFD</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_katz</span><span class="p">(</span><span class="n">simple</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">KFD</span>
<span class="gh">Out[14]: </span><span class="go">np.float64(2.041857476392026)</span>

<span class="gp">In [15]: </span><span class="n">KFD</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_katz</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">KFD</span>
<span class="gh">Out[16]: </span><span class="go">np.float64(3.726104360867858)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Katz, M. J. (1988). Fractals and the analysis of waveforms.
Computers in Biology and Medicine, 18(3), 145-156. doi:10.1016/0010-4825(88)90041-8.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-linelength">
<h3><em>fractal_linelength()</em><a class="headerlink" href="#fractal-linelength" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_linelength">
<span class="sig-name descname"><span class="pre">fractal_linelength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_linelength.html#fractal_linelength"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_linelength" title="Link to this definition">#</a></dt>
<dd><p><strong>Line Length (LL)</strong></p>
<p>Line Length (LL, also known as curve length), stems from a modification of the
<a class="reference internal" href="#neurokit2.complexity.fractal_katz" title="neurokit2.complexity.fractal_katz"><code class="xref py py-func docutils literal notranslate"><span class="pre">Katz</span> <span class="pre">fractal</span> <span class="pre">dimension</span></code></a> algorithm, with the goal of making it more
efficient and accurate (especially for seizure onset detection).</p>
<p>It basically corresponds to the average of the absolute consecutive differences of the signal,
and was made to be used within subwindows. Note that this does not technically measure the
fractal dimension, but the function was named with the <code class="docutils literal notranslate"><span class="pre">fractal_</span></code> prefix due to its
conceptual similarity with Katz’s fractal dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – Line Length.</p></li>
<li><p><em>dict</em> – A dictionary containing additional information (currently empty, but returned nonetheless
for consistency with other functions).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_katz" title="neurokit2.complexity.fractal_katz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_katz</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="gp">In [3]: </span><span class="n">ll</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_linelength</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">ll</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.11575342908508135)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Esteller, R., Echauz, J., Tcheng, T., Litt, B., &amp; Pless, B. (2001, October). Line length: an
efficient feature for seizure onset detection. In 2001 Conference Proceedings of the 23rd
Annual International Conference of the IEEE Engineering in Medicine and Biology Society (Vol.
2, pp. 1707-1710). IEEE.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-petrosian">
<h3><em>fractal_petrosian()</em><a class="headerlink" href="#fractal-petrosian" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_petrosian">
<span class="sig-name descname"><span class="pre">fractal_petrosian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_petrosian.html#fractal_petrosian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_petrosian" title="Link to this definition">#</a></dt>
<dd><p><strong>Petrosian fractal dimension (PFD)</strong></p>
<p>Petrosian (1995) proposed a fast method to estimate the fractal dimension by converting the
signal into a binary sequence from which the fractal dimension is estimated. Several variations
of the algorithm exist (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;D&quot;</span></code>), primarily differing in the
way the discrete (symbolic) sequence is created (see func:<cite>complexity_symbolize</cite> for details).
The most common method (<code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>, by default) binarizes the signal by the sign of consecutive
differences.</p>
<div class="math notranslate nohighlight">
\[\frac{log(N)}{log(N) + log(\frac{N}{N+0.4N_{\delta}})}\]</div>
<p>Most of these methods assume that the signal is periodic (without a linear trend). Linear
detrending might be useful to eliminate linear trends (see <a class="reference internal" href="signal.html#neurokit2.signal_detrend" title="neurokit2.signal_detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal_detrend()</span></code></a>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">information_mutual</span></code>, <a class="reference internal" href="#neurokit2.complexity.entropy_svd" title="neurokit2.complexity.entropy_svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_svd</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. By default,
assigns 0 and 1 to values below and above the mean. Can be <code class="docutils literal notranslate"><span class="pre">None</span></code> to skip the process (in
case the input is already discrete). See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the discrete the signal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>pfd</strong> (<em>float</em>) – The petrosian fractal dimension (PFD).</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute PFD.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="gp">In [3]: </span><span class="n">pfd</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_petrosian</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">symbolize</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_petrosian1.png"><img alt="../_images/p_fractal_petrosian1.png" src="../_images/p_fractal_petrosian1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">pfd</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.0012592763505226)</span>

<span class="gp">In [5]: </span><span class="n">info</span>
<span class="gh">Out[5]: </span><span class="go">{&#39;Symbolization&#39;: &#39;C&#39;}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Esteller, R., Vachtsevanos, G., Echauz, J., &amp; Litt, B. (2001). A comparison of waveform
fractal dimension algorithms. IEEE Transactions on Circuits and Systems I: Fundamental Theory
and Applications, 48(2), 177-183.</p></li>
<li><p>Petrosian, A. (1995, June). Kolmogorov complexity of finite sequences and recognition of
different preictal EEG patterns. In Proceedings eighth IEEE symposium on computer-based
medical systems (pp. 212-217). IEEE.</p></li>
<li><p>Kumar, D. K., Arjunan, S. P., &amp; Aliahmad, B. (2017). Fractals: applications in biological
Signalling and image processing. CRC Press.</p></li>
<li><p>Goh, C., Hamadicharef, B., Henderson, G., &amp; Ifeachor, E. (2005, June). Comparison of fractal
dimension algorithms for the computation of EEG biomarkers for dementia. In 2nd International
Conference on Computational Intelligence in Medicine and Healthcare (CIMED2005).</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-sevcik">
<h3><em>fractal_sevcik()</em><a class="headerlink" href="#fractal-sevcik" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_sevcik">
<span class="sig-name descname"><span class="pre">fractal_sevcik</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_sevcik.html#fractal_sevcik"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_sevcik" title="Link to this definition">#</a></dt>
<dd><p><strong>Sevcik Fractal Dimension (SFD)</strong></p>
<p>The SFD algorithm was proposed to calculate the fractal dimension of waveforms by Sevcik
(1998). This method can be used to quickly measure the complexity and randomness of a signal.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some papers (e.g., Wang et al. 2017) suggest adding <code class="docutils literal notranslate"><span class="pre">np.log(2)</span></code> to the numerator,
but it’s unclear why, so we stuck to the original formula for now. But if you have an idea,
please let us know!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>sfd</strong> (<em>float</em>) – The sevcik fractal dimension.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – An empty dictionary returned for consistency with the other complexity functions.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_petrosian" title="neurokit2.complexity.fractal_petrosian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_petrosian</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">sfd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_sevcik</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">sfd</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.361438527611129)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Sevcik, C. (2010). A procedure to estimate the fractal dimension of waveforms. arXiv preprint
arXiv:1003.5266.</p></li>
<li><p>Kumar, D. K., Arjunan, S. P., &amp; Aliahmad, B. (2017). Fractals: applications in biological
Signalling and image processing. CRC Press.</p></li>
<li><p>Wang, H., Li, J., Guo, L., Dou, Z., Lin, Y., &amp; Zhou, R. (2017). Fractal complexity-based
feature extraction algorithm of communication signals. Fractals, 25(04), 1740008.</p></li>
<li><p>Goh, C., Hamadicharef, B., Henderson, G., &amp; Ifeachor, E. (2005, June). Comparison of fractal
dimension algorithms for the computation of EEG biomarkers for dementia. In 2nd International
Conference on Computational Intelligence in Medicine and Healthcare (CIMED2005).</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-nld">
<h3><em>fractal_nld()</em><a class="headerlink" href="#fractal-nld" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_nld">
<span class="sig-name descname"><span class="pre">fractal_nld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_nld.html#fractal_nld"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_nld" title="Link to this definition">#</a></dt>
<dd><p><strong>Fractal dimension via Normalized Length Density (NLDFD)</strong></p>
<p>NLDFD is a very simple index corresponding to the average absolute consecutive
differences of the (standardized) signal (<code class="docutils literal notranslate"><span class="pre">np.mean(np.abs(np.diff(std_signal)))</span></code>).
This method was developed for measuring signal complexity of very short durations (&lt; 30
samples), and can be used for instance when continuous signal FD changes (or “running” FD) are
of interest (by computing it on sliding windows, see example).</p>
<p>For methods such as Higuchi’s FD, the standard deviation of the window FD increases sharply
when the epoch becomes shorter. The NLD method results in lower standard deviation especially
for shorter epochs, though at the expense of lower accuracy in average window FD.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_higuchi" title="neurokit2.complexity.fractal_higuchi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_higuchi</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>corrected</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will rescale the output value according to the power model estimated by
Kalauzi et al. (2009) to make it more comparable with “true” FD range, as follows:
<code class="docutils literal notranslate"><span class="pre">FD</span> <span class="pre">=</span> <span class="pre">1.9079*((NLD-0.097178)^0.18383)</span></code>. Note that this can result in <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> if the
result of the difference is negative.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fd</strong> (<em>DataFrame</em>) – A dataframe containing the fractal dimension across epochs.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information (currently, but returned nonetheless for
consistency with other functions).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><strong>Example 1</strong>: Usage on a short signal</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a short signal with duration of 0.5s</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="go"># Compute Fractal Dimension</span>
<span class="gp">In [3]: </span><span class="n">fd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_nld</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">fd</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.023124767861850155)</span>
</pre></div>
</div>
<p><strong>Example 2</strong>: Compute FD-NLD on non-overlapping windows</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="go"># Simulate a long signal with duration of 5s</span>
<span class="gp">In [6]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># We want windows of size=100 (0.1s)</span>
<span class="gp">In [7]: </span><span class="n">n_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">//</span> <span class="mi">100</span>  <span class="c1"># How many windows</span>

<span class="go"># Split signal into windows</span>
<span class="gp">In [8]: </span><span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">)</span>

<span class="go"># Compute FD-NLD on all windows</span>
<span class="gp">In [9]: </span><span class="n">nld</span> <span class="o">=</span> <span class="p">[</span><span class="n">nk</span><span class="o">.</span><span class="n">fractal_nld</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">]</span>

<span class="gp">In [10]: </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nld</span><span class="p">)</span>  <span class="c1"># Get average</span>
<span class="gh">Out[10]: </span><span class="go">np.float64(0.607007889678917)</span>
</pre></div>
</div>
<p><strong>Example 3</strong>: Calculate FD-NLD on sliding windows</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Simulate a long signal with duration of 5s</span>
<span class="gp">In [11]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Add period of noise</span>
<span class="gp">In [12]: </span><span class="n">signal</span><span class="p">[</span><span class="mi">1000</span><span class="p">:</span><span class="mi">3000</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="mi">1000</span><span class="p">:</span><span class="mi">3000</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>

<span class="go"># Create function-wrapper that only return the NLD value</span>
<span class="gp">In [13]: </span><span class="n">nld</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_nld</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="go"># Use them in a rolling window of 100 samples (0.1s)</span>
<span class="gp">In [14]: </span><span class="n">rolling_nld</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">nld</span><span class="p">)</span>

<span class="gp">In [15]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">([</span><span class="n">signal</span><span class="p">,</span> <span class="n">rolling_nld</span><span class="p">],</span> <span class="n">subplots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Signal&quot;</span><span class="p">,</span> <span class="s2">&quot;FD-NLD&quot;</span><span class="p">])</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_nld1.png"><img alt="../_images/p_nld1.png" src="../_images/p_nld1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Kalauzi, A., Bojić, T., &amp; Rakić, L. (2009). Extracting complexity waveforms from
one-dimensional signals. Nonlinear biomedical physics, 3(1), 1-11.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-psdslope">
<h3><em>fractal_psdslope()</em><a class="headerlink" href="#fractal-psdslope" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_psdslope">
<span class="sig-name descname"><span class="pre">fractal_psdslope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'voss1988'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_psdslope.html#fractal_psdslope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_psdslope" title="Link to this definition">#</a></dt>
<dd><p><strong>Fractal dimension via Power Spectral Density (PSD) slope</strong></p>
<p>Fractal exponent can be computed from Power Spectral Density slope (PSDslope) analysis in
signals characterized by a frequency power-law dependence.</p>
<p>It first transforms the time series into the frequency domain, and breaks down the signal into
sine and cosine waves of a particular amplitude that together “add-up” to represent the
original signal.
If there is a systematic relationship between the frequencies in the signal and the power of
those frequencies, this will reveal itself in log-log coordinates as a linear relationship. The
slope of the best fitting line is taken as an estimate of the fractal scaling exponent and can
be converted to an estimate of the fractal dimension.</p>
<p>A slope of 0 is consistent with white noise, and a slope of less than 0 but greater than -1,
is consistent with pink noise i.e., 1/f noise. Spectral slopes as steep as -2 indicate
fractional Brownian motion, the epitome of random walk processes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Method to estimate the fractal dimension from the slope,
can be <code class="docutils literal notranslate"><span class="pre">&quot;voss1988&quot;</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">&quot;hasselman2013&quot;</span></code>.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If True, returns the log-log plot of PSD versus frequency.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <code class="docutils literal notranslate"><span class="pre">signal_psd()</span></code> (such as <code class="docutils literal notranslate"><span class="pre">method</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>slope</strong> (<em>float</em>) – Estimate of the fractal dimension obtained from PSD slope analysis.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to perform PSD slope analysis.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal with Laplace Noise</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute the Fractal Dimension from PSD slope</span>
<span class="gp">In [3]: </span><span class="n">psdslope</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_psdslope</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_psdslope1.png"><img alt="../_images/p_fractal_psdslope1.png" src="../_images/p_fractal_psdslope1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">psdslope</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(2.6210307040205967)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://complexity-methods.github.io/book/power-spectral-density-psd-slope.html">https://complexity-methods.github.io/book/power-spectral-density-psd-slope.html</a></p></li>
<li><p>Hasselman, F. (2013). When the blind curve is finite: dimension estimation and model
inference based on empirical waveforms. Frontiers in Physiology, 4, 75. <a class="reference external" href="https://doi.org/10.3389/fphys.2013.00075">https://doi.org/10.3389/fphys.2013.00075</a></p></li>
<li><p>Voss, R. F. (1988). Fractals in nature: From characterization to simulation. The Science of
Fractal Images, 21-70.</p></li>
<li><p>Eke, A., Hermán, P., Kocsis, L., and Kozak, L. R. (2002). Fractal characterization of
complexity in temporal physiological signals. Physiol. Meas. 23, 1-38.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-higuchi">
<h3><em>fractal_higuchi()</em><a class="headerlink" href="#fractal-higuchi" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_higuchi">
<span class="sig-name descname"><span class="pre">fractal_higuchi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_higuchi.html#fractal_higuchi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_higuchi" title="Link to this definition">#</a></dt>
<dd><p><strong>Higuchi’s Fractal Dimension (HFD)</strong></p>
<p>The Higuchi’s Fractal Dimension (HFD) is an approximate value for the box-counting dimension for
time series. It is computed by reconstructing k-max number of new data sets. For each
reconstructed data set, curve length is computed and plotted against its corresponding
<em>k</em>-value on a log-log scale. HFD corresponds to the slope of the least-squares linear trend.</p>
<p>Values should fall between 1 and 2. For more information about the <em>k</em> parameter selection, see
the <a class="reference internal" href="#neurokit2.complexity.complexity_k" title="neurokit2.complexity.complexity_k"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_k()</span></code></a> optimization function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>k_max</strong> (<em>str or int</em>) – Maximum number of interval times (should be greater than or equal to 2).
If <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>, the optimal k-max is estimated using <a class="reference internal" href="#neurokit2.complexity.complexity_k" title="neurokit2.complexity.complexity_k"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_k()</span></code></a>, which is slow.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualise the slope of the curve for the selected k_max value.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Currently not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>HFD</strong> (<em>float</em>) – Higuchi’s fractal dimension of the time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute Higuchi’s fractal dimension.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_k" title="neurokit2.complexity.complexity_k"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_k</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">k_max</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span>  <span class="n">nk</span><span class="o">.</span><span class="n">complexity_k</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k_max</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">hfd</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_higuchi</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k_max</span><span class="o">=</span><span class="n">k_max</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_higuchi1.png"><img alt="../_images/p_fractal_higuchi1.png" src="../_images/p_fractal_higuchi1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<a class="reference internal image-reference" href="../_images/p_fractal_higuchi2.png"><img alt="../_images/p_fractal_higuchi2.png" src="../_images/p_fractal_higuchi2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">hfd</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(1.9442839346289713)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Higuchi, T. (1988). Approach to an irregular time series on the basis of the fractal theory.
Physica D: Nonlinear Phenomena, 31(2), 277-283.</p></li>
<li><p>Vega, C. F., &amp; Noel, J. (2015, June). Parameters analyzed of Higuchi’s fractal dimension for
EEG brain signals. In 2015 Signal Processing Symposium (SPSympo) (pp. 1-5). IEEE.
<a class="reference external" href="https://ieeexplore.ieee.org/document/7168285">https://ieeexplore.ieee.org/document/7168285</a></p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-density">
<h3><em>fractal_density()</em><a class="headerlink" href="#fractal-density" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_density">
<span class="sig-name descname"><span class="pre">fractal_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_density.html#fractal_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_density" title="Link to this definition">#</a></dt>
<dd><p><strong>Density Fractal Dimension (DFD)</strong></p>
<p>This is a <strong>Work in Progress (WIP)</strong>. The idea is to find a way of, essentially, averaging
attractors. Because one can not directly average the trajectories, one way is to convert the
attractor to a 2D density matrix that we can use similarly to a time-frequency heatmap. However,
it is very unclear how to then derive meaningful indices from this density plot. Also, how many
bins, or smoothing, should one use?</p>
<p>Basically, this index is exploratory and should not be used in its state. However, if you’re
interested in the problem of “average” attractors (e.g., from multiple epochs / trials), and
you want to think about it with us, feel free to let us know!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>bins</strong> (<em>int</em>) – If not <code class="docutils literal notranslate"><span class="pre">None</span></code> but an integer, will use this value for the number of bins instead of a
value based on the <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> parameter.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the density matrix. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passe.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dfd</strong> (<em>float</em>) – The density fractal dimension.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">dfd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_density</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_density1.png"><img alt="../_images/p_fractal_density1.png" src="../_images/p_fractal_density1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">epochs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">epochs_create</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">dfd</span><span class="p">,</span> <span class="n">info1</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_density</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_density2.png"><img alt="../_images/p_fractal_density2.png" src="../_images/p_fractal_density2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Compare the complexity of two signals.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Help is needed to find a way to make statistics and comparing two density maps.</p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="gp">In [8]: </span><span class="n">sig2</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">epochs2</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">epochs_create</span><span class="p">(</span><span class="n">sig2</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">dfd</span><span class="p">,</span> <span class="n">info2</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_density</span><span class="p">(</span><span class="n">epochs2</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="go"># Difference between two density maps</span>
<span class="gp">In [11]: </span><span class="n">D</span> <span class="o">=</span> <span class="n">info1</span><span class="p">[</span><span class="s2">&quot;Average&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">info2</span><span class="p">[</span><span class="s2">&quot;Average&quot;</span><span class="p">]</span>

<span class="gp">In [12]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu&#39;</span><span class="p">)</span>
<span class="gh">Out[12]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x260d19ee5d0&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_density3.png"><img alt="../_images/p_fractal_density3.png" src="../_images/p_fractal_density3.png" style="width: 640.0px; height: 480.0px;" />
</a>
</dd></dl>

</section>
<section id="fractal-hurst">
<h3><em>fractal_hurst()</em><a class="headerlink" href="#fractal-hurst" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_hurst">
<span class="sig-name descname"><span class="pre">fractal_hurst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_hurst.html#fractal_hurst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_hurst" title="Link to this definition">#</a></dt>
<dd><p><strong>Hurst Exponent (H)</strong></p>
<p>This function estimates the Hurst exponent via the standard rescaled range (R/S) approach, but
other methods exist, such as Detrended Fluctuation Analysis (DFA, see <a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a>).</p>
<p>The Hurst exponent is a measure for the “long-term memory” of a signal. It can be used to
determine whether the time series is more, less, or equally likely to increase if it has
increased in previous steps. This property makes the Hurst exponent especially interesting for
the analysis of stock data. It typically ranges from 0 to 1, with 0.5 corresponding to a
Brownian motion. If H &lt; 0.5, the time-series covers less “distance” than a random walk (the
memory of the signal decays faster than at random), and vice versa.</p>
<p>The R/S approach first splits the time series into non-overlapping subseries of length n. R and
S (sigma) are then calculated for each subseries and the mean is taken over all subseries
yielding (R/S)_n. This process is repeated for several lengths <em>n</em>. The final exponent is then
derived from fitting a straight line to the plot of <span class="math notranslate nohighlight">\(log((R/S)_n)\)</span> vs <span class="math notranslate nohighlight">\(log(n)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.
or dataframe.</p></li>
<li><p><strong>scale</strong> (<em>list</em>) – A list containing the lengths of the windows (number of data points in each subseries) that
the signal is divided into. See <a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a> for more information.</p></li>
<li><p><strong>corrected</strong> (<em>boolean</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the Anis-Lloyd-Peters correction factor will be applied to the
output according to the expected value for the individual (R/S) values.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns a plot.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_dfa</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate Signal with duration of 2s</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="go"># Compute Hurst Exponent</span>
<span class="gp">In [3]: </span><span class="n">h</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_hurst</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">h</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.965406529715463)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Brandi, G., &amp; Di Matteo, T. (2021). On the statistics of scaling exponents and the
Multiscaling Value at Risk. The European Journal of Finance, 1-22.</p></li>
<li><p>Annis, A. A., &amp; Lloyd, E. H. (1976). The expected value of the adjusted rescaled Hurst range
of independent normal summands. Biometrika, 63(1), 111-116.</p></li>
<li><p><a class="github reference external" href="https://github.com/CSchoel/nolds">CSchoel/nolds</a></p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-correlation">
<h3><em>fractal_correlation()</em><a class="headerlink" href="#fractal-correlation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_correlation">
<span class="sig-name descname"><span class="pre">fractal_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_correlation.html#fractal_correlation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_correlation" title="Link to this definition">#</a></dt>
<dd><p><strong>Correlation Dimension (CD)</strong></p>
<p>The Correlation Dimension (CD, also denoted <em>D2</em>) is a lower bound estimate of the fractal
dimension of a signal.</p>
<p>The time series is first <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">time-delay</span> <span class="pre">embedded</span></code></a>, and distances
between all points in the trajectory are calculated. The “correlation sum” is then computed,
which is the proportion of pairs of points whose distance is smaller than a given radius. The
final correlation dimension is then approximated by a log-log graph of correlation sum vs. a
sequence of radiuses.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">fractal_correlation()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_cd()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>radius</strong> (<em>Union[str, int, list]</em>) – The sequence of radiuses to test. If an integer is passed, will get an exponential sequence
of length <code class="docutils literal notranslate"><span class="pre">radius</span></code> ranging from 2.5% to 50% of the distance range. Methods implemented in
other packages can be used via <code class="docutils literal notranslate"><span class="pre">&quot;nolds&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;Corr_Dim&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;boon2008&quot;</span></code>.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot of correlation dimension if <code class="docutils literal notranslate"><span class="pre">True</span></code>. Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed (not used for now).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cd</strong> (<em>float</em>) – The Correlation Dimension (CD) of the time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute the correlation dimension.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>For some completely unclear reasons, uncommenting the following examples messes up the figures
path of all the subsequent documented function. So, commenting it for now.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># @savefig p_fractal_correlation1.png scale=100%</span>
<span class="go"># cd, info = nk.fractal_correlation(signal, radius=32, show=True)</span>
<span class="go"># @suppress</span>
<span class="go"># plt.close()</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># @savefig p_fractal_correlation2.png scale=100%</span>
<span class="c1"># cd, info = nk.fractal_correlation(signal, radius=&quot;nolds&quot;, show=True)</span>
<span class="c1"># @suppress</span>
<span class="c1"># plt.close()</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># @savefig p_fractal_correlation3.png scale=100%</span>
<span class="c1"># cd, info = nk.fractal_correlation(signal, radius=&#39;boon2008&#39;, show=True)</span>
<span class="c1"># @suppress</span>
<span class="c1"># plt.close()</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Bolea, J., Laguna, P., Remartínez, J. M., Rovira, E., Navarro, A., &amp; Bailón, R. (2014).
Methodological framework for estimating the correlation dimension in HRV signals.
Computational and mathematical methods in medicine, 2014.</p></li>
<li><p>Boon, M. Y., Henry, B. I., Suttle, C. M., &amp; Dain, S. J. (2008). The correlation dimension:
A useful objective measure of the transient visual evoked potential?. Journal of vision,
8(1), 6-6.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-dfa">
<h3><em>fractal_dfa()</em><a class="headerlink" href="#fractal-dfa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_dfa">
<span class="sig-name descname"><span class="pre">fractal_dfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multifractal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxdfa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_dfa.html#fractal_dfa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_dfa" title="Link to this definition">#</a></dt>
<dd><p><strong>(Multifractal) Detrended Fluctuation Analysis (DFA or MFDFA)</strong></p>
<p>Detrended fluctuation analysis (DFA) is used to find long-term statistical dependencies in time
series.</p>
<p>For monofractal DFA, the output <em>alpha</em> <span class="math notranslate nohighlight">\(\alpha\)</span> corresponds to the slope of the linear
trend between the scale factors and the fluctuations. For multifractal DFA, the slope values
under different <em>q</em> values are actually generalised Hurst exponents <em>h</em>. Monofractal DFA
corresponds to MFDFA with <em>q = 2</em>, and its output is actually an estimation of the
<strong>Hurst exponent</strong> (<span class="math notranslate nohighlight">\(h_{(2)}\)</span>).</p>
<p>The Hurst exponent is the measure of long range autocorrelation of a signal, and
<span class="math notranslate nohighlight">\(h_{(2)} &gt; 0.5\)</span> suggests the presence of long range correlation, while
<span class="math notranslate nohighlight">\(h_{(2)} &lt; 0.5`suggests short range correlations. If :math:`h_{(2)} = 0.5\)</span>, it indicates
uncorrelated indiscriminative fluctuations, i.e. a Brownian motion.</p>
<figure class="align-default">
<img alt="Illustration of DFA (Douglas et al., 2022)." src="../_images/douglas2022a.png" />
</figure>
<p>Multifractal DFA returns the generalised Hurst exponents <em>h</em> for different values of <em>q</em>. It is
converted to the multifractal <strong>scaling exponent</strong> <em>Tau</em> <span class="math notranslate nohighlight">\(\tau_{(q)}\)</span>, which non-linear
relationship with <em>q</em> can indicate multifractility. From there, we derive the singularity
exponent <em>H</em> (or <span class="math notranslate nohighlight">\(\alpha\)</span>) (also known as Hölder’s exponents) and the singularity
dimension <em>D</em> (or <span class="math notranslate nohighlight">\(f(\alpha)\)</span>). The variation of <em>D</em> with <em>H</em> is known as multifractal
singularity spectrum (MSP), and usually has shape of an inverted parabola. It measures the long
range correlation property of a signal. From these elements, different features are extracted:</p>
<ul class="simple">
<li><p><strong>Width</strong>: The width of the singularity spectrum, which quantifies the degree of the
multifractality. In the case of monofractal signals, the MSP width is zero, since <em>h</em>(q) is
independent of <em>q</em>.</p></li>
<li><p><strong>Peak</strong>: The value of the singularity exponent <em>H</em> corresponding to the peak of
singularity dimension <em>D</em>. It is a measure of the self-affinity of the signal, and a high
value is an indicator of high degree of correlation between the data points. In the other
words, the process is recurrent and repetitive.</p></li>
<li><p><strong>Mean</strong>: The mean of the maximum and minimum values of singularity exponent <em>H</em>, which
quantifies the average fluctuations of the signal.</p></li>
<li><p><strong>Max</strong>: The value of singularity spectrum <em>D</em> corresponding to the maximum value of
singularity exponent <em>H</em>, which indicates the maximum fluctuation of the signal.</p></li>
<li><p><strong>Delta</strong>: the vertical distance between the singularity spectrum <em>D</em> where the singularity
exponents are at their minimum and maximum. Corresponds to the range of fluctuations of the
signal.</p></li>
<li><p><strong>Asymmetry</strong>: The Asymmetric Ratio (AR) corresponds to the centrality of the peak of the
spectrum. AR = 0.5 indicates that the multifractal spectrum is symmetric (Orozco-Duque et
al., 2015).</p></li>
<li><p><strong>Fluctuation</strong>: The <em>h</em>-fluctuation index (hFI) is defined as the power of the second
derivative of <em>h</em>(q). See Orozco-Duque et al. (2015).</p></li>
<li><p><strong>Increment</strong>: The cumulative function of the squared increments (<span class="math notranslate nohighlight">\(\alpha CF\)</span>) of the
generalized Hurst’s exponents between consecutive moment orders is a more robust index of the
distribution of the generalized Hurst’s exponents (Faini et al., 2021).</p></li>
</ul>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">fractal_dfa()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_dfa()</span></code>, and its
multifractal variant can be directly accessed via <code class="docutils literal notranslate"><span class="pre">fractal_mfdfa()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_mfdfa()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Help is needed to implement the modified formula to compute the slope when
<em>q</em> = 0. See for instance Faini et al. (2021). See <a class="github reference external" href="https://github.com/LRydin/MFDFA/issues/33">LRydin/MFDFA#33</a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>scale</strong> (<em>list</em>) – A list containing the lengths of the windows (number of data points in each subseries) that
the signal is divided into. Also referred to as Tau <span class="math notranslate nohighlight">\(\tau\)</span>. If <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>, will
set it to a logarithmic scale (so that each window scale has the same weight) with a
minimum of 4 and maximum of a tenth of the length (to have more than 10 windows to
calculate the average fluctuation).</p></li>
<li><p><strong>overlap</strong> (<em>bool</em>) – Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>, where the windows will have a 50% overlap with each other, otherwise
non-overlapping windows will be used.</p></li>
<li><p><strong>integrate</strong> (<em>bool</em>) – It is common practice to convert the signal to a random walk (i.e., detrend and integrate,
which corresponds to the signal ‘profile’) in order to avoid having too small exponent
values. Note that it leads to the flattening of the signal, which can lead to the loss of
some details (see Ihlen, 2012 for an explanation). Note that for strongly anticorrelated
signals, this transformation should be applied  two times (i.e., provide
<code class="docutils literal notranslate"><span class="pre">np.cumsum(signal</span> <span class="pre">-</span> <span class="pre">np.mean(signal))</span></code> instead of <code class="docutils literal notranslate"><span class="pre">signal</span></code>).</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the polynomial trend for detrending. 1 corresponds to a linear detrending.</p></li>
<li><p><strong>multifractal</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, compute Multifractal Detrended Fluctuation Analysis (MFDFA), in which case the
argument <code class="docutils literal notranslate"><span class="pre">q</span></code> is taken into account.</p></li>
<li><p><strong>q</strong> (<em>Union[int, list, np.array]</em>) – The sequence of fractal exponents when <code class="docutils literal notranslate"><span class="pre">multifractal=True</span></code>. Must be a sequence between
-10 and 10 (note that zero will be removed, since the code does not converge there).
Setting <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">2</span></code> (default for DFA) gives a result of a standard DFA. For instance, Ihlen
(2012) uses <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">[-5,</span> <span class="pre">-3,</span> <span class="pre">-1,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5]</span></code> (default when for multifractal). In general,
positive q moments amplify the contribution of fractal components with larger amplitude and
negative q moments amplify the contribution of fractal with smaller amplitude (Kantelhardt
et al., 2002).</p></li>
<li><p><strong>maxdfa</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will locate the knee of the fluctuations (using <a class="reference internal" href="misc.html#neurokit2.misc.find_knee" title="neurokit2.misc.find_knee"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_knee()</span></code></a>) and use
that as a maximum scale value. It computes max. DFA (a similar method exists in
<a class="reference internal" href="#neurokit2.complexity.entropy_rate" title="neurokit2.complexity.entropy_rate"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_rate()</span></code></a>).</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualise the trend between the window size and the fluctuations.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Currently not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dfa</strong> (<em>float or pd.DataFrame</em>) – If <code class="docutils literal notranslate"><span class="pre">multifractal</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, one DFA value is returned for a single time series.</p></li>
<li><p><strong>parameters</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute DFA. If <code class="docutils literal notranslate"><span class="pre">multifractal</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the dictionary contains q value, a
series of windows, fluctuations of each window and the
slopes value of the log2(windows) versus log2(fluctuations) plot. If
<code class="docutils literal notranslate"><span class="pre">multifractal</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the dictionary additionally contains the
parameters of the singularity spectrum.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_hurst" title="neurokit2.complexity.fractal_hurst"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_hurst</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.fractal_tmf" title="neurokit2.complexity.fractal_tmf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_tmf</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_rate" title="neurokit2.complexity.entropy_rate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_rate</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Example 1:</strong> Monofractal DFA</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">dfa</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_dfa</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_dfa1.png"><img alt="../_images/p_fractal_dfa1.png" src="../_images/p_fractal_dfa1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dfa</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.651052299795863)</span>
</pre></div>
</div>
<p>As we can see from the plot, the final value, corresponding to the slope of the red line,
doesn’t capture properly the relationship. We can adjust the <em>scale factors</em> to capture the
fractality of short-term fluctuations.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">scale</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">expspace</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">dfa</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_dfa</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_dfa2.png"><img alt="../_images/p_fractal_dfa2.png" src="../_images/p_fractal_dfa2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Example 2:</strong> Multifractal DFA (MFDFA)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">mfdfa</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mfdfa</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_dfa3.png"><img alt="../_images/p_fractal_dfa3.png" src="../_images/p_fractal_dfa3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">mfdfa</span>
<span class="gh">Out[8]: </span>
<span class="go">      Width      Peak      Mean  ...  Asymmetry  Fluctuation  Increment</span>
<span class="go">0  0.816579  0.776432  0.881745  ...  -0.371032     0.000247   0.039944</span>

<span class="go">[1 rows x 8 columns]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Faini, A., Parati, G., &amp; Castiglioni, P. (2021). Multiscale assessment of the degree of
multifractality for physiological time series. Philosophical Transactions of the Royal
Society A, 379(2212), 20200254.</p></li>
<li><p>Orozco-Duque, A., Novak, D., Kremen, V., &amp; Bustamante, J. (2015). Multifractal analysis for
grading complex fractionated electrograms in atrial fibrillation. Physiological Measurement,
36(11), 2269-2284.</p></li>
<li><p>Ihlen, E. A. F. E. (2012). Introduction to multifractal detrended
fluctuation analysis in Matlab. Frontiers in physiology, 3, 141.</p></li>
<li><p>Kantelhardt, J. W., Zschiegner, S. A., Koscielny-Bunde, E., Havlin, S.,
Bunde, A., &amp; Stanley, H. E. (2002). Multifractal detrended fluctuation
analysis of nonstationary time series. Physica A: Statistical
Mechanics and its Applications, 316(1-4), 87-114.</p></li>
<li><p>Hardstone, R., Poil, S. S., Schiavone, G., Jansen, R., Nikulin, V. V.,
Mansvelder, H. D., &amp; Linkenkaer-Hansen, K. (2012). Detrended
fluctuation analysis: a scale-free view on neuronal oscillations.
Frontiers in physiology, 3, 450.</p></li>
</ul>
</dd></dl>

</section>
<section id="fractal-tmf">
<h3><em>fractal_tmf()</em><a class="headerlink" href="#fractal-tmf" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_tmf">
<span class="sig-name descname"><span class="pre">fractal_tmf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/fractal_tmf.html#fractal_tmf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_tmf" title="Link to this definition">#</a></dt>
<dd><p><strong>Multifractal Nonlinearity (tMF)</strong></p>
<p>The Multifractal Nonlinearity index (<em>t</em>MF) is the <em>t</em>-value resulting from the comparison
of the multifractality of the signal (measured by the spectrum width, see
<a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a>) with the multifractality of linearized
<a class="reference internal" href="signal.html#neurokit2.signal_surrogate" title="neurokit2.signal_surrogate"><code class="xref py py-func docutils literal notranslate"><span class="pre">surrogates</span></code></a> obtained by the IAAFT method (i.e., reshuffled series
with comparable linear structure).</p>
<p>This statistics grows larger the more the original series departs from the multifractality
attributable to the linear structure of IAAFT surrogates. When p-value reaches significance, we
can conclude that the signal’s multifractality encodes processes that a linear contingency
cannot.</p>
<p>This index provides an extension of the assessment of multifractality, of which the
multifractal spectrum is by itself a measure of heterogeneity, rather than interactivity.
As such, it cannot alone be used to assess the specific presence of cascade-like interactivity
in the time series, but must be compared to the spectrum of a sample of its surrogates.</p>
<figure class="align-default">
<a class="reference external image-reference" href="https://doi.org/10.3389/fphys.2019.00998"><img alt="Figure from Bell et al. (2019)." src="../_images/bell2019.jpg" />
</a>
</figure>
<p>Both significantly negative and positive values can indicate interactivity, as any difference
from the linear structure represented by the surrogates is an indication of nonlinear
contingence. Indeed, if the degree of heterogeneity for the original series is significantly
less than for the sample of linear surrogates, that is no less evidence of a failure of
linearity than if the degree of heterogeneity is significantly greater.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Help us review the implementation of this index by checking-it out and letting us know
wether it is correct or not.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Number of surrogates. The literature uses values between 30 and 40.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments to be passed to <a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-func docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – tMF index.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information, such as the p-value.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_dfa" title="neurokit2.complexity.fractal_dfa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_dfa</span></code></a>, <a class="reference internal" href="signal.html#neurokit2.signal_surrogate" title="neurokit2.signal_surrogate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal_surrogate</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="go"># Compute tMF</span>
<span class="gp">In [3]: </span><span class="n">tMF</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_tmf</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_tmf.png"><img alt="../_images/p_fractal_tmf.png" src="../_images/p_fractal_tmf.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">tMF</span>  <span class="c1"># t-value</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(11.886934706218392)</span>

<span class="gp">In [5]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span>  <span class="c1"># p-value</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(8.955077454517305e-21)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Ihlen, E. A., &amp; Vereijken, B. (2013). Multifractal formalisms of human behavior. Human
movement science, 32(4), 633-651.</p></li>
<li><p>Kelty-Stephen, D. G., Palatinus, K., Saltzman, E., &amp; Dixon, J. A. (2013). A tutorial on
multifractality, cascades, and interactivity for empirical time series in ecological science.
Ecological Psychology, 25(1), 1-62.</p></li>
<li><p>Bell, C. A., Carver, N. S., Zbaracki, J. A., &amp; Kelty-Stephen, D. G. (2019). Non-linear
amplification of variability through interaction across scales supports greater accuracy in
manual aiming: evidence from a multifractal analysis with comparisons to linear surrogates in
the fitts task. Frontiers in physiology, 10, 998.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="entropy">
<h2>Entropy<a class="headerlink" href="#entropy" title="Link to this heading">#</a></h2>
<section id="entropy-shannon">
<h3><em>entropy_shannon()</em><a class="headerlink" href="#entropy-shannon" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_shannon">
<span class="sig-name descname"><span class="pre">entropy_shannon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_shannon.html#entropy_shannon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_shannon" title="Link to this definition">#</a></dt>
<dd><p><strong>Shannon entropy (SE or ShanEn)</strong></p>
<p>Compute Shannon entropy (SE). Entropy is a measure of unpredictability of the
state, or equivalently, of its average information content. Shannon entropy (SE) is one of the
first and most basic measures of entropy and a foundational concept of information theory,
introduced by Shannon (1948) to quantify the amount of information in a variable.</p>
<div class="math notranslate nohighlight">
\[ShanEn = -\sum_{x \in \mathcal{X}} p(x) \log_2 p(x)\]</div>
<p>Shannon attempted to extend Shannon entropy in what has become known as Differential Entropy
(see <a class="reference internal" href="#neurokit2.complexity.entropy_differential" title="neurokit2.complexity.entropy_differential"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_differential()</span></code></a>).</p>
<p>Because Shannon entropy was meant for symbolic sequences (discrete events such as [“A”, “B”,
“B”, “A”]), it does not do well with continuous signals. One option is to binarize (i.e., cut)
the signal into a number of bins using for instance <code class="docutils literal notranslate"><span class="pre">pd.cut(signal,</span> <span class="pre">bins=100,</span> <span class="pre">labels=False)</span></code>.
This can be done automatically using the <code class="docutils literal notranslate"><span class="pre">method</span></code> argument, which will be transferred to
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a>.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_shannon()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_se()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The logarithmic base to use, defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>, giving a unit in <em>bits</em>. Note that <code class="docutils literal notranslate"><span class="pre">scipy.</span>
<span class="pre">stats.entropy()</span></code> uses Euler’s number (<code class="docutils literal notranslate"><span class="pre">np.e</span></code>) as default (the natural logarithm), giving
a measure of information expressed in <em>nats</em>.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. <code class="docutils literal notranslate"><span class="pre">None</span></code> by
default, which skips the process (and assumes the input is already discrete). See
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the discrete the signal.</p></li>
<li><p><strong>freq</strong> (<em>np.array</em>) – Instead of a signal, a vector of probabilities can be provided (used for instance in
<a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_permutation()</span></code></a>).</p></li>
<li><p><strong>**kwargs</strong> – Optional arguments. Not used for now.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>shanen</strong> (<em>float</em>) – The Shannon entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute Shannon entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_differential" title="neurokit2.complexity.entropy_differential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_differential</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_cumulativeresidual" title="neurokit2.complexity.entropy_cumulativeresidual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_cumulativeresidual</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_tsallis" title="neurokit2.complexity.entropy_tsallis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_tsallis</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_renyi" title="neurokit2.complexity.entropy_renyi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_renyi</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_maximum" title="neurokit2.complexity.entropy_maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_maximum</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">_</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">(np.float64(1.8423709931771086), {&#39;Symbolization&#39;: None, &#39;Base&#39;: 2})</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Simulate a Signal with Laplace Noise</span>
<span class="gp">In [5]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="go"># Compute Shannon&#39;s Entropy</span>
<span class="gp">In [6]: </span><span class="n">shanen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_shannon1.png"><img alt="../_images/p_entropy_shannon1.png" src="../_images/p_entropy_shannon1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">shanen</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(1.5529551820157574)</span>
</pre></div>
</div>
<p>Compare with <code class="docutils literal notranslate"><span class="pre">scipy</span></code> (using the same base).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span>

<span class="go"># Make the binning ourselves</span>
<span class="gp">In [9]: </span><span class="n">binned</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">binned</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">())</span>
<span class="gh">Out[10]: </span><span class="go">np.float64(1.076426505950179)</span>

<span class="gp">In [11]: </span><span class="n">shanen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon</span><span class="p">(</span><span class="n">binned</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">shanen</span>
<span class="gh">Out[12]: </span><span class="go">np.float64(1.076426505950179)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Shannon, C. E. (1948). A mathematical theory of communication. The Bell system technical
journal, 27(3), 379-423.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-maximum">
<h3><em>entropy_maximum()</em><a class="headerlink" href="#entropy-maximum" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_maximum">
<span class="sig-name descname"><span class="pre">entropy_maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_maximum.html#entropy_maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_maximum" title="Link to this definition">#</a></dt>
<dd><p><strong>Maximum Entropy (MaxEn)</strong></p>
<p>Provides an upper bound for the entropy of a random variable, so that the empirical entropy
(obtained for instance with <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>) will lie in between 0 and max. entropy.</p>
<p>It can be useful to normalize the empirical entropy by the maximum entropy (which is made by
default in some algorithms).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>maxen</strong> (<em>float</em>) – The maximum entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – An empty dictionary returned for consistency with the other complexity functions.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">maxen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_maximum</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">maxen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(2.0)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="entropy-differential">
<h3><em>entropy_differential()</em><a class="headerlink" href="#entropy-differential" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_differential">
<span class="sig-name descname"><span class="pre">entropy_differential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_differential.html#entropy_differential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_differential" title="Link to this definition">#</a></dt>
<dd><p><strong>Differential entropy (DiffEn)</strong></p>
<p>Differential entropy (DiffEn; also referred to as continuous entropy) started as an
attempt by Shannon to extend Shannon entropy. However, differential entropy presents some
issues too, such as that it can be negative even for simple distributions (such as the uniform
distribution).</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_differential()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_diffen()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The logarithmic base to use, defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>, giving a unit in <em>bits</em>. Note that <code class="docutils literal notranslate"><span class="pre">scipy.</span>
<span class="pre">stats.entropy()</span></code> uses Euler’s number (<code class="docutils literal notranslate"><span class="pre">np.e</span></code>) as default (the natural logarithm), giving
a measure of information expressed in <em>nats</em>.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments passed to <code class="docutils literal notranslate"><span class="pre">scipy.stats.differential_entropy()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>diffen</strong> (<em>float</em>) – The Differential entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute Differential entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_cumulativeresidual" title="neurokit2.complexity.entropy_cumulativeresidual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_cumulativeresidual</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_kl" title="neurokit2.complexity.entropy_kl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_kl</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal with Laplace Noise</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Compute Differential Entropy</span>
<span class="gp">In [3]: </span><span class="n">diffen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_differential</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">diffen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.4930395678012545)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.differential_entropy.html">scipy.stats.differential_entropy()</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Differential_entropy">https://en.wikipedia.org/wiki/Differential_entropy</a></p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-power">
<h3><em>entropy_power()</em><a class="headerlink" href="#entropy-power" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_power">
<span class="sig-name descname"><span class="pre">entropy_power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_power.html#entropy_power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_power" title="Link to this definition">#</a></dt>
<dd><p><strong>Entropy Power (PowEn)</strong></p>
<p>The Shannon Entropy Power (PowEn or SEP) is a measure of the effective variance of a random
vector. It is based on the estimation of the density of the variable, thus relying on <code class="xref py py-func docutils literal notranslate"><span class="pre">density()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We are not sure at all about the correct implementation of this function. Please consider
helping us by double-checking the code against the formulas in the references.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">density_bandwidth()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>powen</strong> (<em>float</em>) – The computed entropy power measure.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">information_fisershannon</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="gp">In [3]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">powen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_power</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">powen</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.05855921535412314)</span>

<span class="go"># Visualize the distribution that the entropy power is based on</span>
<span class="gp">In [6]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Values&quot;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;Density&quot;</span><span class="p">])</span>
<span class="gh">Out[6]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x260cd1fdf90&gt;]</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/entropy_power2.png"><img alt="../_images/entropy_power2.png" src="../_images/entropy_power2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Change density bandwidth.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">powen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_power</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">powen</span>
<span class="gh">Out[8]: </span><span class="go">np.float64(0.0585589828096633)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Guignard, F., Laib, M., Amato, F., &amp; Kanevski, M. (2020). Advanced analysis of temporal data
using Fisher-Shannon information: theoretical development and application in geosciences.
Frontiers in Earth Science, 8, 255.</p></li>
<li><p>Vignat, C., &amp; Bercher, J. F. (2003). Analysis of signals in the Fisher-Shannon information
plane. Physics Letters A, 312(1-2), 27-33.</p></li>
<li><p>Dembo, A., Cover, T. M., &amp; Thomas, J. A. (1991). Information theoretic inequalities. IEEE
Transactions on Information theory, 37(6), 1501-1518.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-tsallis">
<h3><em>entropy_tsallis()</em><a class="headerlink" href="#entropy-tsallis" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_tsallis">
<span class="sig-name descname"><span class="pre">entropy_tsallis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_tsallis.html#entropy_tsallis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_tsallis" title="Link to this definition">#</a></dt>
<dd><p><strong>Tsallis entropy (TSEn)</strong></p>
<p>Tsallis Entropy is an extension of <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a> to the case where
entropy is nonextensive. It is similarly computed from a vector of probabilities of different
states. Because it works on discrete inputs (e.g., [A, B, B, A, B]), it requires to transform
the continuous signal into a discrete one.</p>
<div class="math notranslate nohighlight">
\[TSEn = \frac{1}{q - 1} \left( 1 - \sum_{x \in \mathcal{X}} p(x)^q \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>q</strong> (<em>float</em>) – Tsallis’s <em>q</em> parameter, sometimes referred to as the entropic-index (default to 1).</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. <code class="docutils literal notranslate"><span class="pre">None</span></code> by
default, which skips the process (and assumes the input is already discrete). See
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the discrete the signal.</p></li>
<li><p><strong>freq</strong> (<em>np.array</em>) – Instead of a signal, a vector of probabilities can be provided.</p></li>
<li><p><strong>**kwargs</strong> – Optional arguments. Not used for now.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>tsen</strong> (<em>float</em>) – The Tsallis entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.fractal_petrosian" title="neurokit2.complexity.fractal_petrosian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_petrosian</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_renyi" title="neurokit2.complexity.entropy_renyi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_renyi</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">tsen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_tsallis</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">tsen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.5229550675313184)</span>

<span class="gp">In [5]: </span><span class="n">shanen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">shanen</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(1.5229550675313184)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Tsallis, C. (2009). Introduction to nonextensive statistical mechanics: approaching a complex
world. Springer, 1(1), 2-1.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-renyi">
<h3><em>entropy_renyi()</em><a class="headerlink" href="#entropy-renyi" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_renyi">
<span class="sig-name descname"><span class="pre">entropy_renyi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_renyi.html#entropy_renyi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_renyi" title="Link to this definition">#</a></dt>
<dd><p><strong>Rényi entropy (REn or H)</strong></p>
<p>In information theory, the Rényi entropy <em>H</em> generalizes the Hartley entropy, the Shannon
entropy, the collision entropy and the min-entropy.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha = 0\)</span>: the Rényi entropy becomes what is known as the <strong>Hartley entropy</strong>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha = 1\)</span>: the Rényi entropy becomes the <strong>:func:`Shannon entropy &lt;entropy_shannon&gt;`</strong>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha = 2\)</span>: the Rényi entropy becomes the collision entropy, which corresponds to
the surprisal of “rolling doubles”.</p></li>
</ul>
<p>It is mathematically defined as:</p>
<div class="math notranslate nohighlight">
\[REn = \frac{1}{1-\alpha} \log_2 \left( \sum_{x \in \mathcal{X}} p(x)^\alpha \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The <em>alpha</em> <span class="math notranslate nohighlight">\(\alpha\)</span> parameter (default to 1) for Rényi entropy.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. <code class="docutils literal notranslate"><span class="pre">None</span></code> by
default, which skips the process (and assumes the input is already discrete). See
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the discrete the signal.</p></li>
<li><p><strong>freq</strong> (<em>np.array</em>) – Instead of a signal, a vector of probabilities can be provided.</p></li>
<li><p><strong>**kwargs</strong> – Optional arguments. Not used for now.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ren</strong> (<em>float</em>) – The Tsallis entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_tsallis" title="neurokit2.complexity.entropy_tsallis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_tsallis</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">tsen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_renyi</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">tsen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.5229550675313184)</span>

<span class="go"># Compare to Shannon function</span>
<span class="gp">In [5]: </span><span class="n">shanen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">shanen</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(1.5229550675313184)</span>

<span class="go"># Hartley Entropy</span>
<span class="gp">In [7]: </span><span class="n">nk</span><span class="o">.</span><span class="n">entropy_renyi</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(1.6094379124341003)</span>

<span class="go"># Collision Entropy</span>
<span class="gp">In [8]: </span><span class="n">nk</span><span class="o">.</span><span class="n">entropy_renyi</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[8]: </span><span class="go">np.float64(1.4500101755059984)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rényi, A. (1961, January). On measures of entropy and information. In Proceedings of the
Fourth Berkeley Symposium on Mathematical Statistics and Probability, Volume 1:
Contributions to the Theory of Statistics (Vol. 4, pp. 547-562). University of California
Press.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-approximate">
<h3><em>entropy_approximate()</em><a class="headerlink" href="#entropy-approximate" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_approximate">
<span class="sig-name descname"><span class="pre">entropy_approximate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_approximate.html#entropy_approximate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_approximate" title="Link to this definition">#</a></dt>
<dd><p><strong>Approximate entropy (ApEn) and its corrected version (cApEn)</strong></p>
<p>Approximate entropy is a technique used to quantify the amount of regularity and the
unpredictability of fluctuations over time-series data. The advantages of ApEn include lower
computational demand (ApEn can be designed to work for small data samples (&lt; 50 data points)
and can be applied in real time) and less sensitive to noise. However, ApEn is heavily
dependent on the record length and lacks relative consistency.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_approximate()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_apen()</span></code>, and
the corrected version via <code class="docutils literal notranslate"><span class="pre">complexity_capen()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>corrected</strong> (<em>bool</em>) – If true, will compute corrected ApEn (cApEn), see Porta (2007).</p></li>
<li><p><strong>**kwargs</strong> – Other arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_sample</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_fuzzy" title="neurokit2.complexity.entropy_fuzzy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_fuzzy</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>apen</strong> (<em>float</em>) – The approximate entropy of the single time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute approximate entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">apen</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_approximate</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">apen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.08837414074679684)</span>

<span class="gp">In [5]: </span><span class="n">capen</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_approximate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">capen</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(0.08907775138332998)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Sabeti, M., Katebi, S., &amp; Boostani, R. (2009). Entropy and complexity measures for EEG signal
classification of schizophrenic and control participants. Artificial intelligence in medicine,
47(3), 263-274.</p></li>
<li><p>Shi, B., Zhang, Y., Yuan, C., Wang, S., &amp; Li, P. (2017). Entropy analysis of short-term
heartbeat interval time series during regular walking. Entropy, 19(10), 568.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-sample">
<h3><em>entropy_sample()</em><a class="headerlink" href="#entropy-sample" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_sample">
<span class="sig-name descname"><span class="pre">entropy_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_sample.html#entropy_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_sample" title="Link to this definition">#</a></dt>
<dd><p><strong>Sample Entropy (SampEn)</strong></p>
<p>Compute the sample entropy (SampEn) of a signal. SampEn is a modification
of ApEn used for assessing complexity of physiological time series signals. It corresponds to
the conditional probability that two vectors that are close to each other for <em>m</em> dimensions
will remain close at the next <em>m + 1</em> component.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_sample()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_sampen()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_approximate" title="neurokit2.complexity.entropy_approximate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_approximate</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_fuzzy" title="neurokit2.complexity.entropy_fuzzy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_fuzzy</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_quadratic" title="neurokit2.complexity.entropy_quadratic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_quadratic</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>sampen</strong> (<em>float</em>) – The sample entropy of the single time series.
If undefined conditional probabilities are detected (logarithm
of sum of conditional probabilities is <code class="docutils literal notranslate"><span class="pre">ln(0)</span></code>), <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> will
be returned, meaning it fails to retrieve ‘accurate’ regularity information.
This tends to happen for short data segments, increasing tolerance
levels might help avoid this.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute sample entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">sampen</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_sample</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">sampen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.07380851770121913)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="entropy-quadratic">
<h3><em>entropy_quadratic()</em><a class="headerlink" href="#entropy-quadratic" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_quadratic">
<span class="sig-name descname"><span class="pre">entropy_quadratic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_quadratic.html#entropy_quadratic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_quadratic" title="Link to this definition">#</a></dt>
<dd><p><strong>Quadratic Sample Entropy (QSE)</strong></p>
<p>Compute the quadratic sample entropy (QSE) of a signal. It is essentially a correction of
SampEn introduced by Lake (2005) defined as:</p>
<div class="math notranslate nohighlight">
\[QSE = SampEn + ln(2 * tolerannce)\]</div>
<p>QSE has been described as a more stable measure of entropy than SampEn (Gylling, 2017).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_sample</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>qse</strong> (<em>float</em>) – The  uadratic sample entropy of the single time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute sample entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">qsa</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_quadratic</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">qsa</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(-1.8819529224920126)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Huselius Gylling, K. (2017). Quadratic sample entropy as a measure of burstiness: A study in
how well Rényi entropy rate and quadratic sample entropy can capture the presence of spikes in
time-series data.</p></li>
<li><p>Lake, D. E. (2005). Renyi entropy measures of heart rate Gaussianity. IEEE Transactions on
Biomedical Engineering, 53(1), 21-27.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-cumulativeresidual">
<h3><em>entropy_cumulativeresidual()</em><a class="headerlink" href="#entropy-cumulativeresidual" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_cumulativeresidual">
<span class="sig-name descname"><span class="pre">entropy_cumulativeresidual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_cumulativeresidual.html#entropy_cumulativeresidual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_cumulativeresidual" title="Link to this definition">#</a></dt>
<dd><p><strong>Cumulative residual entropy (CREn)</strong></p>
<p>The cumulative residual entropy is an alternative to the Shannon
differential entropy with several advantageous properties, such as non-negativity. The key idea
is to use the cumulative distribution (CDF) instead of the density function in Shannon’s
entropy.</p>
<div class="math notranslate nohighlight">
\[CREn = -\int_{0}^{\infty} p(|X| &gt; x) \log_{2} p(|X| &gt; x) dx\]</div>
<p>Similarly to <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a> and <a class="reference internal" href="#neurokit2.complexity.fractal_petrosian" title="neurokit2.complexity.fractal_petrosian"><code class="xref py py-func docutils literal notranslate"><span class="pre">Petrosian</span> <span class="pre">fractal</span> <span class="pre">dimension</span></code></a>, different methods to transform continuous signals into discrete ones are
available. See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_cumulativeresidual()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_cren()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. <code class="docutils literal notranslate"><span class="pre">None</span></code> by
default, which skips the process (and assumes the input is already discrete). See
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the discrete the signal.</p></li>
<li><p><strong>freq</strong> (<em>np.array</em>) – Instead of a signal, a vector of probabilities can be provided.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>CREn</strong> (<em>float</em>) – The cumulative residual entropy.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing <code class="docutils literal notranslate"><span class="pre">Values</span></code> for each pair of events.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">cren</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_cumulativeresidual</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_cumulativeresidual1.png"><img alt="../_images/p_entropy_cumulativeresidual1.png" src="../_images/p_entropy_cumulativeresidual1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">cren</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.9798687566511528)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rao, M., Chen, Y., Vemuri, B. C., &amp; Wang, F. (2004). Cumulative residual entropy: a new
measure of information. IEEE transactions on Information Theory, 50(6), 1220-1228.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-rate">
<h3><em>entropy_rate()</em><a class="headerlink" href="#entropy-rate" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_rate">
<span class="sig-name descname"><span class="pre">entropy_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_rate.html#entropy_rate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_rate" title="Link to this definition">#</a></dt>
<dd><p><strong>Entropy Rate (RatEn)</strong></p>
<p>The Entropy Rate (RatEn or ER) quantifies the amount of information needed to describe the
signal given observations of signal(k). In other words, it is the entropy of the time series
conditioned on the <em>k</em>-histories.</p>
<p>It quantifies how much uncertainty or randomness the process produces at each new time step,
given knowledge about the past states of the process. The entropy rate is estimated as the
slope of the linear fit between the history length <em>k</em> and the joint Shannon entropies. The
entropy at k = 1 is called <strong>Excess Entropy</strong> (ExEn).</p>
<p>We adapted the algorithm to include a knee-point detection (beyond which the self-Entropy
reaches a plateau), and if it exists, we additionally re-compute the Entropy Rate up until that
point. This <strong>Maximum Entropy Rate</strong> (MaxRatEn) can be retrieved from the dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – A <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a> sequence in the form of a vector of values.</p></li>
<li><p><strong>kmax</strong> (<em>int</em>) – The max history length to consider. If an integer is passed, will generate a range from 1
to kmax.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. By default,
assigns 0 and 1 to values below and above the mean. Can be <code class="docutils literal notranslate"><span class="pre">None</span></code> to skip the process (in
case the input is already discrete). See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the Entropy Rate line.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Example 1</strong>: A simple discrete signal. We have to specify <code class="docutils literal notranslate"><span class="pre">symbolize=None</span></code> as the signal is
already discrete.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">raten</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_rate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_rate1.png"><img alt="../_images/p_entropy_rate1.png" src="../_images/p_entropy_rate1.png" style="width: 600.0px; height: 600.0px;" />
</a>
<p>Here we can see that <em>kmax</em> is likely to big to provide an accurate estimation of entropy rate.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">raten</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_rate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_rate2.png"><img alt="../_images/p_entropy_rate2.png" src="../_images/p_entropy_rate2.png" style="width: 600.0px; height: 600.0px;" />
</a>
<p><strong>Example 2</strong>: A continuous signal.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">raten</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_rate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_rate3.png"><img alt="../_images/p_entropy_rate3.png" src="../_images/p_entropy_rate3.png" style="width: 600.0px; height: 600.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">raten</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(0.13604346820833424)</span>

<span class="gp">In [8]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Excess_Entropy&quot;</span><span class="p">]</span>
<span class="gh">Out[8]: </span><span class="go">np.float64(0.9999971146079947)</span>

<span class="gp">In [9]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;MaxRatEn&quot;</span><span class="p">]</span>
<span class="gh">Out[9]: </span><span class="go">np.float64(0.3211967949605768)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Mediano, P. A., Rosas, F. E., Timmermann, C., Roseman, L., Nutt, D. J., Feilding, A., … &amp;
Carhart-Harris, R. L. (2020). Effects of external stimulation on psychedelic state
neurodynamics. Biorxiv.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-svd">
<h3><em>entropy_svd()</em><a class="headerlink" href="#entropy-svd" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_svd">
<span class="sig-name descname"><span class="pre">entropy_svd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_svd.html#entropy_svd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_svd" title="Link to this definition">#</a></dt>
<dd><p><strong>Singular Value Decomposition (SVD) Entropy</strong></p>
<p>SVD entropy (SVDEn) can be intuitively seen as an indicator of how many eigenvectors are needed
for an adequate explanation of the dataset. In other words, it measures feature-richness: the
higher the SVD entropy, the more orthogonal vectors are required to adequately explain the
space-state. Similarly to <code class="xref py py-func docutils literal notranslate"><span class="pre">Fisher</span> <span class="pre">Information</span> <span class="pre">(FI)</span></code>, it is based on
the Singular Value Decomposition of the <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">time-delay</span> <span class="pre">embedded</span></code></a> signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">information_fisher</span></code>, <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embedding</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If True, will plot the attractor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>svd</strong> (<em>float</em>) – The singular value decomposition (SVD).</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute SVDEn.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">svden</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_svd</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">svden</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.5091667337544503)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_svd1.png"><img alt="../_images/p_entropy_svd1.png" src="../_images/p_entropy_svd1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Roberts, S. J., Penny, W., &amp; Rezek, I. (1999). Temporal and spatial complexity measures for
electroencephalogram based brain-computer interfacing. Medical &amp; biological engineering &amp;
computing, 37(1), 93-98.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-kl">
<h3><em>entropy_kl()</em><a class="headerlink" href="#entropy-kl" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_kl">
<span class="sig-name descname"><span class="pre">entropy_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_kl.html#entropy_kl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_kl" title="Link to this definition">#</a></dt>
<dd><p><strong>Kozachenko-Leonenko (K-L) Differential entropy (KLEn)</strong></p>
<p>The Kozachenko-Leonenko (K-L) estimate of the differential entropy is also referred to as the
<em>nearest neighbor estimate</em> of entropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>norm</strong> (<em>str</em>) – The probability norm used when computing k-nearest neighbour distances. Can be
<code class="docutils literal notranslate"><span class="pre">&quot;euclidean&quot;</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">&quot;max&quot;</span></code>.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments (not used for now).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>klen</strong> (<em>float</em>) – The KL-entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute Differential entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_differential" title="neurokit2.complexity.entropy_differential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_differential</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal with Laplace Noise</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Compute Kozachenko-Leonenko (K-L) Entropy</span>
<span class="gp">In [3]: </span><span class="n">klen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_kl</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">klen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.6751429743416755)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Gautama, T., Mandic, D. P., &amp; Van Hulle, M. M. (2003, April). A differential entropy based
method for determining the optimal embedding parameters of a signal. In 2003 IEEE
International Conference on Acoustics, Speech, and Signal Processing, 2003. Proceedings.
(ICASSP’03). (Vol. 6, pp. VI-29). IEEE.</p></li>
<li><p>Beirlant, J., Dudewicz, E. J., Györfi, L., &amp; Van der Meulen, E. C. (1997). Nonparametric
entropy estimation: An overview. International Journal of Mathematical and Statistical
Sciences, 6(1), 17-39.</p></li>
<li><p>Kozachenko, L., &amp; Leonenko, N. (1987). Sample estimate of the entropy of a random vector.
Problemy Peredachi Informatsii, 23(2), 9-16.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-spectral">
<h3><em>entropy_spectral()</em><a class="headerlink" href="#entropy-spectral" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_spectral">
<span class="sig-name descname"><span class="pre">entropy_spectral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_spectral.html#entropy_spectral"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_spectral" title="Link to this definition">#</a></dt>
<dd><p><strong>Spectral Entropy (SpEn)</strong></p>
<p>Spectral entropy (SE or SpEn) treats the signal’s normalized power spectrum density (PSD) in the
frequency domain as a probability distribution, and calculates the Shannon entropy of it.</p>
<div class="math notranslate nohighlight">
\[H(x, sf) =  -\sum P(f) \log_2[P(f)]\]</div>
<p>A signal with a single frequency component (i.e., pure sinusoid) produces the smallest entropy.
On the other hand, a signal with all frequency components of equal power value (white
noise) produces the greatest entropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>bins</strong> (<em>int</em>) – If an integer is passed, will cut the PSD into a number of bins of frequency.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Display the power spectrum.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Keyword arguments to be passed to <code class="docutils literal notranslate"><span class="pre">signal_psd()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>SpEn</strong> (<em>float</em>) – Spectral Entropy</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_wiener</span></code>, <a class="reference internal" href="signal.html#neurokit2.signal_psd" title="neurokit2.signal_psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal_psd</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal with Laplace Noise</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Compute Spectral Entropy</span>
<span class="gp">In [3]: </span><span class="n">SpEn</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_spectral</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_spectral1.png"><img alt="../_images/p_entropy_spectral1.png" src="../_images/p_entropy_spectral1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">SpEn</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.6101824039265449)</span>
</pre></div>
</div>
<p>Bin the frequency spectrum.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">SpEn</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_spectral</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_spectral2.png"><img alt="../_images/p_entropy_spectral2.png" src="../_images/p_entropy_spectral2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Crepeau, J. C., &amp; Isaacson, L. K. (1991). Spectral Entropy Measurements of Coherent
Structures in an Evolving Shear Layer. Journal of Non-Equilibrium Thermodynamics, 16(2).
doi:10.1515/jnet.1991.16.2.137</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-phase">
<h3><em>entropy_phase()</em><a class="headerlink" href="#entropy-phase" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_phase">
<span class="sig-name descname"><span class="pre">entropy_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_phase.html#entropy_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_phase" title="Link to this definition">#</a></dt>
<dd><p><strong>Phase Entropy (PhasEn)</strong></p>
<p>Phase entropy (PhasEn or PhEn) has been developed by quantifying the distribution of the signal
in accross <em>k</em> parts (of a two-dimensional phase space referred to as a second order difference
plot (SODP). It build on the concept of <a class="reference internal" href="#neurokit2.complexity.entropy_grid" title="neurokit2.complexity.entropy_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">Grid</span> <span class="pre">Entropy</span></code></a>, that uses
<a class="reference internal" href="hrv.html#neurokit2.hrv.hrv_nonlinear" title="neurokit2.hrv.hrv_nonlinear"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poincaré</span> <span class="pre">plot</span></code></a> as its basis.</p>
<figure class="align-default">
<a class="reference external image-reference" href="https://doi.org/10.1088/1361-6579/ab499e"><img alt="Figure from Rohila et al. (2019)." src="../_images/rohila2019.png" />
</a>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of sections that the SODP is divided into. It is a coarse graining parameter
that defines how fine the grid is. It is recommended to use even-numbered (preferably
multiples of 4) partitions for sake of symmetry.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the Second Order Difference Plot (SODP).</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments, such as the logarithmic <code class="docutils literal notranslate"><span class="pre">base</span></code> to use for
<a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>phasen</strong> (<em>float</em>) – Phase Entropy</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute Phase Entropy</span>
<span class="gp">In [3]: </span><span class="n">phasen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_phase</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_phase1.png"><img alt="../_images/p_entropy_phase1.png" src="../_images/p_entropy_phase1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">phasen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.1529401042734624)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">phasen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_phase</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_phase2.png"><img alt="../_images/p_entropy_phase2.png" src="../_images/p_entropy_phase2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rohila, A., &amp; Sharma, A. (2019). Phase entropy: A new complexity measure for heart rate
variability. Physiological Measurement, 40(10), 105006.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-grid">
<h3><em>entropy_grid()</em><a class="headerlink" href="#entropy-grid" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_grid">
<span class="sig-name descname"><span class="pre">entropy_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_grid.html#entropy_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_grid" title="Link to this definition">#</a></dt>
<dd><p><strong>Grid Entropy (GridEn)</strong></p>
<p>Grid Entropy (GridEn or GDEn) is defined as a gridded descriptor of a <a class="reference internal" href="hrv.html#neurokit2.hrv.hrv_nonlinear" title="neurokit2.hrv.hrv_nonlinear"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poincaré</span> <span class="pre">plot</span></code></a>,
which is a two-dimensional phase space diagram of a time series that plots the present sample
of a time series with respect to their delayed values. The plot is divided into <span class="math notranslate nohighlight">\(n*n\)</span>
grids, and the <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a> is computed from the probability
distribution of the number of points in each grid.</p>
<p>Yan et al. (2019) define two novel measures, namely <strong>GridEn</strong> and <strong>Gridded Distribution Rate
(GDR)</strong>, the latter being the percentage of grids containing points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of sections that the Poincaré plot is divided into. It is a coarse
graining parameter that defines how fine the grid is.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the Poincaré plot.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments, such as the logarithmic <code class="docutils literal notranslate"><span class="pre">base</span></code> to use for
<a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>griden</strong> (<em>float</em>) – Grid Entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="hrv.html#neurokit2.hrv.hrv_nonlinear" title="neurokit2.hrv.hrv_nonlinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hrv_nonlinear</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_phase" title="neurokit2.complexity.entropy_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_phase</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute Grid Entropy</span>
<span class="gp">In [3]: </span><span class="n">phasen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_grid</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_grid1.png"><img alt="../_images/p_entropy_grid1.png" src="../_images/p_entropy_grid1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">phasen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(2.3669357220845013)</span>

<span class="gp">In [5]: </span><span class="n">phasen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_grid</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_grid2.png"><img alt="../_images/p_entropy_grid2.png" src="../_images/p_entropy_grid2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;GDR&quot;</span><span class="p">]</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(0.67)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Yan, C., Li, P., Liu, C., Wang, X., Yin, C., &amp; Yao, L. (2019). Novel gridded descriptors of
poincaré plot for analyzing heartbeat interval time-series. Computers in biology and
medicine, 109, 280-289.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-attention">
<h3><em>entropy_attention()</em><a class="headerlink" href="#entropy-attention" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_attention">
<span class="sig-name descname"><span class="pre">entropy_attention</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">silent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_attention.html#entropy_attention"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_attention" title="Link to this definition">#</a></dt>
<dd><p><strong>Attention Entropy (AttEn)</strong></p>
<p>Yang et al. (2020) propose a conceptually new approach called <strong>Attention Entropy (AttEn)</strong>,
which pays attention only to the key observations (local maxima and minima; i.e., peaks).
Instead of counting the frequency of all observations, it analyzes the frequency distribution
of the intervals between the key observations in a time-series. The advantages of the attention
entropy are that it does not need any parameter to tune, is robust to the time-series length,
and requires only linear time to compute.</p>
<p>Because this index relies on peak-detection, it is not suited for noisy signals. Signal
cleaning (in particular filtering), and eventually more tuning for the peak detection
algorithm, can help.</p>
<p><strong>AttEn</strong> is computed as the average of various subindices, such as:</p>
<ul class="simple">
<li><p><strong>MaxMax</strong>: The entropy of local-maxima intervals.</p></li>
<li><p><strong>MinMin</strong>: The entropy of local-minima intervals.</p></li>
<li><p><strong>MaxMin</strong>: The entropy of intervals between local maxima and subsequent minima.</p></li>
<li><p><strong>MinMax</strong>: The entropy of intervals between local minima and subsequent maxima.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If True, the local maxima and minima will be displayed.</p></li>
<li><p><strong>silent</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, silence possible warnings.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <code class="docutils literal notranslate"><span class="pre">scipy.signal.find_peaks()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>atten</strong> (<em>float</em>) – The attention entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing values of sub-entropies, such as <code class="docutils literal notranslate"><span class="pre">MaxMax</span></code>, <code class="docutils literal notranslate"><span class="pre">MinMin</span></code>,
<code class="docutils literal notranslate"><span class="pre">MaxMin</span></code>, and <code class="docutils literal notranslate"><span class="pre">MinMax</span></code>.</p></li>
<li><p><em>**kwargs</em> – Other arguments to be passed to <code class="docutils literal notranslate"><span class="pre">scipy.signal.find_peaks()</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_cumulative_residual</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Compute Attention Entropy</span>
<span class="gp">In [3]: </span><span class="n">atten</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_attention</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_attention1.png"><img alt="../_images/p_entropy_attention1.png" src="../_images/p_entropy_attention1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">atten</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.0954757952145573)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Yang, J., Choudhary, G. I., Rahardja, S., &amp; Franti, P. (2020). Classification of interbeat
interval time-series using attention entropy. IEEE Transactions on Affective Computing.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-increment">
<h3><em>entropy_increment()</em><a class="headerlink" href="#entropy-increment" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_increment">
<span class="sig-name descname"><span class="pre">entropy_increment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_increment.html#entropy_increment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_increment" title="Link to this definition">#</a></dt>
<dd><p><strong>Increment Entropy (IncrEn) and its Multiscale variant (MSIncrEn)</strong></p>
<p>Increment Entropy (IncrEn) quantifies the magnitudes of the variations between adjacent
elements into ranks based on a precision factor <em>q</em> and the standard deviation of the time
series. IncrEn is conceptually similar to <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">permutation</span> <span class="pre">entropy</span></code></a> in
that it also uses the concepts of symbolic dynamics.</p>
<p>In the IncrEn calculation, two letters are used to describe the relationship between adjacent
elements in a time series. One letter represents the volatility direction, and the other
represents the magnitude of the variation between the adjacent elements.</p>
<p>The time series is reconstructed into vectors of <em>m</em> elements. Each element of each vector
represents the increment between two neighbouring elements in the original time series.
Each increment element is mapped to a word consisting of two letters (one letter represents
the volatility direction, and the other represents the magnitude of the variation between
the adjacent elements), and then, each vector is described as a symbolic (discrete) pattern.
The <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a> of the probabilities of independent patterns is
then computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>q</strong> (<em>float</em>) – The quantifying resolution <em>q</em> represents the precision of <em>IncrEn</em>, with larger values
indicating a higher precision, causing IncrEn to be more sensitive to subtle fluctuations.
The IncrEn value increases with increasing <em>q</em>, until reaching a plateau. This property can
be useful to selecting an optimal <em>q</em> value.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments, such as the logarithmic <code class="docutils literal notranslate"><span class="pre">base</span></code> to use for
<a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>incren</strong> (<em>float</em>) – The Increment Entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used, such as the
average entropy <code class="docutils literal notranslate"><span class="pre">AvEn</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># IncrEn</span>
<span class="gp">In [3]: </span><span class="n">incren</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_increment</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">incren</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(2.7737346401936214)</span>

<span class="go"># Multiscale IncrEn (MSIncrEn)</span>
<span class="gp">In [5]: </span><span class="n">msincren</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSIncrEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_increment1.png"><img alt="../_images/p_entropy_increment1.png" src="../_images/p_entropy_increment1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Liu, X., Jiang, A., Xu, N., &amp; Xue, J. (2016). Increment entropy as a measure of complexity
for time series. Entropy, 18(1), 22.</p></li>
<li><p>Liu, X., Jiang, A., Xu, N., &amp; Xue, J. (2016). Correction on Liu, X.; Jiang, A.; Xu, N.; Xue,
J. Increment Entropy as a Measure of Complexity for Time Series. Entropy 2016, 18, 22.
Entropy, 18(4), 133.</p></li>
<li><p>Liu, X., Wang, X., Zhou, X., &amp; Jiang, A. (2018). Appropriate use of the increment entropy for
electrophysiological time series. Computers in Biology and Medicine, 95, 13-23.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-slope">
<h3><em>entropy_slope()</em><a class="headerlink" href="#entropy-slope" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_slope">
<span class="sig-name descname"><span class="pre">entropy_slope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.1,</span> <span class="pre">45]</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_slope.html#entropy_slope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_slope" title="Link to this definition">#</a></dt>
<dd><p><strong>Slope Entropy (SlopEn)</strong></p>
<p>Slope Entropy (SlopEn) uses an alphabet of three symbols, 0, 1, and 2, with positive (+) and
negative versions (-) of the last two. Each symbol covers a range of slopes for the segment
joining two consecutive samples of the input data, and the <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a>
of the relative frequency of each pattern is computed.</p>
<figure class="align-default">
<a class="reference external image-reference" href="https://doi.org/10.3390/e21121167"><img alt="Figure from Cuesta-Frau, D. (2019)." src="../_images/cuestafrau2019.png" />
</a>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>thresholds</strong> (<em>list</em>) – Angular thresholds (called <em>levels</em>). A list of monotonically increasing  values in the
range [0, 90] degrees.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments, such as the logarithmic <code class="docutils literal notranslate"><span class="pre">base</span></code> to use for
<a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>slopen</strong> (<em>float</em>) – Slope Entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute Slope Entropy</span>
<span class="gp">In [3]: </span><span class="n">slopen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_slope</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">45</span><span class="p">])</span>

<span class="gp">In [4]: </span><span class="n">slopen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(3.804580134487825)</span>

<span class="gp">In [5]: </span><span class="n">slopen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_slope</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>

<span class="gp">In [6]: </span><span class="n">slopen</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(5.02984332497549)</span>

<span class="go"># Compute Multiscale Slope Entropy (MSSlopEn)</span>
<span class="gp">In [7]: </span><span class="n">msslopen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSSlopEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_slope1.png"><img alt="../_images/p_entropy_slope1.png" src="../_images/p_entropy_slope1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Cuesta-Frau, D. (2019). Slope entropy: A new time series complexity estimator based on both
symbolic patterns and amplitude information. Entropy, 21(12), 1167.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-symbolicdynamic">
<h3><em>entropy_symbolicdynamic()</em><a class="headerlink" href="#entropy-symbolicdynamic" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_symbolicdynamic">
<span class="sig-name descname"><span class="pre">entropy_symbolicdynamic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MEP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_symbolicdynamic.html#entropy_symbolicdynamic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_symbolicdynamic" title="Link to this definition">#</a></dt>
<dd><p><strong>Symbolic Dynamic Entropy (SyDyEn) and its Multiscale variants (MSSyDyEn)</strong></p>
<p>Symbolic Dynamic Entropy (SyDyEn) combines the merits of symbolic dynamic and information
theory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. Can be one
of <code class="docutils literal notranslate"><span class="pre">&quot;MEP&quot;</span></code> (default), <code class="docutils literal notranslate"><span class="pre">&quot;NCDF&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;linear&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;kmeans&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;equal&quot;</span></code>,
or others. See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>c</strong> (<em>int</em>) – Number of symbols <em>c</em>.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments (currently not used).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>SyDyEn</strong> (<em>float</em>) – Symbolic Dynamic Entropy (SyDyEn) of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_dispersion" title="neurokit2.complexity.entropy_dispersion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_dispersion</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [3]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute Symbolic Dynamic Entropy</span>
<span class="gp">In [4]: </span><span class="n">sydyen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_symbolicdynamic</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="s2">&quot;MEP&quot;</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">sydyen</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(3.672946845575994)</span>

<span class="gp">In [6]: </span><span class="n">sydyen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_symbolicdynamic</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="s2">&quot;kmeans&quot;</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">sydyen</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(3.322090707943956)</span>

<span class="go"># Compute Multiscale Symbolic Dynamic Entropy (MSSyDyEn)</span>
<span class="gp">In [8]: </span><span class="n">mssydyen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSSyDyEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="go"># Compute Modified Multiscale Symbolic Dynamic Entropy (MMSyDyEn)</span>
<span class="gp">In [9]: </span><span class="n">mmsydyen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MMSyDyEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_symbolicdynamic1.png"><img alt="../_images/p_entropy_symbolicdynamic1.png" src="../_images/p_entropy_symbolicdynamic1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<a class="reference internal image-reference" href="../_images/p_entropy_symbolicdynamic2.png"><img alt="../_images/p_entropy_symbolicdynamic2.png" src="../_images/p_entropy_symbolicdynamic2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Matilla-García, M., Morales, I., Rodríguez, J. M., &amp; Marín, M. R. (2021). Selection of
embedding dimension and delay time in phase space reconstruction via symbolic dynamics.
Entropy, 23(2), 221.</p></li>
<li><p>Li, Y., Yang, Y., Li, G., Xu, M., &amp; Huang, W. (2017). A fault diagnosis scheme for planetary
gearboxes using modified multi-scale symbolic dynamic entropy and mRMR feature selection.
Mechanical Systems and Signal Processing, 91, 295-312.</p></li>
<li><p>Rajagopalan, V., &amp; Ray, A. (2006). Symbolic time series analysis via wavelet-based
partitioning. Signal processing, 86(11), 3309-3320.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-dispersion">
<h3><em>entropy_dispersion()</em><a class="headerlink" href="#entropy-dispersion" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_dispersion">
<span class="sig-name descname"><span class="pre">entropy_dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NCDF'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fluctuation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_dispersion.html#entropy_dispersion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_dispersion" title="Link to this definition">#</a></dt>
<dd><p><strong>Dispersion Entropy (DispEn)</strong></p>
<p>The Dispersion Entropy (DispEn). Also returns the Reverse Dispersion Entropy (RDEn).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>c</strong> (<em>int</em>) – Number of symbols <em>c</em>. Rostaghi (2016) recommend in practice a <em>c</em> between 4 and 8.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Method to convert a continuous signal input into a symbolic (discrete) signal. Can be one
of <code class="docutils literal notranslate"><span class="pre">&quot;NCDF&quot;</span></code> (default), <code class="docutils literal notranslate"><span class="pre">&quot;finesort&quot;</span></code>, or others. See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for
details.</p></li>
<li><p><strong>fluctuation</strong> (<em>bool</em>) – Fluctuation-based Dispersion entropy.</p></li>
<li><p><strong>rho</strong> (<em>float</em>) – Tuning parameter of “finesort”. Only when <code class="docutils literal notranslate"><span class="pre">method=&quot;finesort&quot;</span></code>.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments (currently not used).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>DispEn</strong> (<em>float</em>) – Dispersion Entropy (DispEn) of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_symbolicdynamic" title="neurokit2.complexity.entropy_symbolicdynamic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_symbolicdynamic</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute Dispersion Entropy (DispEn)</span>
<span class="gp">In [3]: </span><span class="n">dispen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_dispersion</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">dispen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.4080466280484532)</span>

<span class="go"># Get Reverse Dispersion Entropy (RDEn)</span>
<span class="gp">In [5]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;RDEn&quot;</span><span class="p">]</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.006170201607185522)</span>

<span class="go"># Fluctuation-based DispEn with &quot;finesort&quot;</span>
<span class="gp">In [6]: </span><span class="n">dispen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_dispersion</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">symbolize</span><span class="o">=</span><span class="s2">&quot;finesort&quot;</span><span class="p">,</span> <span class="n">fluctuation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">dispen</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(1.4080466280484532)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rostaghi, M., &amp; Azami, H. (2016). Dispersion entropy: A measure for time-series analysis.
IEEE Signal Processing Letters, 23(5), 610-614.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-ofentropy">
<h3><em>entropy_ofentropy()</em><a class="headerlink" href="#entropy-ofentropy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_ofentropy">
<span class="sig-name descname"><span class="pre">entropy_ofentropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_ofentropy.html#entropy_ofentropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_ofentropy" title="Link to this definition">#</a></dt>
<dd><p><strong>Entropy of entropy (EnofEn)</strong></p>
<p>Entropy of entropy (EnofEn or EoE) combines the features of <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-func docutils literal notranslate"><span class="pre">MSE</span></code></a>
with an alternate measure of information, called <em>superinformation</em>, used in DNA sequencing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>scale</strong> (<em>int</em>) – The size of the windows that the signal is divided into. Also referred to as Tau
<span class="math notranslate nohighlight">\(\tau\)</span>, it represents the scale factor and corresponds to
the amount of coarsegraining.</p></li>
<li><p><strong>bins</strong> (<em>int</em>) – The number of equal-size bins to divide the signal’s range in.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments, such as the logarithmic <code class="docutils literal notranslate"><span class="pre">base</span></code> to use for
<a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>enofen</strong> (<em>float</em>) – The Entropy of entropy of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used, such as the
average entropy <code class="docutils literal notranslate"><span class="pre">AvEn</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># EnofEn</span>
<span class="gp">In [3]: </span><span class="n">enofen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_ofentropy</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">enofen</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(3.934829508503262)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Hsu, C. F., Wei, S. Y., Huang, H. P., Hsu, L., Chi, S., &amp; Peng, C. K. (2017). Entropy of
entropy: Measurement of dynamical complexity for biological systems. Entropy, 19(10), 550.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-permutation">
<h3><em>entropy_permutation()</em><a class="headerlink" href="#entropy-permutation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_permutation">
<span class="sig-name descname"><span class="pre">entropy_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corrected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conditional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_permutation.html#entropy_permutation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_permutation" title="Link to this definition">#</a></dt>
<dd><p><strong>Permutation Entropy (PEn), its Weighted (WPEn) and Conditional (CPEn) forms</strong></p>
<p>Permutation Entropy (PEn) is a robust measure of the complexity of a dynamic system by
capturing the order relations between values of a time series and extracting a probability
distribution of the ordinal patterns (see Henry and Judge, 2019). Using ordinal descriptors
increases robustness to large artifacts occurring with low frequencies. PEn is applicable
for regular, chaotic, noisy, or real-world time series and has been employed in the context of
EEG, ECG, and stock market time series.</p>
<p>Mathematically, it corresponds to the <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">entropy</span></code></a> after the
signal has been made <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">discrete</span></code></a> by analyzing the permutations in
the time-embedded space.</p>
<p>However, the main shortcoming of traditional PEn is that no information besides the order
structure is retained when extracting the ordinal patterns, which leads to several possible
issues (Fadlallah et al., 2013). The <strong>Weighted PEn</strong> was developed to address these
limitations by incorporating significant information (regarding the amplitude) from the
original time series into the ordinal patterns.</p>
<p>The <strong>Conditional Permutation Entropy (CPEn)</strong> was originally defined by Bandt &amp; Pompe as
<em>Sorting Entropy</em>, but recently gained in popularity as conditional through the work of
Unakafov et al. (2014). It describes the average diversity of the ordinal patterns succeeding a
given ordinal pattern (dimension+1 vs. dimension).</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_permutation()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_pe()</span></code>.
Moreover, variants can be directly accessed via <code class="docutils literal notranslate"><span class="pre">complexity_wpe()</span></code> and <code class="docutils literal notranslate"><span class="pre">complexity_mspe()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>corrected</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, divide by log2(factorial(m)) to normalize the entropy between 0 and 1. Otherwise,
return the permutation entropy in bit.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – If True, compute the weighted permutation entropy (WPE).</p></li>
<li><p><strong>**kwargs</strong> – Optional arguments, such as a function to compute Entropy (<code class="xref py py-func docutils literal notranslate"><span class="pre">nk.entropy_shannon()</span></code>
(default), <code class="xref py py-func docutils literal notranslate"><span class="pre">nk.entropy_tsallis()</span></code> or <code class="xref py py-func docutils literal notranslate"><span class="pre">nk.entropy_reyni()</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>PEn</strong> (<em>float</em>) – Permutation Entropy</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_ordinalpatterns" title="neurokit2.complexity.complexity_ordinalpatterns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_ordinalpatterns</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Permutation Entropy (uncorrected)</span>
<span class="gp">In [2]: </span><span class="n">pen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_permutation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">pen</span>
<span class="gh">Out[3]: </span><span class="go">np.float64(2.572852420383253)</span>

<span class="go"># Weighted Permutation Entropy (WPEn)</span>
<span class="gp">In [4]: </span><span class="n">wpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_permutation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">wpen</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.9947175987737426)</span>

<span class="go"># Conditional Permutation Entropy (CPEn)</span>
<span class="gp">In [6]: </span><span class="n">cpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_permutation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">cpen</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(0.42162709025144085)</span>

<span class="go"># Conditional Weighted Permutation Entropy (CWPEn)</span>
<span class="gp">In [8]: </span><span class="n">cwpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_permutation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">cwpen</span>
<span class="gh">Out[9]: </span><span class="go">np.float64(0.4061278543278739)</span>

<span class="go"># Conditional Renyi Permutation Entropy (CRPEn)</span>
<span class="gp">In [10]: </span><span class="n">crpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_permutation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="n">nk</span><span class="o">.</span><span class="n">entropy_renyi</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">crpen</span>
<span class="gh">Out[11]: </span><span class="go">np.float64(0.28585042772830704)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Henry, M., &amp; Judge, G. (2019). Permutation entropy and information recovery in nonlinear
dynamic economic time series. Econometrics, 7(1), 10.</p></li>
<li><p>Fadlallah, B., Chen, B., Keil, A., &amp; Principe, J. (2013). Weighted-permutation entropy: A
complexity measure for time series incorporating amplitude information. Physical Review E, 87
(2), 022911.</p></li>
<li><p>Zanin, M., Zunino, L., Rosso, O. A., &amp; Papo, D. (2012). Permutation entropy and its main
biomedical and econophysics applications: a review. Entropy, 14(8), 1553-1577.</p></li>
<li><p>Bandt, C., &amp; Pompe, B. (2002). Permutation entropy: a natural complexity measure for time
series. Physical review letters, 88(17), 174102.</p></li>
<li><p>Unakafov, A. M., &amp; Keller, K. (2014). Conditional entropy of ordinal patterns. Physica D:
Nonlinear Phenomena, 269, 94-102.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-bubble">
<h3><em>entropy_bubble()</em><a class="headerlink" href="#entropy-bubble" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_bubble">
<span class="sig-name descname"><span class="pre">entropy_bubble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_bubble.html#entropy_bubble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_bubble" title="Link to this definition">#</a></dt>
<dd><p><strong>Bubble Entropy (BubblEn)</strong></p>
<p>Introduced by Manis et al. (2017) with the goal of being independent of parameters such as
<em>Tolerance</em> and <em>Dimension</em>. Bubble Entropy is based on <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">permutation</span> <span class="pre">entropy</span></code></a>,
but uses the bubble sort algorithm for the ordering procedure instead of the number of swaps
performed for each vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The <em>alpha</em> <span class="math notranslate nohighlight">\(\alpha\)</span> parameter (default to 1) for <a class="reference internal" href="#neurokit2.complexity.entropy_renyi" title="neurokit2.complexity.entropy_renyi"><code class="xref py py-func docutils literal notranslate"><span class="pre">Rényi</span> <span class="pre">entropy</span></code></a>).</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_ordinalpatterns" title="neurokit2.complexity.complexity_ordinalpatterns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_ordinalpatterns</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_permutation</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_renyi" title="neurokit2.complexity.entropy_renyi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_renyi</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>BubbEn</strong> (<em>float</em>) – The Bubble Entropy.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute sample entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">BubbEn</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_bubble</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">BubbEn</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.07799253889312076)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Manis, G., Aktaruzzaman, M. D., &amp; Sassi, R. (2017). Bubble entropy: An entropy almost free of
parameters. IEEE Transactions on Biomedical Engineering, 64(11), 2711-2718.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-range">
<h3><em>entropy_range()</em><a class="headerlink" href="#entropy-range" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_range">
<span class="sig-name descname"><span class="pre">entropy_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_range.html#entropy_range"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_range" title="Link to this definition">#</a></dt>
<dd><p><strong>Range Entropy (RangEn)</strong></p>
<p>Introduced by Omidvarnia et al. (2018), Range Entropy (RangEn or RangeEn) refers to a modified
form of SampEn (or ApEn).</p>
<p>Both ApEn and SampEn compute the logarithmic likelihood that runs of patterns that are close
remain close on the next incremental comparisons, of which this closeness is estimated by the
Chebyshev distance. Range Entropy uses instead a normalized “range distance”, resulting in
modified forms of ApEn and SampEn, <strong>RangEn (A)</strong> (<em>mApEn</em>) and <strong>RangEn (B)</strong> (<em>mSampEn</em>).</p>
<p>However, the RangEn (A), based on ApEn, often yields undefined entropies (i.e., <em>NaN</em> or
<em>Inf</em>). As such, using RangEn (B) is recommended instead.</p>
<p>RangEn is described as more robust to nonstationary signal changes, and has a more linear
relationship with the Hurst exponent (compared to ApEn and SampEn), and has no need for signal
amplitude correction.</p>
<p>Note that the <a class="reference internal" href="#neurokit2.complexity.entropy_approximate" title="neurokit2.complexity.entropy_approximate"><code class="xref py py-func docutils literal notranslate"><span class="pre">corrected</span></code></a> version of ApEn (cApEn) can be computed
by setting <code class="docutils literal notranslate"><span class="pre">corrected=True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>approximate</strong> (<em>bool</em>) – The entropy algorithm to use. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), will use sample entropy and return
<em>mSampEn</em> (<strong>RangEn B</strong>). If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will use approximate entropy and return <em>mApEn</em>
(<strong>RangEn A</strong>).</p></li>
<li><p><strong>**kwargs</strong> – Other arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_approximate" title="neurokit2.complexity.entropy_approximate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_approximate</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_sample</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>RangEn</strong> (<em>float</em>) – Range Entropy. If undefined conditional probabilities are detected (logarithm
of sum of conditional probabilities is <code class="docutils literal notranslate"><span class="pre">ln(0)</span></code>), <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> will
be returned, meaning it fails to retrieve ‘accurate’ regularity information.
This tends to happen for short data segments, increasing tolerance
levels might help avoid this.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>

<span class="go"># Range Entropy B (mSampEn)</span>
<span class="gp">In [3]: </span><span class="n">RangEnB</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_range</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">RangEnB</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.0882982278736182)</span>

<span class="go"># Range Entropy A (mApEn)</span>
<span class="gp">In [5]: </span><span class="n">RangEnA</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_range</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">RangEnA</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(1.0749312293123292)</span>

<span class="go"># Range Entropy A (corrected)</span>
<span class="gp">In [7]: </span><span class="n">RangEnAc</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_range</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">approximate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">RangEnAc</span>
<span class="gh">Out[8]: </span><span class="go">np.float64(1.1153142451616476)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Omidvarnia, A., Mesbah, M., Pedersen, M., &amp; Jackson, G. (2018). Range entropy: A bridge
between signal complexity and self-similarity. Entropy, 20(12), 962.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-fuzzy">
<h3><em>entropy_fuzzy()</em><a class="headerlink" href="#entropy-fuzzy" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_fuzzy">
<span class="sig-name descname"><span class="pre">entropy_fuzzy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_fuzzy.html#entropy_fuzzy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_fuzzy" title="Link to this definition">#</a></dt>
<dd><p><strong>Fuzzy Entropy (FuzzyEn)</strong></p>
<p>Fuzzy entropy (FuzzyEn) of a signal stems from the combination between information theory and
fuzzy set theory (Zadeh, 1965). A fuzzy set is a set containing elements with varying degrees of
membership.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_fuzzy()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_fuzzyen()</span></code>, or
<code class="docutils literal notranslate"><span class="pre">complexity_fuzzyapen()</span></code> for its approximate version. Note that the fuzzy corrected
approximate entropy (cApEn) can also be computed via setting <code class="docutils literal notranslate"><span class="pre">corrected=True</span></code> (see examples).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>approximate</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will compute the fuzzy approximate entropy (FuzzyApEn).</p></li>
<li><p><strong>**kwargs</strong> – Other arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fuzzyen</strong> (<em>float</em>) – The fuzzy entropy of the single time series.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute fuzzy entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_sample</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>..ipython:: python</p>
<blockquote>
<div><p>import neurokit2 as nk</p>
<p>signal = nk.signal_simulate(duration=2, frequency=5)</p>
<p>fuzzyen, parameters = nk.entropy_fuzzy(signal)
fuzzyen</p>
<p>fuzzyapen, parameters = nk.entropy_fuzzy(signal, approximate=True)
fuzzyapen</p>
<p>fuzzycapen, parameters = nk.entropy_fuzzy(signal, approximate=True, corrected=True)
fuzzycapen</p>
</div></blockquote>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Ishikawa, A., &amp; Mieno, H. (1979). The fuzzy entropy concept and its application. Fuzzy Sets
and systems, 2(2), 113-123.</p></li>
<li><p>Zadeh, L. A. (1996). Fuzzy sets. In Fuzzy sets, fuzzy logic, and fuzzy systems: selected
papers by Lotfi A Zadeh (pp. 394-432).</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-multiscale">
<h3><em>entropy_multiscale()</em><a class="headerlink" href="#entropy-multiscale" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_multiscale">
<span class="sig-name descname"><span class="pre">entropy_multiscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'MSEn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_multiscale.html#entropy_multiscale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_multiscale" title="Link to this definition">#</a></dt>
<dd><p><strong>Multiscale entropy (MSEn) and its Composite (CMSEn), Refined (RCMSEn) or fuzzy versions</strong></p>
<p>One of the limitation of <a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">SampEn</span></code></a> is that it characterizes
complexity strictly on the time scale defined by the sampling procedure (via the <code class="docutils literal notranslate"><span class="pre">delay</span></code>
argument). To address this, Costa et al. (2002) proposed the multiscale entropy (MSEn),
which computes sample entropies at multiple scales.</p>
<p>The conventional MSEn algorithm consists of two steps:</p>
<ol class="arabic simple">
<li><p>A <a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-func docutils literal notranslate"><span class="pre">coarse-graining</span></code></a> procedure is used to represent the
signal at different time scales.</p></li>
<li><p><a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sample</span> <span class="pre">entropy</span></code></a> (or other function) is used to quantify the
regularity of a coarse-grained time series at each time scale factor.</p></li>
</ol>
<p>However, in the traditional coarse-graining procedure, the larger the scale factor is, the
shorter the coarse-grained time series is. As such, the variance of the entropy of the
coarse-grained series estimated by SampEn increases as the time scale factor increases, making
it problematic for shorter signals.</p>
<ul class="simple">
<li><p><strong>CMSEn</strong>: In order to reduce the variance of estimated entropy values at large scales, Wu et
al. (2013) introduced the <strong>Composite Multiscale Entropy</strong> algorithm, which computes
multiple coarse-grained series for each scale factor (via the <strong>time-shift</strong> method for
<a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-func docutils literal notranslate"><span class="pre">coarse-graining</span></code></a>).</p></li>
<li><p><strong>RCMSEn</strong>: Wu et al. (2014) further <strong>Refined</strong> their CMSEn by averaging not the entropy
values of each subcoarsed vector, but its components at a lower level.</p></li>
<li><p><strong>MMSEn</strong>: Wu et al. (2013) also introduced the <strong>Modified Multiscale Entropy</strong>
algorithm, which is based on rolling-average <a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-func docutils literal notranslate"><span class="pre">coarse-graining</span></code></a>.</p></li>
<li><p><strong>IMSEn</strong>: Liu et al. (2012) introduced an adaptive-resampling procedure to resample the
coarse-grained series. We implement a generalization of this via interpolation that can be
referred to as <strong>Interpolated Multiscale Entropy</strong>.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Interpolated Multiscale variants don’t work as expected. Help is needed to fix this
procedure.</p>
</div>
<p>Their <a class="reference internal" href="#neurokit2.complexity.entropy_fuzzy" title="neurokit2.complexity.entropy_fuzzy"><code class="xref py py-func docutils literal notranslate"><span class="pre">Fuzzy</span></code></a> version can be obtained by setting <code class="docutils literal notranslate"><span class="pre">fuzzy=True</span></code>.</p>
<p>This function can be called either via <code class="docutils literal notranslate"><span class="pre">entropy_multiscale()</span></code> or <code class="docutils literal notranslate"><span class="pre">complexity_mse()</span></code>.
Moreover, variants can be directly accessed via <code class="docutils literal notranslate"><span class="pre">complexity_cmse()</span></code>, <cite>complexity_rcmse()`</cite>,
<code class="docutils literal notranslate"><span class="pre">complexity_fuzzymse()</span></code>, <code class="docutils literal notranslate"><span class="pre">complexity_fuzzycmse()</span></code> and <code class="docutils literal notranslate"><span class="pre">complexity_fuzzyrcmse()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.
or dataframe.</p></li>
<li><p><strong>scale</strong> (<em>str or int or list</em>) – A list of scale factors used for coarse graining the time series. If ‘default’, will use
<code class="docutils literal notranslate"><span class="pre">range(len(signal)</span> <span class="pre">/</span> <span class="pre">(dimension</span> <span class="pre">+</span> <span class="pre">10))</span></code> (see discussion
<a class="reference external" href="https://github.com/neuropsychology/NeuroKit/issues/75#issuecomment-583884426">here</a>).
If ‘max’, will use all scales until half the length of the signal. If an integer, will
create a range until the specified int. See <a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_coarsegraining()</span></code></a> for details.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – What version of multiscale entropy to compute. Can be one of <code class="docutils literal notranslate"><span class="pre">&quot;MSEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;CMSEn&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;RCMSEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MMSEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;IMSEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MSApEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MSPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;CMSPEn&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;MMSPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;IMSPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MSWPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;CMSWPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MMSWPEn&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;IMSWPEn&quot;</span></code>
(case sensitive).</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Show the entropy values for each scale factor.</p></li>
<li><p><strong>**kwargs</strong> – Optional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – The point-estimate of multiscale entropy (MSEn) of the single time series corresponding to
the area under the MSEn values curve, which is essentially the sum of sample entropy values
over the range of scale factors.</p></li>
<li><p><em>dict</em> – A dictionary containing additional information regarding the parameters used
to compute multiscale entropy. The entropy values corresponding to each <code class="docutils literal notranslate"><span class="pre">&quot;Scale&quot;</span></code>
factor are stored under the <code class="docutils literal notranslate"><span class="pre">&quot;Value&quot;</span></code> key.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_coarsegraining</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_sample" title="neurokit2.complexity.entropy_sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_sample</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_fuzzy" title="neurokit2.complexity.entropy_fuzzy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_fuzzy</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_permutation</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p><strong>MSEn</strong> (basic coarse-graining)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>

<span class="gp">In [3]: </span><span class="n">msen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale1.png"><img alt="../_images/p_entropy_multiscale1.png" src="../_images/p_entropy_multiscale1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>CMSEn</strong> (time-shifted coarse-graining)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">cmsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;CMSEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale2.png"><img alt="../_images/p_entropy_multiscale2.png" src="../_images/p_entropy_multiscale2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>RCMSEn</strong> (refined composite MSEn)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">rcmsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;RCMSEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale3.png"><img alt="../_images/p_entropy_multiscale3.png" src="../_images/p_entropy_multiscale3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>MMSEn</strong> (rolling-window coarse-graining)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">mmsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MMSEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale4.png"><img alt="../_images/p_entropy_multiscale4.png" src="../_images/p_entropy_multiscale4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>IMSEn</strong> (interpolated coarse-graining)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">imsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;IMSEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale5.png"><img alt="../_images/p_entropy_multiscale5.png" src="../_images/p_entropy_multiscale5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>MSApEn</strong> (based on ApEn instead of SampEn)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">msapen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSApEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale6.png"><img alt="../_images/p_entropy_multiscale6.png" src="../_images/p_entropy_multiscale6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>MSPEn</strong> (based on PEn), <strong>CMSPEn</strong>, <strong>MMSPEn</strong> and <strong>IMSPEn</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">mspen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSPEn&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale7.png"><img alt="../_images/p_entropy_multiscale7.png" src="../_images/p_entropy_multiscale7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">cmspen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;CMSPEn&quot;</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">cmspen</span>
<span class="gh">Out[11]: </span><span class="go">np.float64(0.9270529263870483)</span>

<span class="gp">In [12]: </span><span class="n">mmspen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MMSPEn&quot;</span><span class="p">)</span>

<span class="gp">In [13]: </span><span class="n">mmspen</span>
<span class="gh">Out[13]: </span><span class="go">np.float64(0.953782723664592)</span>

<span class="gp">In [14]: </span><span class="n">imspen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;IMSPEn&quot;</span><span class="p">)</span>

<span class="gp">In [15]: </span><span class="n">imspen</span>
<span class="gh">Out[15]: </span><span class="go">np.float64(0.954390411042964)</span>
</pre></div>
</div>
<p><strong>MSWPEn</strong> (based on WPEn), <strong>CMSWPEn</strong>, <strong>MMSWPEn</strong> and <strong>IMSWPEn</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [16]: </span><span class="n">mswpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSWPEn&quot;</span><span class="p">)</span>

<span class="gp">In [17]: </span><span class="n">cmswpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;CMSWPEn&quot;</span><span class="p">)</span>

<span class="gp">In [18]: </span><span class="n">mmswpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MMSWPEn&quot;</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">imswpen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;IMSWPEn&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>FuzzyMSEn</strong>, <strong>FuzzyCMSEn</strong> and <strong>FuzzyRCMSEn</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">fuzzymsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;MSEn&quot;</span><span class="p">,</span> <span class="n">fuzzy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_multiscale8.png"><img alt="../_images/p_entropy_multiscale8.png" src="../_images/p_entropy_multiscale8.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [21]: </span><span class="n">fuzzycmsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;CMSEn&quot;</span><span class="p">,</span> <span class="n">fuzzy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">fuzzycmsen</span>
<span class="gh">Out[22]: </span><span class="go">np.float64(1.0155636506693684)</span>

<span class="gp">In [23]: </span><span class="n">fuzzyrcmsen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;RCMSEn&quot;</span><span class="p">,</span> <span class="n">fuzzy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [24]: </span><span class="n">fuzzycmsen</span>
<span class="gh">Out[24]: </span><span class="go">np.float64(1.0155636506693684)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Costa, M., Goldberger, A. L., &amp; Peng, C. K. (2002). Multiscale entropy analysis of complex
physiologic time series. Physical review letters, 89(6), 068102.</p></li>
<li><p>Costa, M., Goldberger, A. L., &amp; Peng, C. K. (2005). Multiscale entropy analysis of biological
signals. Physical review E, 71(2), 021906.</p></li>
<li><p>Wu, S. D., Wu, C. W., Lee, K. Y., &amp; Lin, S. G. (2013). Modified multiscale entropy for
short-term time series analysis. Physica A: Statistical Mechanics and its Applications, 392
(23), 5865-5873.</p></li>
<li><p>Wu, S. D., Wu, C. W., Lin, S. G., Wang, C. C., &amp; Lee, K. Y. (2013). Time series analysis
using composite multiscale entropy. Entropy, 15(3), 1069-1084.</p></li>
<li><p>Wu, S. D., Wu, C. W., Lin, S. G., Lee, K. Y., &amp; Peng, C. K. (2014). Analysis of complex time
series using refined composite multiscale entropy. Physics Letters A, 378(20), 1369-1374.</p></li>
<li><p>Gow, B. J., Peng, C. K., Wayne, P. M., &amp; Ahn, A. C. (2015). Multiscale entropy analysis of
center-of-pressure dynamics in human postural control: methodological considerations. Entropy,
17(12), 7926-7947.</p></li>
<li><p>Norris, P. R., Anderson, S. M., Jenkins, J. M., Williams, A. E., &amp; Morris Jr, J. A. (2008).
Heart rate multiscale entropy at three hours predicts hospital mortality in 3,154 trauma
patients. Shock, 30(1), 17-22.</p></li>
<li><p>Liu, Q., Wei, Q., Fan, S. Z., Lu, C. W., Lin, T. Y., Abbod, M. F., &amp; Shieh, J. S. (2012).
Adaptive computation of multiscale entropy and its application in EEG signals for monitoring
depth of anesthesia during surgery. Entropy, 14(6), 978-992.</p></li>
</ul>
</dd></dl>

</section>
<section id="entropy-hierarchical">
<h3><em>entropy_hierarchical()</em><a class="headerlink" href="#entropy-hierarchical" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_hierarchical">
<span class="sig-name descname"><span class="pre">entropy_hierarchical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_hierarchical.html#entropy_hierarchical"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_hierarchical" title="Link to this definition">#</a></dt>
<dd><p><strong>Hierarchical Entropy (HEn)</strong></p>
<p>Hierarchical Entropy (HEn) can be viewed as a generalization of the multiscale
decomposition used in <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiscale</span> <span class="pre">entropy</span></code></a>, and the Haar wavelet
decomposition since it generate subtrees of the hierarchical tree. It preserves the strength of
the multiscale decomposition with additional components of higher frequency in different
scales. The hierarchical decomposition, unlike the wavelet decomposition, contains redundant
components, which makes it sensitive to the dynamical richness of the time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>scale</strong> (<em>int</em>) – The maximum scale factor. Can only be a number of “default”. Though it behaves a bit
differently here, see <code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_multiscale()</span></code> for details.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Method for symbolic sequence partitioning. Can be one of <code class="docutils literal notranslate"><span class="pre">&quot;MEP&quot;</span></code> (default),
<code class="docutils literal notranslate"><span class="pre">&quot;linear&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;kmeans&quot;</span></code>.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other keyword arguments (currently not used).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>SyDyEn</strong> (<em>float</em>) – Symbolic Dynamic Entropy (SyDyEn) of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_multiscale</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a Signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="go"># Compute Hierarchical Entropy (HEn)</span>
<span class="gp">In [3]: </span><span class="n">hen</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_hierarchical</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_entropy_hierarchical1.png"><img alt="../_images/p_entropy_hierarchical1.png" src="../_images/p_entropy_hierarchical1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Jiang, Y., Peng, C. K., &amp; Xu, Y. (2011). Hierarchical entropy analysis for biological
signals. Journal of Computational and Applied Mathematics, 236(5), 728-742.</p></li>
<li><p>Li, W., Shen, X., &amp; Li, Y. (2019). A comparative study of multiscale sample entropy and
hierarchical entropy and its application in feature extraction for ship-radiated noise.
Entropy, 21(8), 793.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="other-indices">
<h2>Other indices<a class="headerlink" href="#other-indices" title="Link to this heading">#</a></h2>
<section id="fisher-information">
<h3><em>fisher_information()</em><a class="headerlink" href="#fisher-information" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fisher_information">
<span class="sig-name descname"><span class="pre">fisher_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/information_fisher.html#fisher_information"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fisher_information" title="Link to this definition">#</a></dt>
<dd><p><strong>Fisher Information (FI)</strong></p>
<p>The Fisher information was introduced by R. A. Fisher in 1925, as a measure of “intrinsic
accuracy” in statistical estimation theory. It is central to many statistical fields far beyond
that of complexity theory. It measures the amount of information that an observable random
variable carries about an unknown parameter. In complexity analysis, the amount of information
that a system carries “about itself” is measured. Similarly to <a class="reference internal" href="#neurokit2.complexity.entropy_svd" title="neurokit2.complexity.entropy_svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">SVDEn</span></code></a>, it
is based on the Singular Value Decomposition (SVD) of the <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">time-delay</span> <span class="pre">embedded</span></code></a>
signal. The value of FI is usually anti-correlated with other measures of complexity (the more
information a system withholds about itself, and the more predictable and thus, less complex it
is).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_svd" title="neurokit2.complexity.entropy_svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_svd</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">information_mutual</span></code>, <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embedding</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fi</strong> (<em>float</em>) – The computed fisher information measure.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute fisher information.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">fi</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fisher_information</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">fi</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.6424727558784687)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="fishershannon-information">
<h3><em>fishershannon_information()</em><a class="headerlink" href="#fishershannon-information" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fishershannon_information">
<span class="sig-name descname"><span class="pre">fishershannon_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/information_fishershannon.html#fishershannon_information"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fishershannon_information" title="Link to this definition">#</a></dt>
<dd><p><strong>Fisher-Shannon Information (FSI)</strong></p>
<p>The <a class="reference internal" href="#neurokit2.complexity.entropy_power" title="neurokit2.complexity.entropy_power"><code class="xref py py-func docutils literal notranslate"><span class="pre">Shannon</span> <span class="pre">Entropy</span> <span class="pre">Power</span></code></a> is closely related to another index, the
Fisher Information Measure (FIM). Their combination results in the Fisher-Shannon Information
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We are not sure at all about the correct implementation of this function. Please consider
helping us by double-checking the code against the formulas in the references.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">density_bandwidth()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fsi</strong> (<em>float</em>) – The computed FSI.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_power" title="neurokit2.complexity.entropy_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_power</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">fsi</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fishershannon_information</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">fsi</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.0002686249472149861)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Guignard, F., Laib, M., Amato, F., &amp; Kanevski, M. (2020). Advanced analysis of temporal data
using Fisher-Shannon information: theoretical development and application in geosciences.
Frontiers in Earth Science, 8, 255.</p></li>
<li><p>Vignat, C., &amp; Bercher, J. F. (2003). Analysis of signals in the Fisher-Shannon information
plane. Physics Letters A, 312(1-2), 27-33.</p></li>
</ul>
</dd></dl>

</section>
<section id="mutual-information">
<h3><em>mutual_information()</em><a class="headerlink" href="#mutual-information" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.mutual_information">
<span class="sig-name descname"><span class="pre">mutual_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'varoquaux'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/information_mutual.html#mutual_information"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.mutual_information" title="Link to this definition">#</a></dt>
<dd><p><strong>Mutual Information (MI)</strong></p>
<p>Computes the mutual information (MI) between two vectors from a joint histogram.
The mutual information of two variables is a measure of the mutual dependence between them.
More specifically, it quantifies the “amount of information” obtained about one variable by
observing the other variable.</p>
<p>Different methods are available:</p>
<ul class="simple">
<li><p><strong>nolitsa</strong>: Standard mutual information (a bit faster than the <code class="docutils literal notranslate"><span class="pre">&quot;sklearn&quot;</span></code> method).</p></li>
<li><p><strong>varoquaux</strong>: Applies a Gaussian filter on the joint-histogram. The smoothing amount can be
modulated via the <code class="docutils literal notranslate"><span class="pre">sigma</span></code> argument (by default, <code class="docutils literal notranslate"><span class="pre">sigma=1</span></code>).</p></li>
<li><p><strong>knn</strong>: Non-parametric (i.e., not based on binning) estimation via nearest neighbors.
Additional parameters includes <code class="docutils literal notranslate"><span class="pre">k</span></code> (by default, <code class="docutils literal notranslate"><span class="pre">k=3</span></code>), the number of nearest neighbors
to use.</p></li>
<li><p><strong>max</strong>: Maximum Mutual Information coefficient, i.e., the MI is maximal given a certain
combination of number of bins.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Union[list, np.array, pd.Series]</em>) – A vector of values.</p></li>
<li><p><strong>y</strong> (<em>Union[list, np.array, pd.Series]</em>) – A vector of values.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The method to use.</p></li>
<li><p><strong>bins</strong> (<em>int</em>) – Number of bins to use while creating the histogram. Only used for <code class="docutils literal notranslate"><span class="pre">&quot;nolitsa&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;varoquaux&quot;</span></code>. If <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>, the number of bins is estimated following
Hacine-Gharbi (2018).</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments to pass to the chosen method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>float</em> – The computed similarity measure.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">information_fisher</span></code></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Example 1</strong>: Simple case</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [4]: </span><span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;varoquaux&quot;</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.0001470209869369743)</span>

<span class="gp">In [5]: </span><span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nolitsa&quot;</span><span class="p">)</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.22002600168808772)</span>

<span class="gp">In [6]: </span><span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;knn&quot;</span><span class="p">)</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(1.2435788908307561)</span>

<span class="gp">In [7]: </span><span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
<span class="gh">Out[7]: </span><span class="go">np.float64(0.19200837690707584)</span>
</pre></div>
</div>
<p><strong>Example 2</strong>: Method comparison</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="gp">In [9]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="gp">In [10]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="gp">In [12]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

<span class="gp">In [13]: </span><span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">200</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">rez</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;Noise&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">level</span><span class="p">]})</span>
<span class="gp">   ....: </span>    <span class="n">rez</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;varoquaux&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">rez</span><span class="p">[</span><span class="s2">&quot;MI2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;varoquaux&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">rez</span><span class="p">[</span><span class="s2">&quot;MI3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nolitsa&quot;</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">rez</span><span class="p">[</span><span class="s2">&quot;MI4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;knn&quot;</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">rez</span><span class="p">[</span><span class="s2">&quot;MI5&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">noise</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">rez</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [14]: </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">])</span>

<span class="gp">In [15]: </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI2&quot;</span><span class="p">])</span>

<span class="gp">In [16]: </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI3&quot;</span><span class="p">])</span>

<span class="gp">In [17]: </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI4&quot;</span><span class="p">])</span>

<span class="gp">In [18]: </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI5&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;MI5&quot;</span><span class="p">])</span>

<span class="gp">In [19]: </span><span class="n">data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;Noise&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;MI1&quot;</span><span class="p">,</span> <span class="s2">&quot;MI2&quot;</span><span class="p">,</span> <span class="s2">&quot;MI3&quot;</span><span class="p">,</span> <span class="s2">&quot;MI4&quot;</span><span class="p">,</span> <span class="s2">&quot;MI5&quot;</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;line&quot;</span><span class="p">)</span>
<span class="gh">Out[19]: </span><span class="go">&lt;Axes: xlabel=&#39;Noise&#39;&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_information_mutual1.png"><img alt="../_images/p_information_mutual1.png" src="../_images/p_information_mutual1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Computation time</span>
<span class="c1"># x = np.random.normal(size=10000)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;varoquaux&quot;)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;nolitsa&quot;)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;sklearn&quot;)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;knn&quot;, k=2)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;knn&quot;, k=5)</span>
<span class="c1"># %timeit nk.mutual_information(x, x**2, method=&quot;max&quot;)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Studholme, C., Hawkes, D. J., &amp; Hill, D. L. (1998, June). Normalized entropy measure for
multimodality image alignment. In Medical imaging 1998: image processing (Vol. 3338, pp.
132-143). SPIE.</p></li>
<li><p>Hacine-Gharbi, A., &amp; Ravier, P. (2018). A binning formula of bi-histogram for joint entropy
estimation using mean square error minimization. Pattern Recognition Letters, 101, 21-28.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-hjorth">
<h3><em>complexity_hjorth()</em><a class="headerlink" href="#complexity-hjorth" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_hjorth">
<span class="sig-name descname"><span class="pre">complexity_hjorth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_hjorth.html#complexity_hjorth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_hjorth" title="Link to this definition">#</a></dt>
<dd><p><strong>Hjorth’s Complexity and Parameters</strong></p>
<p>Hjorth Parameters are indicators of statistical properties initially introduced by Hjorth
(1970) to describe the general characteristics of an EEG trace in a few quantitative terms, but
which can applied to any time series. The parameters are activity, mobility, and complexity.
NeuroKit returns complexity directly in the output tuple, but the other parameters can be found
in the dictionary.</p>
<ul>
<li><p>The <strong>activity</strong> parameter is simply the variance of the signal, which corresponds to the
mean power of a signal (if its mean is 0).</p>
<div class="math notranslate nohighlight">
\[Activity = \sigma_{signal}^2\]</div>
</li>
<li><p>The <strong>mobility</strong> parameter represents the mean frequency or the proportion of standard
deviation of the power spectrum. This is defined as the square root of variance of the
first derivative of the signal divided by the variance of the signal.</p>
<div class="math notranslate nohighlight">
\[Mobility = \frac{\sigma_{dd}/ \sigma_{d}}{Complexity}\]</div>
</li>
<li><p>The <strong>complexity</strong> parameter gives an estimate of the bandwidth of the signal, which
indicates the similarity of the shape of the signal to a pure sine wave (for which the
value converges to 1). In other words, it is a measure of the “excessive details” with
reference to the “softest” possible curve shape. The Complexity parameter is defined as the
ratio of the mobility of the first derivative of the signal to the mobility of the signal.</p>
<div class="math notranslate nohighlight">
\[Complexity = \sigma_{d}/ \sigma_{signal}\]</div>
</li>
</ul>
<p><span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(dd\)</span> represent the first and second derivatives of the signal, respectively.</p>
<p>Hjorth (1970) illustrated the parameters as follows:</p>
<figure class="align-default">
<a class="reference external image-reference" href="http://dx.doi.org/10.1016/0013-4694(70)90143-4"><img alt="Figure from Hjorth (1970)." src="../_images/hjorth1970.png" />
</a>
</figure>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.fractal_petrosian" title="neurokit2.complexity.fractal_petrosian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_petrosian</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hjorth</strong> (<em>float</em>) – Hjorth’s Complexity.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing the additional Hjorth parameters, such as <code class="docutils literal notranslate"><span class="pre">&quot;Mobility&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;Activity&quot;</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a signal with duration os 2s</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="go"># Compute Hjorth&#39;s Complexity</span>
<span class="gp">In [3]: </span><span class="n">complexity</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_hjorth</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">complexity</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.0010008861067599)</span>

<span class="gp">In [5]: </span><span class="n">info</span>
<span class="gh">Out[5]: </span><span class="go">{&#39;Mobility&#39;: np.float64(0.03140677206992582), &#39;Activity&#39;: np.float64(0.125)}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Hjorth, B (1970) EEG Analysis Based on Time Domain Properties. Electroencephalography and
Clinical Neurophysiology, 29, 306-310.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-decorrelation">
<h3><em>complexity_decorrelation()</em><a class="headerlink" href="#complexity-decorrelation" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_decorrelation">
<span class="sig-name descname"><span class="pre">complexity_decorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_decorrelation.html#complexity_decorrelation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_decorrelation" title="Link to this definition">#</a></dt>
<dd><p><strong>Decorrelation Time (DT)</strong></p>
<p>The decorrelation time (DT) is defined as the time (in samples) of the first zero crossing of
the autocorrelation sequence. A shorter decorrelation time corresponds to a less correlated
signal. For instance, a drop in the decorrelation time of EEG has been observed prior to
seizures, related to a decrease in the low frequency power (Mormann et al., 2005).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If True, will return a plot of the autocorrelation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – Decorrelation Time (DT)</p></li>
<li><p><em>dict</em> – A dictionary containing additional information (currently empty, but returned nonetheless
for consistency with other functions).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="signal.html#neurokit2.signal_autocor" title="neurokit2.signal_autocor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal_autocor</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="go"># Simulate a signal</span>
<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># Compute DT</span>
<span class="gp">In [3]: </span><span class="n">dt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_decorrelation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">dt</span>
<span class="gh">Out[4]: </span><span class="go">np.int64(5)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_decorrelation1.png"><img alt="../_images/p_complexity_decorrelation1.png" src="../_images/p_complexity_decorrelation1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Mormann, F., Kreuz, T., Rieke, C., Andrzejak, R. G., Kraskov, A., David, P., … &amp; Lehnertz,
K. (2005). On the predictability of epileptic seizures. Clinical neurophysiology, 116(3),
569-587.</p></li>
<li><p>Teixeira, C. A., Direito, B., Feldwisch-Drentrup, H., Valderrama, M., Costa, R. P.,
Alvarado-Rojas, C., … &amp; Dourado, A. (2011). EPILAB: A software package for studies on the
prediction of epileptic seizures. Journal of Neuroscience Methods, 200(2), 257-271.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-lempelziv">
<h3><em>complexity_lempelziv()</em><a class="headerlink" href="#complexity-lempelziv" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_lempelziv">
<span class="sig-name descname"><span class="pre">complexity_lempelziv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_lempelziv.html#complexity_lempelziv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_lempelziv" title="Link to this definition">#</a></dt>
<dd><p><strong>Lempel-Ziv Complexity (LZC, PLZC and MSLZC)</strong></p>
<p>Computes Lempel-Ziv Complexity (LZC) to quantify the regularity of the signal, by scanning
symbolic sequences for new patterns, increasing the complexity count every time a new sequence
is detected. Regular signals have a lower number of distinct patterns and thus have low LZC
whereas irregular signals are characterized by a high LZC. While often being interpreted as a
complexity measure, LZC was originally proposed to reflect randomness (Lempel and Ziv, 1976).</p>
<p>Permutation Lempel-Ziv Complexity (<strong>PLZC</strong>) combines LZC with <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">permutation</span></code></a>.
A sequence of symbols is generated from the permutations observed in the <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">tine-delay</span>
<span class="pre">embedding</span></code></a>, and LZC is computed over it.</p>
<p>Multiscale (Permutation) Lempel-Ziv Complexity (<strong>MSLZC</strong> or <strong>MSPLZC</strong>) combines permutation
LZC with the <a class="reference internal" href="#neurokit2.complexity.entropy_multiscale" title="neurokit2.complexity.entropy_multiscale"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiscale</span> <span class="pre">approach</span></code></a>. It first performs a
<a class="reference internal" href="#neurokit2.complexity.complexity_coarsegraining" title="neurokit2.complexity.complexity_coarsegraining"><code class="xref py py-func docutils literal notranslate"><span class="pre">coarse-graining</span></code></a> procedure to the original time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter. Only used
when <code class="docutils literal notranslate"><span class="pre">permutation=True</span></code>.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter. Only used
when <code class="docutils literal notranslate"><span class="pre">permutation=True</span></code></p></li>
<li><p><strong>permutation</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will return PLZC.</p></li>
<li><p><strong>symbolize</strong> (<em>str</em>) – Only used when <code class="docutils literal notranslate"><span class="pre">permutation=False</span></code>. Method to convert a continuous signal input into a
symbolic (discrete) signal. By default, assigns 0 and 1 to values below and above the mean.
Can be <code class="docutils literal notranslate"><span class="pre">None</span></code> to skip the process (in case the input is already discrete). See
<a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <a class="reference internal" href="#neurokit2.complexity.complexity_ordinalpatterns" title="neurokit2.complexity.complexity_ordinalpatterns"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_ordinalpatterns()</span></code></a> (if
<code class="docutils literal notranslate"><span class="pre">permutation=True</span></code>) or <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lzc</strong> (<em>float</em>) – Lempel Ziv Complexity (LZC) of the signal.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute LZC.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_symbolize</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_ordinalpatterns" title="neurokit2.complexity.complexity_ordinalpatterns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_ordinalpatterns</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_permutation</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="go"># LZC</span>
<span class="gp">In [3]: </span><span class="n">lzc</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_lempelziv</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">lzc</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.0588723832474038)</span>

<span class="go"># PLZC</span>
<span class="gp">In [5]: </span><span class="n">plzc</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_lempelziv</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">plzc</span>
<span class="gh">Out[6]: </span><span class="go">np.float64(0.7051573072286799)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># MSLZC</span>
<span class="gp">In [7]: </span><span class="n">mslzc</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;LZC&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_lempelziv1.png"><img alt="../_images/p_complexity_lempelziv1.png" src="../_images/p_complexity_lempelziv1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># MSPLZC</span>
<span class="gp">In [8]: </span><span class="n">msplzc</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_multiscale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;LZC&quot;</span><span class="p">,</span> <span class="n">permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_lempelziv2.png"><img alt="../_images/p_complexity_lempelziv2.png" src="../_images/p_complexity_lempelziv2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lempel, A., &amp; Ziv, J. (1976). On the complexity of finite sequences. IEEE Transactions on
information theory, 22(1), 75-81.</p></li>
<li><p>Nagarajan, R. (2002). Quantifying physiological data with Lempel-Ziv complexity-certain
issues. IEEE Transactions on Biomedical Engineering, 49(11), 1371-1373.</p></li>
<li><p>Kaspar, F., &amp; Schuster, H. G. (1987). Easily calculable measure for the complexity of
spatiotemporal patterns. Physical Review A, 36(2), 842.</p></li>
<li><p>Zhang, Y., Hao, J., Zhou, C., &amp; Chang, K. (2009). Normalized Lempel-Ziv complexity and
its application in bio-sequence analysis. Journal of mathematical chemistry, 46(4), 1203-1212.</p></li>
<li><p>Bai, Y., Liang, Z., &amp; Li, X. (2015). A permutation Lempel-Ziv complexity measure for EEG
analysis. Biomedical Signal Processing and Control, 19, 102-114.</p></li>
<li><p>Borowska, M. (2021). Multiscale Permutation Lempel-Ziv Complexity Measure for Biomedical
Signal Analysis: Interpretation and Application to Focal EEG Signals. Entropy, 23(7), 832.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-relativeroughness">
<h3><em>complexity_relativeroughness()</em><a class="headerlink" href="#complexity-relativeroughness" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_relativeroughness">
<span class="sig-name descname"><span class="pre">complexity_relativeroughness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_relativeroughness.html#complexity_relativeroughness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_relativeroughness" title="Link to this definition">#</a></dt>
<dd><p><strong>Relative Roughness (RR)</strong></p>
<p>Relative Roughness is a ratio of local variance (autocovariance at lag-1) to global variance
(autocovariance at lag-0) that can be used to classify different ‘noises’
(see <a class="reference external" href="https://complexity-methods.github.io/book/relative-roughness.html">Hasselman, 2019</a>).
It can also be used as an index to test for the applicability of fractal analysis (see
<a class="reference external" href="https://doi.org/10.3389/fphys.2012.00208">Marmelat et al., 2012</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments to be passed to <code class="docutils literal notranslate"><span class="pre">nk.signal_autocor()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rr</strong> (<em>float</em>) – The RR value.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute RR.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">rr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_relativeroughness</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">rr</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(1.2)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Marmelat, V., Torre, K., &amp; Delignieres, D. (2012). Relative roughness:
an index for testing the suitability of the monofractal model.
Frontiers in Physiology, 3, 208.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-lyapunov">
<h3><em>complexity_lyapunov()</em><a class="headerlink" href="#complexity-lyapunov" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_lyapunov">
<span class="sig-name descname"><span class="pre">complexity_lyapunov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rosenstein1993'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_lyapunov.html#complexity_lyapunov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_lyapunov" title="Link to this definition">#</a></dt>
<dd><p><strong>(Largest) Lyapunov Exponent (LLE)</strong></p>
<p>Lyapunov exponents (LE) describe the rate of exponential separation (convergence or divergence)
of nearby trajectories of a dynamical system. It is a measure of sensitive dependence on
initial conditions, i.e. how quickly two nearby states diverge. A system can have multiple LEs,
equal to the number of the dimensionality of the phase space, and the largest LE value, “LLE” is
often used to determine the overall predictability of the dynamical system.</p>
<p>Different algorithms exist to estimate these indices:</p>
<ul class="simple">
<li><p><strong>Rosenstein et al.’s (1993)</strong> algorithm was designed for calculating LLEs from small
datasets. The time series is first reconstructed using a delay-embedding method, and the
closest neighbour of each vector is computed using the euclidean distance. These two
neighbouring points are then tracked along their distance trajectories for a number of data
points. The slope of the line using a least-squares fit of the mean log trajectory of the
distances gives the final LLE.</p></li>
<li><p><strong>Makowski</strong> is a custom modification of Rosenstein’s algorithm, using KDTree for more
efficient nearest neighbors computation. Additionally, the LLE is computed as the slope up to
the changepoint of divergence rate (the point where it flattens out), making it more robust
to the length trajectory parameter.</p></li>
<li><p><strong>Eckmann et al. (1986)</strong> computes LEs by first reconstructing the time series using a
delay-embedding method, and obtains the tangent that maps to the reconstructed dynamics using
a least-squares fit, where the LEs are deduced from the tangent maps.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <strong>Eckman (1986)</strong> method currently does not work. Please help us fixing it by double
checking the code, the paper and helping us figuring out what’s wrong. Overall, we would like
to improve this function to return for instance all the exponents (Lyapunov spectrum),
implement newer and faster methods (e.g., Balcerzak, 2018, 2020), etc. If you’re interested
in helping out with this, please get in touch!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter. If method
is <code class="docutils literal notranslate"><span class="pre">&quot;eckmann1986&quot;</span></code>, larger values for dimension are recommended.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The method that defines the algorithm for computing LE. Can be one of <code class="docutils literal notranslate"><span class="pre">&quot;rosenstein1993&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;makowski&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;eckmann1986&quot;</span></code>.</p></li>
<li><p><strong>len_trajectory</strong> (<em>int</em>) – Applies when method is <code class="docutils literal notranslate"><span class="pre">&quot;rosenstein1993&quot;</span></code>. The number of data points in which
neighboring trajectories are followed.</p></li>
<li><p><strong>matrix_dim</strong> (<em>int</em>) – Applies when method is <code class="docutils literal notranslate"><span class="pre">&quot;eckmann1986&quot;</span></code>. Corresponds to the number of LEs to return.</p></li>
<li><p><strong>min_neighbors</strong> (<em>int, str</em>) – Applies when method is <code class="docutils literal notranslate"><span class="pre">&quot;eckmann1986&quot;</span></code>. Minimum number of neighbors. If <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">min(2</span> <span class="pre">*</span> <span class="pre">matrix_dim,</span> <span class="pre">matrix_dim</span> <span class="pre">+</span> <span class="pre">4)</span></code> is used.</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – Other arguments to be passed to <code class="docutils literal notranslate"><span class="pre">signal_psd()</span></code> for calculating the minimum temporal
separation of two neighbors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>lle</strong> (<em>float</em>) – An estimate of the largest Lyapunov exponent (LLE) if method is <code class="docutils literal notranslate"><span class="pre">&quot;rosenstein1993&quot;</span></code>, and
an array of LEs if <code class="docutils literal notranslate"><span class="pre">&quot;eckmann1986&quot;</span></code>.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used
to compute LLE.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="go"># Rosenstein&#39;s method</span>
<span class="gp">In [3]: </span><span class="n">lle</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_lyapunov</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rosenstein&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">lle</span>
<span class="gh">Out[4]: </span><span class="go">np.float64(0.06320099427691092)</span>

<span class="go"># Makowski&#39;s change-point method</span>
<span class="gp">In [5]: </span><span class="n">lle</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_lyapunov</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;makowski&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="go"># Eckman&#39;s method is broken. Please help us fix-it!</span>
<span class="go"># lle, info = nk.complexity_lyapunov(signal, dimension=2, method=&quot;eckmann1986&quot;)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_lyapunov1.png"><img alt="../_images/p_complexity_lyapunov1.png" src="../_images/p_complexity_lyapunov1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<a class="reference internal image-reference" href="../_images/p_complexity_lyapunov2.png"><img alt="../_images/p_complexity_lyapunov2.png" src="../_images/p_complexity_lyapunov2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rosenstein, M. T., Collins, J. J., &amp; De Luca, C. J. (1993). A practical method
for calculating largest Lyapunov exponents from small data sets.
Physica D: Nonlinear Phenomena, 65(1-2), 117-134.</p></li>
<li><p>Eckmann, J. P., Kamphorst, S. O., Ruelle, D., &amp; Ciliberto, S. (1986). Liapunov
exponents from time series. Physical Review A, 34(6), 4971.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-rqa">
<h3><em>complexity_rqa()</em><a class="headerlink" href="#complexity-rqa" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_rqa">
<span class="sig-name descname"><span class="pre">complexity_rqa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_linelength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'python'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/complexity_rqa.html#complexity_rqa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_rqa" title="Link to this definition">#</a></dt>
<dd><p><strong>Recurrence Quantification Analysis (RQA)</strong></p>
<p>A <a class="reference internal" href="#neurokit2.complexity.recurrence_matrix" title="neurokit2.complexity.recurrence_matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">recurrence</span> <span class="pre">plot</span></code></a> is based on a time-delay embedding representation
of a signal and is a 2D depiction of when a system revisits a state that is has been in the
past.</p>
<p>Recurrence quantification analysis (RQA) is a method of complexity analysis
for the investigation of dynamical systems. It quantifies the number and duration
of recurrences of a dynamical system presented by its phase space trajectory.</p>
<figure class="align-default">
<img alt="Illustration of RQA (Douglas et al., 2022)." src="../_images/douglas2022c.png" />
</figure>
<p>Features include:</p>
<ul class="simple">
<li><p><strong>Recurrence rate (RR)</strong>: Proportion of points that are labelled as recurrences. Depends on
the radius <em>r</em>.</p></li>
<li><p><strong>Determinism (DET)</strong>: Proportion of recurrence points which form diagonal lines. Indicates
autocorrelation.</p></li>
<li><p><strong>Divergence (DIV)</strong>: The inverse of the longest diagonal line length (<em>LMax</em>).</p></li>
<li><p><strong>Laminarity (LAM)</strong>: Proportion of recurrence points which form vertical lines. Indicates the
amount of laminar phases (intermittency).</p></li>
<li><p><strong>Trapping Time (TT)</strong>: Average length of vertical black lines.</p></li>
<li><p><strong>L</strong>: Average length of diagonal black lines. Average duration that a system is staying in
the same state.</p></li>
<li><p><strong>LEn</strong>: Entropy of diagonal lines lengths.</p></li>
<li><p><strong>VMax</strong>: Longest vertical line length.</p></li>
<li><p><strong>VEn</strong>: Entropy of vertical lines lengths.</p></li>
<li><p><strong>W</strong>: Average white vertical line length.</p></li>
<li><p><strong>WMax</strong>: Longest white vertical line length.</p></li>
<li><p><strong>WEn</strong>: Entropy of white vertical lines lengths.</p></li>
<li><p><strong>DeteRec</strong>: The ratio of determinism / recurrence rate.</p></li>
<li><p><strong>LamiDet</strong>: The ratio of laminarity / determinism.</p></li>
<li><p><strong>DiagRec</strong>: Diagonal Recurrence Rates, capturing the magnitude of autocorrelation at
different lags, which is related to fractal fluctuations. See Tomashin et al. (2022),
approach 3.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More feature exist for RQA, such as the <a class="reference external" href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/rqa/quantification/#RecurrenceAnalysis.trend">trend</a>. We would like to add
them, but we need help. Get in touch if you’re interested!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>min_linelength</strong> (<em>int</em>) – Minimum length of diagonal and vertical lines. Default to 2.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Can be <code class="docutils literal notranslate"><span class="pre">&quot;pyrqa&quot;</span></code> to use the <em>PyRQA</em> package (requires to install it first).</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualise recurrence matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rqa</strong> (<em>DataFrame</em>) – The RQA results.</p></li>
<li><p><strong>info</strong> (<em>dict</em>) – A dictionary containing additional information regarding the parameters used to compute RQA.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="go"># RQA</span>
<span class="gp">In [3]: </span><span class="n">results</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_rqa</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_rqa1.png"><img alt="../_images/p_complexity_rqa1.png" src="../_images/p_complexity_rqa1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">results</span>
<span class="gh">Out[4]: </span>
<span class="go">   RecurrenceRate   DiagRec  Determinism  ...         W  WMax       WEn</span>
<span class="go">0        0.239994 -0.067644     0.857205  ...  9.643633   406  2.922534</span>

<span class="go">[1 rows x 14 columns]</span>

<span class="go"># Compare to PyRQA</span>
<span class="go"># results1, info = nk.complexity_rqa(signal, tolerance=1, show=True, method = &quot;pyrqa&quot;)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rawald, T., Sips, M., Marwan, N., &amp; Dransch, D. (2014). Fast computation of recurrences in
long time series. In Translational Recurrences (pp. 17-29). Springer, Cham.</p></li>
<li><p>Tomashin, A., Leonardi, G., &amp; Wallot, S. (2022). Four Methods to Distinguish between Fractal
Dimensions in Time Series through Recurrence Quantification Analysis. Entropy, 24(9), 1314.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Link to this heading">#</a></h2>
<section id="fractal-mandelbrot">
<h3><em>fractal_mandelbrot()</em><a class="headerlink" href="#fractal-mandelbrot" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.fractal_mandelbrot">
<span class="sig-name descname"><span class="pre">fractal_mandelbrot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">real_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-2,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imaginary_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-2,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buddha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_fractal_mandelbrot.html#fractal_mandelbrot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.fractal_mandelbrot" title="Link to this definition">#</a></dt>
<dd><p><strong>Mandelbrot (or a Buddhabrot) Fractal</strong></p>
<p>Vectorized function to efficiently generate an array containing values corresponding to a
Mandelbrot fractal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – The size in pixels (corresponding to the width of the figure).</p></li>
<li><p><strong>real_range</strong> (<em>tuple</em>) – The mandelbrot set is defined within the -2, 2 complex space (the real being the x-axis and
the imaginary the y-axis). Adjusting these ranges can be used to pan, zoom and crop the
figure.</p></li>
<li><p><strong>imaginary_range</strong> (<em>tuple</em>) – The mandelbrot set is defined within the -2, 2 complex space (the real being the x-axis and
the imaginary the y-axis). Adjusting these ranges can be used to pan, zoom and crop the
figure.</p></li>
<li><p><strong>iterations</strong> (<em>int</em>) – Number of iterations.</p></li>
<li><p><strong>threshold</strong> (<em>int</em>) – The threshold used, increasing it will increase the sharpness (not used for buddhabrots).</p></li>
<li><p><strong>buddha</strong> (<em>bool</em>) – Whether to return a buddhabrot.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualize the fractal.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ndarray</em> – Array of values.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create the Mandelbrot fractal</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">m</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_mandelbrot1.png"><img alt="../_images/p_fractal_mandelbrot1.png" src="../_images/p_fractal_mandelbrot1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Zoom at the Seahorse Valley</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">m</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">(</span><span class="n">real_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.76</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.74</span><span class="p">),</span> <span class="n">imaginary_range</span><span class="o">=</span><span class="p">(</span><span class="mf">0.09</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">),</span>
<span class="gp">   ...: </span>                          <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_mandelbrot2.png"><img alt="../_images/p_fractal_mandelbrot2.png" src="../_images/p_fractal_mandelbrot2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Draw manually</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="gp">In [5]: </span><span class="n">m</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">(</span><span class="n">real_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">),</span> <span class="n">imaginary_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">))</span>

<span class="gp">In [6]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
<span class="gh">Out[6]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x260cd068b90&gt;</span>

<span class="gp">In [7]: </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="gh">Out[7]: </span><span class="go">(np.float64(-0.5), np.float64(908.5), np.float64(999.5), np.float64(-0.5))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_mandelbrot3.png"><img alt="../_images/p_fractal_mandelbrot3.png" src="../_images/p_fractal_mandelbrot3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Generate a Buddhabrot fractal</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span> <span class="n">real_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">),</span> <span class="n">imaginary_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">),</span>
<span class="gp">   ...: </span>                          <span class="n">buddha</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">   ...: </span>

<span class="gp">In [9]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="gh">Out[9]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x260d3749a90&gt;</span>

<span class="gp">In [10]: </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">(np.float64(-0.5), np.float64(1363.5), np.float64(1499.5), np.float64(-0.5))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_mandelbrot4.png"><img alt="../_images/p_fractal_mandelbrot4.png" src="../_images/p_fractal_mandelbrot4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p>Mixed MandelBuddha</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">m</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">()</span>

<span class="gp">In [12]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">fractal_mandelbrot</span><span class="p">(</span><span class="n">buddha</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="gp">In [13]: </span><span class="n">mixed</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">b</span>

<span class="gp">In [14]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mixed</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="gh">Out[14]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x260d3818f50&gt;</span>

<span class="gp">In [15]: </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="gh">Out[15]: </span><span class="go">(np.float64(-0.5), np.float64(999.5), np.float64(999.5), np.float64(-0.5))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_fractal_mandelbrot5.png"><img alt="../_images/p_fractal_mandelbrot5.png" src="../_images/p_fractal_mandelbrot5.png" style="width: 640.0px; height: 480.0px;" />
</a>
</dd></dl>

</section>
<section id="complexity-simulate">
<h3><em>complexity_simulate()</em><a class="headerlink" href="#complexity-simulate" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_simulate">
<span class="sig-name descname"><span class="pre">complexity_simulate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ornstein'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hurst_exponent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_simulate.html#complexity_simulate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_simulate" title="Link to this definition">#</a></dt>
<dd><p><strong>Simulate chaotic time series</strong></p>
<p>This function generates a chaotic signal using different algorithms and complex systems.</p>
<ul class="simple">
<li><p><strong>Mackey-Glass:</strong> Generates time series using the discrete approximation of the
Mackey-Glass delay differential equation described by Grassberger &amp; Procaccia (1983).</p></li>
<li><p><strong>Ornstein-Uhlenbeck</strong></p></li>
<li><p><strong>Lorenz</strong></p></li>
<li><p><strong>Random walk</strong></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>duration</strong> (<em>int</em>) – Desired length of duration (s).</p></li>
<li><p><strong>sampling_rate</strong> (<em>int</em>) – The desired sampling rate (in Hz, i.e., samples/second).</p></li>
<li><p><strong>duration</strong> (<em>int</em>) – The desired length in samples.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The method. can be <code class="docutils literal notranslate"><span class="pre">&quot;hurst&quot;</span></code> for a (fractional) Ornstein-Uhlenbeck process, <code class="docutils literal notranslate"><span class="pre">&quot;lorenz&quot;</span></code>
for the first dimension of a Lorenz system, <code class="docutils literal notranslate"><span class="pre">&quot;mackeyglass&quot;</span></code> to use the Mackey-Glass
equation, or <code class="docutils literal notranslate"><span class="pre">random</span></code> to generate a random-walk.</p></li>
<li><p><strong>hurst_exponent</strong> (<em>float</em>) – Defaults to <code class="docutils literal notranslate"><span class="pre">0.5</span></code>.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>array</em> – Simulated complexity time series.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><strong>Lorenz System</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lorenz&quot;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate1.png"><img alt="../_images/p_complexity_simulate1.png" src="../_images/p_complexity_simulate1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">5</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate2.png"><img alt="../_images/p_complexity_simulate2.png" src="../_images/p_complexity_simulate2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Ornstein System</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ornstein&quot;</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate3.png"><img alt="../_images/p_complexity_simulate3.png" src="../_images/p_complexity_simulate3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">100</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="gh">Out[7]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate4.png"><img alt="../_images/p_complexity_simulate4.png" src="../_images/p_complexity_simulate4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Mackey-Glass System</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mackeyglass&quot;</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate5.png"><img alt="../_images/p_complexity_simulate5.png" src="../_images/p_complexity_simulate5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">25</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate6.png"><img alt="../_images/p_complexity_simulate6.png" src="../_images/p_complexity_simulate6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Random walk</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;randomwalk&quot;</span><span class="p">)</span>

<span class="gp">In [12]: </span><span class="n">nk</span><span class="o">.</span><span class="n">signal_plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;orange&quot;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate7.png"><img alt="../_images/p_complexity_simulate7.png" src="../_images/p_complexity_simulate7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">100</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="gh">Out[13]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_simulate8.png"><img alt="../_images/p_complexity_simulate8.png" src="../_images/p_complexity_simulate8.png" style="width: 640.0px; height: 480.0px;" />
</a>
</dd></dl>

</section>
<section id="complexity-embedding">
<h3><em>complexity_embedding()</em><a class="headerlink" href="#complexity-embedding" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_embedding">
<span class="sig-name descname"><span class="pre">complexity_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_embedding.html#complexity_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_embedding" title="Link to this definition">#</a></dt>
<dd><p><strong>Time-delay Embedding of a Signal</strong></p>
<p>Time-delay embedding is one of the key concept of complexity science. It is based on the idea
that a dynamical system can be described by a vector of numbers, called its <em>‘state’</em>, that
aims to provide a complete description of the system at some point in time. The set of all
possible states is called the <em>‘state space’</em>.</p>
<p>Takens’s (1981) embedding theorem suggests that a sequence of measurements of a dynamic system
includes in itself all the information required to completely reconstruct the state space.
Time-delay embedding attempts to identify the state <em>s</em> of the system at some time <em>t</em> by
searching the past history of observations for similar states, and, by studying the evolution
of similar states, infer information about the future of the system.</p>
<p><strong>Attractors</strong></p>
<p>How to visualize the dynamics of a system? A sequence of state values over time is called a
trajectory. Depending on the system, different trajectories can evolve to a common subset of
state space called an attractor. The presence and behavior of attractors gives intuition about
the underlying dynamical system. We can visualize the system and its attractors by plotting the
trajectory of many different initial state values and numerically integrating them to
approximate their continuous time evolution on discrete computers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values. Can also be a string,
such as <code class="docutils literal notranslate"><span class="pre">&quot;lorenz&quot;</span></code> (Lorenz attractor), <code class="docutils literal notranslate"><span class="pre">&quot;rossler&quot;</span></code> (Rössler attractor), or
<code class="docutils literal notranslate"><span class="pre">&quot;clifford&quot;</span></code> (Clifford attractor) to obtain a pre-defined attractor.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the reconstructed attractor. See <a class="reference internal" href="#neurokit2.complexity.complexity_attractor" title="neurokit2.complexity.complexity_attractor"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a> for details.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <a class="reference internal" href="#neurokit2.complexity.complexity_attractor" title="neurokit2.complexity.complexity_attractor"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>array</em> – Embedded time-series, of shape <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">-</span> <span class="pre">(dimension</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">delay</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_attractor" title="neurokit2.complexity.complexity_attractor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_attractor</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Example 1</strong>: Understanding the output</p>
<p>The first columns contains the beginning of the signal, and the second column contains the
values at <em>t+2</em>.</p>
<p><strong>Example 2</strong>: 2D, 3D, and “4D” Attractors. Note that 3D attractors are slow to plot.</p>
<p>In the last 3D-attractor, the 4th dimension is represented by the color.</p>
<p><strong>Example 3</strong>: Attractor of heart rate</p>
<blockquote>
<div><p>ecg = nk.ecg_simulate(duration=60*4, sampling_rate=200)
peaks, _ = nk.ecg_peaks(ecg, sampling_rate=200)
signal = nk.ecg_rate(peaks, sampling_rate=200, desired_length=len(ecg))</p>
<p>&#64;savefig p_complexity_embedding4.png scale=100%
embedded = nk.complexity_embedding(signal, delay=250, dimension=2, show=True)
&#64;suppress
plt.close()</p>
</div></blockquote>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Gautama, T., Mandic, D. P., &amp; Van Hulle, M. M. (2003, April). A differential entropy based
method for determining the optimal embedding parameters of a signal. In 2003 IEEE
International Conference on Acoustics, Speech, and Signal Processing, 2003. Proceedings.
(ICASSP’03). (Vol. 6, pp. VI-29). IEEE.</p></li>
<li><p>Takens, F. (1981). Detecting strange attractors in turbulence. In Dynamical systems and
turbulence, Warwick 1980 (pp. 366-381). Springer, Berlin, Heidelberg.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-attractor">
<h3><em>complexity_attractor()</em><a class="headerlink" href="#complexity-attractor" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_attractor">
<span class="sig-name descname"><span class="pre">complexity_attractor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">embedded</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lorenz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'time'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'last_dim'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shadows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_attractor.html#complexity_attractor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_attractor" title="Link to this definition">#</a></dt>
<dd><p><strong>Attractor Graph</strong></p>
<p>Create an attractor graph from an <a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">embedded</span></code></a> time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>embedded</strong> (<em>Union[str, np.ndarray]</em>) – Output of <code class="docutils literal notranslate"><span class="pre">complexity_embedding()</span></code>. Can also be a string, such as <code class="docutils literal notranslate"><span class="pre">&quot;lorenz&quot;</span></code> (Lorenz
attractor) or <code class="docutils literal notranslate"><span class="pre">&quot;rossler&quot;</span></code> (Rössler attractor).</p></li>
<li><p><strong>alpha</strong> (<em>Union[str, float]</em>) – Transparency of the lines. If <code class="docutils literal notranslate"><span class="pre">&quot;time&quot;</span></code>, the lines will be transparent as a function of
time (slow).</p></li>
<li><p><strong>color</strong> (<em>str</em>) – Color of the plot. If <code class="docutils literal notranslate"><span class="pre">&quot;last_dim&quot;</span></code>, the last dimension (max 4th) of the embedded data
will be used when the dimensions are higher than 2. Useful to visualize the depth (for
3-dimensions embedding), or the fourth dimension, but it is slow.</p></li>
<li><p><strong>shadows</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, 2D projections will be added to the sides of the 3D attractor.</p></li>
<li><p><strong>linewidth</strong> (<em>float</em>) – Set the line width in points.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments are passed to the color palette (e.g., <code class="docutils literal notranslate"><span class="pre">name=&quot;plasma&quot;</span></code>), or
to the Lorenz system simulator, such as <code class="docutils literal notranslate"><span class="pre">duration</span></code> (default = 100), <code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code>
(default = 10), <code class="docutils literal notranslate"><span class="pre">sigma</span></code> (default = 10), <code class="docutils literal notranslate"><span class="pre">beta</span></code> (default = 8/3), <code class="docutils literal notranslate"><span class="pre">rho</span></code> (default = 28).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embeddding</span></code></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Lorenz attractors</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">fig</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;last_dim&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor1.png"><img alt="../_images/p_complexity_attractor1.png" src="../_images/p_complexity_attractor1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Fast result (fixed alpha and color)</span>
<span class="gp">In [3]: </span><span class="n">fig</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor2.png"><img alt="../_images/p_complexity_attractor2.png" src="../_images/p_complexity_attractor2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Rössler attractors</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="s2">&quot;rossler&quot;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="gh">Out[4]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor3.png"><img alt="../_images/p_complexity_attractor3.png" src="../_images/p_complexity_attractor3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>2D Attractors using a signal</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Simulate Signal</span>
<span class="gp">In [5]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

<span class="go"># 2D Attractor</span>
<span class="gp">In [6]: </span><span class="n">embedded</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="go"># Fast (fixed alpha and color)</span>
<span class="gp">In [7]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[7]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor4.png"><img alt="../_images/p_complexity_attractor4.png" src="../_images/p_complexity_attractor4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Slow</span>
<span class="gp">In [8]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;last_dim&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
<span class="gh">Out[8]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor5.png"><img alt="../_images/p_complexity_attractor5.png" src="../_images/p_complexity_attractor5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>3D Attractors using a signal</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># 3D Attractor</span>
<span class="gp">In [9]: </span><span class="n">embedded</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_embedding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>

<span class="go"># Fast (fixed alpha and color)</span>
<span class="gp">In [10]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor6.png"><img alt="../_images/p_complexity_attractor6.png" src="../_images/p_complexity_attractor6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Slow</span>
<span class="gp">In [11]: </span><span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;last_dim&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
<span class="gh">Out[11]: </span><span class="go">&lt;Figure size 640x480 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_attractor7.png"><img alt="../_images/p_complexity_attractor7.png" src="../_images/p_complexity_attractor7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Animated Rotation</strong></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.animation</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">animation</span>

<span class="gp">In [13]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">IPython</span>

<span class="gp">In [14]: </span><span class="n">fig</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_attractor</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">shadows</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [15]: </span><span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">get_axes</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">In [16]: </span><span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">azim</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>
<span class="gp">   ....: </span><span class="n">anim</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">361</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">   ....: </span><span class="n">IPython</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">HTML</span><span class="p">(</span><span class="n">anim</span><span class="o">.</span><span class="n">to_jshtml</span><span class="p">())</span>
<span class="gp">   ....: </span>
<span class="gh">Out[16]: </span><span class="go">&lt;IPython.core.display.HTML object&gt;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="complexity-symbolize">
<h3><em>complexity_symbolize</em><a class="headerlink" href="#complexity-symbolize" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_symbolize">
<span class="sig-name descname"><span class="pre">complexity_symbolize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_symbolize.html#complexity_symbolize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_symbolize" title="Link to this definition">#</a></dt>
<dd><p><strong>Signal Symbolization and Discretization</strong></p>
<p>Many complexity indices are made to assess the recurrence and predictability of discrete -
symbolic - states. As such, continuous signals must be transformed into such discrete sequence.</p>
<p>For instance, one of the easiest way is to split the signal values into two categories, above
and below the mean, resulting in a sequence of <em>A</em> and <em>B</em>. More complex methods have been
developped to that end.</p>
<ul class="simple">
<li><p><strong>Method ‘A’</strong> binarizes the signal by higher vs. lower values as compated to the signal’s
mean. Equivalent to <code class="docutils literal notranslate"><span class="pre">method=&quot;mean&quot;</span></code> (<code class="docutils literal notranslate"><span class="pre">method=&quot;median&quot;</span></code> is also valid).</p></li>
<li><p><strong>Method ‘B’</strong> uses values that are within the mean +/- 1 SD band vs. values that are outside
this band.</p></li>
<li><p><strong>Method ‘C’</strong> computes the difference between consecutive samples and binarizes depending on
their sign.</p></li>
<li><p><strong>Method ‘D’</strong> forms separates consecutive samples that exceed 1 signal’s SD from the others
smaller changes.</p></li>
<li><p><strong>Method ‘r’</strong> is based on the concept of <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">*tolerance*</span></code></a>, and
will separate consecutive samples that exceed a given tolerance threshold, by default
<span class="math notranslate nohighlight">\(0.2 * SD\)</span>. See <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> for more details.</p></li>
<li><p><strong>Binning</strong>: If an integer <em>n</em> is passed, will bin the signal into <em>n</em> equal-width bins.
Requires to specify <em>c</em>.</p></li>
<li><p><strong>MEP</strong>: Maximum Entropy Partitioning. Requires to specify <em>c</em>.</p></li>
<li><p><strong>NCDF</strong>: Please help us to improve the documentation here. Requires to specify <em>c</em>.</p></li>
<li><p><strong>Linear</strong>: Please help us to improve the documentation here. Requires to specify <em>c</em>.</p></li>
<li><p><strong>Uniform</strong>: Please help us to improve the documentation here. Requires to specify <em>c</em>.</p></li>
<li><p><strong>kmeans</strong>: k-means clustering. Requires to specify <em>c</em>.</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>method</strong> (<em>str or int</em>) – Method of symbolization. Can be one of <code class="docutils literal notranslate"><span class="pre">&quot;A&quot;</span></code> (default), <code class="docutils literal notranslate"><span class="pre">&quot;B&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;C&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;D&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;Binning&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;MEP&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;NCDF&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;linear&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;uniform&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;kmeans&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;equal&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">None</span></code> to skip the process (for instance, in cases when the binarization
has already been done before).</p>
<p>See <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a> for details.</p>
</li>
<li><p><strong>c</strong> (<em>int</em>) – Number of symbols <em>c</em>, used in some algorithms.</p></li>
<li><p><strong>random_state</strong> (<em>None, int, numpy.random.RandomState or numpy.random.Generator</em>) – Seed for the random number generator. See <code class="xref py py-func docutils literal notranslate"><span class="pre">misc.check_random_state()</span></code> for further information.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Plot the reconstructed attractor. See <a class="reference internal" href="#neurokit2.complexity.complexity_attractor" title="neurokit2.complexity.complexity_attractor"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a> for details.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments to be passed to <a class="reference internal" href="#neurokit2.complexity.complexity_attractor" title="neurokit2.complexity.complexity_attractor"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>array</em> – A symbolic sequence made of discrete states (e.g., 0 and 1).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_cumulative_residual</span></code>, <a class="reference internal" href="#neurokit2.complexity.fractal_petrosian" title="neurokit2.complexity.fractal_petrosian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fractal_petrosian</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="go"># Method &quot;A&quot; is equivalent to &quot;mean&quot;</span>
<span class="gp">In [3]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize1.png"><img alt="../_images/p_complexity_symbolize1.png" src="../_images/p_complexity_symbolize1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize2.png"><img alt="../_images/p_complexity_symbolize2.png" src="../_images/p_complexity_symbolize2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize3.png"><img alt="../_images/p_complexity_symbolize3.png" src="../_images/p_complexity_symbolize3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">noise</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize4.png"><img alt="../_images/p_complexity_symbolize4.png" src="../_images/p_complexity_symbolize4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize5.png"><img alt="../_images/p_complexity_symbolize5.png" src="../_images/p_complexity_symbolize5.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;binning&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize6.png"><img alt="../_images/p_complexity_symbolize6.png" src="../_images/p_complexity_symbolize6.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;MEP&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize7.png"><img alt="../_images/p_complexity_symbolize7.png" src="../_images/p_complexity_symbolize7.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;NCDF&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize8.png"><img alt="../_images/p_complexity_symbolize8.png" src="../_images/p_complexity_symbolize8.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize9.png"><img alt="../_images/p_complexity_symbolize9.png" src="../_images/p_complexity_symbolize9.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;equal&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize10.png"><img alt="../_images/p_complexity_symbolize10.png" src="../_images/p_complexity_symbolize10.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [14]: </span><span class="n">symbolic</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_symbolize</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;kmeans&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_symbolize11.png"><img alt="../_images/p_complexity_symbolize11.png" src="../_images/p_complexity_symbolize11.png" style="width: 640.0px; height: 480.0px;" />
</a>
</dd></dl>

</section>
<section id="complexity-coarsegraining">
<h3><em>complexity_coarsegraining()</em><a class="headerlink" href="#complexity-coarsegraining" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_coarsegraining">
<span class="sig-name descname"><span class="pre">complexity_coarsegraining</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nonoverlapping'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_coarsegraining.html#complexity_coarsegraining"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_coarsegraining" title="Link to this definition">#</a></dt>
<dd><p><strong>Coarse-graining of a signal</strong></p>
<p>The goal of coarse-graining is to represent the signal at a different “scale”. The
coarse-grained time series for a scale factor Tau (<span class="math notranslate nohighlight">\(\tau\)</span>) are obtained by averaging
non-overlapping windows of size Tau. In most of the complexity metrics, multiple coarse-grained
segments are constructed for a given signal, to represent the signal at different scales (hence
the “multiscale” adjective).</p>
<figure class="align-default">
<a class="reference external image-reference" href="https://doi.org/10.1016/j.physleta.2014.03.034"><img alt="Figure from Wu et al. (2013)." src="../_images/wu2013a.png" />
</a>
</figure>
<p>This coarse-graining procedure is similar to moving averaging and the decimation of the original
time series. The length of each coarse-grained time series is N/Tau. For <code class="docutils literal notranslate"><span class="pre">scale</span> <span class="pre">=</span> <span class="pre">1</span></code>, the
coarse-grained time series is simply the original time series itself.</p>
<p>The coarse graining procedure (used for instance in MSE) is considered a shortcoming that
decreases the entropy rate artificially (Nikulin, 2004). One of the core issue is that the
length of coarse-grained signals becomes smaller as the scale increases.</p>
<p>To address this issue of length, several methods have been proposed, such as <strong>adaptive
resampling</strong> (Liu et al. 2012), <strong>moving average</strong> (Wu et al. 2013), or <strong>timeshift</strong>
(Wu et al. 2013).</p>
<ul class="simple">
<li><p><strong>Non-overlapping</strong> (default): The coarse-grained time series are constructed by averaging
non-overlapping windows of given size.</p></li>
<li><p><strong>Interpolate</strong>: Interpolates (i.e., resamples) the coarse-grained time series to match the
original signal length (currently using a monotonic cubic method, but let us know if you have
any opinion on that).</p></li>
<li><p><strong>Moving average</strong>: The coarse-grained time series via a moving average.</p></li>
<li><p><strong>Time-shift</strong>: For each scale, a <em>k</em> number of coarse-grained vectors are constructed (see
<strong>Figure</strong> below). Somewhat similar to moving-average, with the difference that the time lag
creates new vectors.</p></li>
</ul>
<figure class="align-default">
<a class="reference external image-reference" href="https://doi.org/10.1016/j.physleta.2014.03.034"><img alt="Figure from Wu et al. (2013)." src="../_images/wu2013b.png" />
</a>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>scale</strong> (<em>int</em>) – The size of the windows that the signal is divided into. Also referred to as Tau
<span class="math notranslate nohighlight">\(\tau\)</span>, it represents the scale factor and corresponds to
the amount of coarsegraining.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Can be <code class="docutils literal notranslate"><span class="pre">&quot;nonoverlapping&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;rolling&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;interpolate&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;timeshift&quot;</span></code>.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, will show the coarse-grained signal.</p></li>
<li><p><strong>**kwargs</strong> – Other arguments (not used currently).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><em>array</em> – The coarse-grained signal.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p><strong>Simple examples</strong>
.. ipython:: python</p>
<blockquote>
<div><p>import neurokit2 as nk</p>
<p>signal = [0, 2, 4, 6, 8, 10]
nk.complexity_coarsegraining(signal, scale=2)</p>
<p>signal = [0, 1, 2, 0, 1]
nk.complexity_coarsegraining(signal, scale=3)</p>
<p>nk.complexity_coarsegraining(signal=range(10), method=”interpolate”)
nk.complexity_coarsegraining(signal=range(10), method=”rolling”)</p>
</div></blockquote>
<p><strong>Simulated signal</strong>
.. ipython:: python</p>
<blockquote>
<div><p>signal = nk.signal_simulate(duration=2, frequency=[5, 20])</p>
<p>&#64;savefig p_complexity_coarsegraining1.png scale=100%
coarsegrained = nk.complexity_coarsegraining(signal, scale=40, show=True)
&#64;suppress
plt.close()</p>
</div></blockquote>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">coarsegrained</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_coarsegraining</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interpolate&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_coarsegraining2.png"><img alt="../_images/p_complexity_coarsegraining2.png" src="../_images/p_complexity_coarsegraining2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [2]: </span><span class="n">coarsegrained</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_coarsegraining</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;rolling&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_coarsegraining3.png"><img alt="../_images/p_complexity_coarsegraining3.png" src="../_images/p_complexity_coarsegraining3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>

<span class="gp">In [4]: </span><span class="n">coarsegrained</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_coarsegraining</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;timeshift&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_complexity_coarsegraining4.png"><img alt="../_images/p_complexity_coarsegraining4.png" src="../_images/p_complexity_coarsegraining4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p><strong>Benchmarking</strong>
.. ipython:: python</p>
<blockquote>
<div><p>signal = nk.signal_simulate(duration=10, frequency=5)
scale = 2
x_pd = pd.Series(signal).rolling(window=scale).mean().values[scale-1::scale]
x_nk = nk.complexity_coarsegraining(signal, scale=scale)
np.allclose(x_pd - x_nk, 0)</p>
<p>%timeit x_pd = pd.Series(signal).rolling(window=scale).mean().values[scale-1::scale]
%timeit x_nk = nk.complexity_coarsegraining(signal, scale=scale)</p>
<p>signal = nk.signal_simulate(duration=30, frequency=5)
scale = 3</p>
<p>x_pd = pd.Series(signal).rolling(window=scale).mean().values[scale-1::]
x_nk = nk.complexity_coarsegraining(signal, scale=scale, rolling=True)
np.allclose(x_pd - x_nk[1:-1], 0)</p>
<p>%timeit pd.Series(signal).rolling(window=scale).mean().values[scale-1::]
%timeit nk.complexity_coarsegraining(signal, scale=scale, rolling=True)</p>
</div></blockquote>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Su, C., Liang, Z., Li, X., Li, D., Li, Y., &amp; Ursino, M. (2016). A comparison of multiscale
permutation entropy measures in on-line depth of anesthesia monitoring. PLoS One, 11(10),
e0164104.</p></li>
<li><p>Nikulin, V. V., &amp; Brismar, T. (2004). Comment on “Multiscale entropy analysis of complex
physiologic time series”” Physical review letters, 92(8), 089803.</p></li>
<li><p>Liu, Q., Wei, Q., Fan, S. Z., Lu, C. W., Lin, T. Y., Abbod, M. F., &amp; Shieh, J. S. (2012).
Adaptive computation of multiscale entropy and its application in EEG signals for monitoring
depth of anesthesia during surgery. Entropy, 14(6), 978-992.</p></li>
<li><p>Wu, S. D., Wu, C. W., Lee, K. Y., &amp; Lin, S. G. (2013). Modified multiscale entropy for
short-term time series analysis. Physica A: Statistical Mechanics and its Applications, 392
(23), 5865-5873.</p></li>
<li><p>Wu, S. D., Wu, C. W., Lin, S. G., Wang, C. C., &amp; Lee, K. Y. (2013). Time series analysis
using composite multiscale entropy. Entropy, 15(3), 1069-1084.</p></li>
</ul>
</dd></dl>

</section>
<section id="complexity-ordinalpatterns">
<h3><em>complexity_ordinalpatterns()</em><a class="headerlink" href="#complexity-ordinalpatterns" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.complexity_ordinalpatterns">
<span class="sig-name descname"><span class="pre">complexity_ordinalpatterns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'quicksort'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_complexity_ordinalpatterns.html#complexity_ordinalpatterns"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.complexity_ordinalpatterns" title="Link to this definition">#</a></dt>
<dd><p><strong>Find Ordinal Patterns for Permutation Procedures</strong></p>
<p>The seminal work by Bandt and Pompe (2002) introduced a symbolization approach to obtain a
sequence of ordinal patterns (permutations) from continuous data. It is used in
<a class="reference internal" href="#neurokit2.complexity.entropy_permutation" title="neurokit2.complexity.entropy_permutation"><code class="xref py py-func docutils literal notranslate"><span class="pre">permutation</span> <span class="pre">entropy</span></code></a> and its different variants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.array, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Can be <code class="docutils literal notranslate"><span class="pre">&quot;quicksort&quot;</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">&quot;bubblesort&quot;</span></code> (used in Bubble Entropy).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>array</em> – Ordinal patterns.</p></li>
<li><p><em>vector</em> – Frequencies of each ordinal pattern.</p></li>
<li><p><em>dict</em> – A dictionary containing additional elements.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Example given by Bandt and Pompe (2002):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">patterns</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_ordinalpatterns</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">patterns</span>
<span class="gh">Out[4]: </span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 0, 2],</span>
<span class="go">       [2, 0, 1]])</span>

<span class="gp">In [5]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Frequencies&quot;</span><span class="p">]</span>
<span class="gh">Out[5]: </span><span class="go">array([0.4, 0.2, 0.4])</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="gp">In [7]: </span><span class="n">patterns</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_ordinalpatterns</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;bubblesort&quot;</span><span class="p">)</span>

<span class="gp">In [8]: </span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;Frequencies&quot;</span><span class="p">]</span>
<span class="gh">Out[8]: </span><span class="go">array([0.36363636, 0.09090909, 0.18181818, 0.36363636])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Bandt, C., &amp; Pompe, B. (2002). Permutation entropy: a natural complexity measure for time
series. Physical review letters, 88(17), 174102.</p></li>
<li><p>Manis, G., Aktaruzzaman, M. D., &amp; Sassi, R. (2017). Bubble entropy: An entropy almost free of
parameters. IEEE Transactions on Biomedical Engineering, 64(11), 2711-2718.</p></li>
</ul>
</dd></dl>

</section>
<section id="recurrence-matrix">
<h3><em>recurrence_matrix()</em><a class="headerlink" href="#recurrence-matrix" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.recurrence_matrix">
<span class="sig-name descname"><span class="pre">recurrence_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/utils_recurrence_matrix.html#recurrence_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.recurrence_matrix" title="Link to this definition">#</a></dt>
<dd><p><strong>Recurrence Matrix</strong></p>
<p>Fast Python implementation of recurrence matrix (tested against pyRQA). Returns a tuple
with the recurrence matrix (made of 0s and 1s) and the distance matrix (the non-binarized
version of the former).</p>
<p>It is used in <a class="reference internal" href="#neurokit2.complexity.complexity_rqa" title="neurokit2.complexity.complexity_rqa"><code class="xref py py-func docutils literal notranslate"><span class="pre">Recurrence</span> <span class="pre">Quantification</span> <span class="pre">Analysis</span> <span class="pre">(RQA)</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>Union[list, np.ndarray, pd.Series]</em>) – The signal (i.e., a time series) in the form of a vector of values.</p></li>
<li><p><strong>delay</strong> (<em>int</em>) – Time delay (often denoted <em>Tau</em> <span class="math notranslate nohighlight">\(\tau\)</span>, sometimes referred to as <em>lag</em>) in samples.
See <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – Embedding Dimension (<em>m</em>, sometimes referred to as <em>d</em> or <em>order</em>). See
<a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a> to estimate the optimal value for this parameter.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – Tolerance (often denoted as <em>r</em>), distance to consider two data points as similar. If
<code class="docutils literal notranslate"><span class="pre">&quot;sd&quot;</span></code> (default), will be set to <span class="math notranslate nohighlight">\(0.2 * SD_{signal}\)</span>. See
<a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a> to estimate the optimal value for this parameter. A rule of
thumb is to set <em>r</em> so that the percentage of points classified as recurrences is about
2-5%.</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Visualise recurrence matrix.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.complexity_embedding" title="neurokit2.complexity.complexity_embedding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_embedding</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_delay" title="neurokit2.complexity.complexity_delay"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_delay</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_dimension" title="neurokit2.complexity.complexity_dimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_dimension</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_tolerance" title="neurokit2.complexity.complexity_tolerance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_tolerance</span></code></a>, <a class="reference internal" href="#neurokit2.complexity.complexity_rqa" title="neurokit2.complexity.complexity_rqa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complexity_rqa</span></code></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>np.ndarray</em> – The recurrence matrix.</p></li>
<li><p><em>np.ndarray</em> – The distance matrix.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">signal</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">signal_simulate</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="go"># Default r</span>
<span class="gp">In [3]: </span><span class="n">rc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_recurrence_matrix1.png"><img alt="../_images/p_recurrence_matrix1.png" src="../_images/p_recurrence_matrix1.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Larger radius</span>
<span class="gp">In [4]: </span><span class="n">rc</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_recurrence_matrix2.png"><img alt="../_images/p_recurrence_matrix2.png" src="../_images/p_recurrence_matrix2.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># Optimization of tolerance via recurrence matrix</span>
<span class="gp">In [5]: </span><span class="n">tol</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">complexity_tolerance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;recurrence&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_recurrence_matrix3.png"><img alt="../_images/p_recurrence_matrix3.png" src="../_images/p_recurrence_matrix3.png" style="width: 640.0px; height: 480.0px;" />
</a>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">rc</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">recurrence_matrix</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/p_recurrence_matrix4.png"><img alt="../_images/p_recurrence_matrix4.png" src="../_images/p_recurrence_matrix4.png" style="width: 640.0px; height: 480.0px;" />
</a>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Rawald, T., Sips, M., Marwan, N., &amp; Dransch, D. (2014). Fast computation of recurrences
in long time series. In Translational Recurrences (pp. 17-29). Springer, Cham.</p></li>
<li><p>Dabiré, H., Mestivier, D., Jarnet, J., Safar, M. E., &amp; Chau, N. P. (1998). Quantification of
sympathetic and parasympathetic tones by nonlinear indexes in normotensive rats. American
Journal of Physiology-Heart and Circulatory Physiology, 275(4), H1290-H1297.</p></li>
</ul>
</dd></dl>

</section>
</section>
<section id="joint-multivariate">
<h2>Joint/Multivariate<a class="headerlink" href="#joint-multivariate" title="Link to this heading">#</a></h2>
<section id="entropy-shannon-joint">
<h3><em>entropy_shannon_joint()</em><a class="headerlink" href="#entropy-shannon-joint" title="Link to this heading">#</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="neurokit2.complexity.entropy_shannon_joint">
<span class="sig-name descname"><span class="pre">entropy_shannon_joint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/neurokit2/complexity/entropy_shannon_joint.html#entropy_shannon_joint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#neurokit2.complexity.entropy_shannon_joint" title="Link to this definition">#</a></dt>
<dd><p><strong>Shannon’s Joint Entropy</strong></p>
<p>The joint entropy measures how much entropy is contained in a joint system of two random
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Union[list, np.array, pd.Series]</em>) – A <a class="reference internal" href="#neurokit2.complexity.complexity_symbolize" title="neurokit2.complexity.complexity_symbolize"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a> sequence in the form of a vector of values.</p></li>
<li><p><strong>y</strong> (<em>Union[list, np.array, pd.Series]</em>) – Another symbolic sequence with the same values.</p></li>
<li><p><strong>base</strong> (<em>float</em>) – The logarithmic base to use, defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">scipy.stats.entropy()</span></code>
uses <code class="docutils literal notranslate"><span class="pre">np.e</span></code> as default (the natural logarithm).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float</em> – The Shannon joint entropy.</p></li>
<li><p><em>dict</em> – A dictionary containing additional information regarding the parameters used
to compute Shannon entropy.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#neurokit2.complexity.entropy_shannon" title="neurokit2.complexity.entropy_shannon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entropy_shannon</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span><span class="w"> </span><span class="nn">neurokit2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nk</span>

<span class="gp">In [2]: </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]</span>

<span class="gp">In [3]: </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">]</span>

<span class="gp">In [4]: </span><span class="n">jen</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">entropy_shannon_joint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">jen</span>
<span class="gh">Out[5]: </span><span class="go">np.float64(0.118714603408425)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="data.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Data</p>
      </div>
    </a>
    <a class="right-next"
       href="markov.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Markov Chains</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main">Main</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity"><em>complexity()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity"><code class="docutils literal notranslate"><span class="pre">complexity()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters-choice">Parameters Choice</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-delay"><em>complexity_delay()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_delay"><code class="docutils literal notranslate"><span class="pre">complexity_delay()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-dimension"><em>complexity_dimension()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_dimension"><code class="docutils literal notranslate"><span class="pre">complexity_dimension()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-tolerance"><em>complexity_tolerance()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_tolerance"><code class="docutils literal notranslate"><span class="pre">complexity_tolerance()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-k"><em>complexity_k()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_k"><code class="docutils literal notranslate"><span class="pre">complexity_k()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-dimension">Fractal Dimension</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-katz"><em>fractal_katz()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_katz"><code class="docutils literal notranslate"><span class="pre">fractal_katz()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-linelength"><em>fractal_linelength()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_linelength"><code class="docutils literal notranslate"><span class="pre">fractal_linelength()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-petrosian"><em>fractal_petrosian()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_petrosian"><code class="docutils literal notranslate"><span class="pre">fractal_petrosian()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-sevcik"><em>fractal_sevcik()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_sevcik"><code class="docutils literal notranslate"><span class="pre">fractal_sevcik()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-nld"><em>fractal_nld()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_nld"><code class="docutils literal notranslate"><span class="pre">fractal_nld()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-psdslope"><em>fractal_psdslope()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_psdslope"><code class="docutils literal notranslate"><span class="pre">fractal_psdslope()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-higuchi"><em>fractal_higuchi()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_higuchi"><code class="docutils literal notranslate"><span class="pre">fractal_higuchi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-density"><em>fractal_density()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_density"><code class="docutils literal notranslate"><span class="pre">fractal_density()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-hurst"><em>fractal_hurst()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_hurst"><code class="docutils literal notranslate"><span class="pre">fractal_hurst()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-correlation"><em>fractal_correlation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_correlation"><code class="docutils literal notranslate"><span class="pre">fractal_correlation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-dfa"><em>fractal_dfa()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_dfa"><code class="docutils literal notranslate"><span class="pre">fractal_dfa()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-tmf"><em>fractal_tmf()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_tmf"><code class="docutils literal notranslate"><span class="pre">fractal_tmf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy">Entropy</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-shannon"><em>entropy_shannon()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_shannon"><code class="docutils literal notranslate"><span class="pre">entropy_shannon()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-maximum"><em>entropy_maximum()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_maximum"><code class="docutils literal notranslate"><span class="pre">entropy_maximum()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-differential"><em>entropy_differential()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_differential"><code class="docutils literal notranslate"><span class="pre">entropy_differential()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-power"><em>entropy_power()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_power"><code class="docutils literal notranslate"><span class="pre">entropy_power()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-tsallis"><em>entropy_tsallis()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_tsallis"><code class="docutils literal notranslate"><span class="pre">entropy_tsallis()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-renyi"><em>entropy_renyi()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_renyi"><code class="docutils literal notranslate"><span class="pre">entropy_renyi()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-approximate"><em>entropy_approximate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_approximate"><code class="docutils literal notranslate"><span class="pre">entropy_approximate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-sample"><em>entropy_sample()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_sample"><code class="docutils literal notranslate"><span class="pre">entropy_sample()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-quadratic"><em>entropy_quadratic()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_quadratic"><code class="docutils literal notranslate"><span class="pre">entropy_quadratic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-cumulativeresidual"><em>entropy_cumulativeresidual()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_cumulativeresidual"><code class="docutils literal notranslate"><span class="pre">entropy_cumulativeresidual()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-rate"><em>entropy_rate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_rate"><code class="docutils literal notranslate"><span class="pre">entropy_rate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-svd"><em>entropy_svd()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_svd"><code class="docutils literal notranslate"><span class="pre">entropy_svd()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-kl"><em>entropy_kl()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_kl"><code class="docutils literal notranslate"><span class="pre">entropy_kl()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-spectral"><em>entropy_spectral()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_spectral"><code class="docutils literal notranslate"><span class="pre">entropy_spectral()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-phase"><em>entropy_phase()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_phase"><code class="docutils literal notranslate"><span class="pre">entropy_phase()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-grid"><em>entropy_grid()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_grid"><code class="docutils literal notranslate"><span class="pre">entropy_grid()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-attention"><em>entropy_attention()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_attention"><code class="docutils literal notranslate"><span class="pre">entropy_attention()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-increment"><em>entropy_increment()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_increment"><code class="docutils literal notranslate"><span class="pre">entropy_increment()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-slope"><em>entropy_slope()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_slope"><code class="docutils literal notranslate"><span class="pre">entropy_slope()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-symbolicdynamic"><em>entropy_symbolicdynamic()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_symbolicdynamic"><code class="docutils literal notranslate"><span class="pre">entropy_symbolicdynamic()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-dispersion"><em>entropy_dispersion()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_dispersion"><code class="docutils literal notranslate"><span class="pre">entropy_dispersion()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-ofentropy"><em>entropy_ofentropy()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_ofentropy"><code class="docutils literal notranslate"><span class="pre">entropy_ofentropy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-permutation"><em>entropy_permutation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_permutation"><code class="docutils literal notranslate"><span class="pre">entropy_permutation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-bubble"><em>entropy_bubble()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_bubble"><code class="docutils literal notranslate"><span class="pre">entropy_bubble()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-range"><em>entropy_range()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_range"><code class="docutils literal notranslate"><span class="pre">entropy_range()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-fuzzy"><em>entropy_fuzzy()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_fuzzy"><code class="docutils literal notranslate"><span class="pre">entropy_fuzzy()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-multiscale"><em>entropy_multiscale()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_multiscale"><code class="docutils literal notranslate"><span class="pre">entropy_multiscale()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-hierarchical"><em>entropy_hierarchical()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_hierarchical"><code class="docutils literal notranslate"><span class="pre">entropy_hierarchical()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-indices">Other indices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fisher-information"><em>fisher_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fisher_information"><code class="docutils literal notranslate"><span class="pre">fisher_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fishershannon-information"><em>fishershannon_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fishershannon_information"><code class="docutils literal notranslate"><span class="pre">fishershannon_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mutual-information"><em>mutual_information()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.mutual_information"><code class="docutils literal notranslate"><span class="pre">mutual_information()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-hjorth"><em>complexity_hjorth()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_hjorth"><code class="docutils literal notranslate"><span class="pre">complexity_hjorth()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-decorrelation"><em>complexity_decorrelation()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_decorrelation"><code class="docutils literal notranslate"><span class="pre">complexity_decorrelation()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-lempelziv"><em>complexity_lempelziv()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_lempelziv"><code class="docutils literal notranslate"><span class="pre">complexity_lempelziv()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-relativeroughness"><em>complexity_relativeroughness()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_relativeroughness"><code class="docutils literal notranslate"><span class="pre">complexity_relativeroughness()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-lyapunov"><em>complexity_lyapunov()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_lyapunov"><code class="docutils literal notranslate"><span class="pre">complexity_lyapunov()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-rqa"><em>complexity_rqa()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_rqa"><code class="docutils literal notranslate"><span class="pre">complexity_rqa()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#utilities">Utilities</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fractal-mandelbrot"><em>fractal_mandelbrot()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.fractal_mandelbrot"><code class="docutils literal notranslate"><span class="pre">fractal_mandelbrot()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-simulate"><em>complexity_simulate()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_simulate"><code class="docutils literal notranslate"><span class="pre">complexity_simulate()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-embedding"><em>complexity_embedding()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_embedding"><code class="docutils literal notranslate"><span class="pre">complexity_embedding()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-attractor"><em>complexity_attractor()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_attractor"><code class="docutils literal notranslate"><span class="pre">complexity_attractor()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-symbolize"><em>complexity_symbolize</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_symbolize"><code class="docutils literal notranslate"><span class="pre">complexity_symbolize()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-coarsegraining"><em>complexity_coarsegraining()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_coarsegraining"><code class="docutils literal notranslate"><span class="pre">complexity_coarsegraining()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#complexity-ordinalpatterns"><em>complexity_ordinalpatterns()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.complexity_ordinalpatterns"><code class="docutils literal notranslate"><span class="pre">complexity_ordinalpatterns()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recurrence-matrix"><em>recurrence_matrix()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.recurrence_matrix"><code class="docutils literal notranslate"><span class="pre">recurrence_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joint-multivariate">Joint/Multivariate</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entropy-shannon-joint"><em>entropy_shannon_joint()</em></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#neurokit2.complexity.entropy_shannon_joint"><code class="docutils literal notranslate"><span class="pre">entropy_shannon_joint()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href="https://dominiquemakowski.github.io/">Dominique Makowski</a> and the <a href="https://github.com/neuropsychology/NeuroKit/blob/master/AUTHORS.rst">Team</a>. This documentation is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> license.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020–2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>