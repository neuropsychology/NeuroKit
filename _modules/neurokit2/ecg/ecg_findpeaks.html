
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neurokit2.ecg.ecg_findpeaks &#8212; NeuroKit2 0.2.13 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=0ac042cd"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/neurokit2/ecg/ecg_findpeaks';</script>
    <link rel="icon" href="../../../_static/icon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/neurokit.png" class="logo__image only-light" alt="NeuroKit2 0.2.13 documentation - Home"/>
    <script>document.write(`<img src="../../../_static/neurokit.png" class="logo__image only-dark" alt="NeuroKit2 0.2.13 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Menu</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite_us.html">Cite us</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../codebook.html">Codebook</a></li>

<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples/index.html">Examples</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/bio_eventrelated/bio_eventrelated.html">Event-related Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/bio_intervalrelated/bio_intervalrelated.html">Interval-related Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/bio_custom/bio_custom.html">Customize your Processing Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ecg_hrv/ecg_hrv.html">Heart Rate Variability (HRV)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ecg_heartbeats/ecg_heartbeats.html">Extract and Visualize Individual Heartbeats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ecg_delineate/ecg_delineate.html">Locate P, Q, S and T waves in ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ecg_edr/ecg_edr.html">ECG-Derived Respiration (EDR)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ecg_generate_12leads/ecg_generate_12leads.html">Generating Abnormal 12-leads ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/eda_peaks/eda_peaks.html">Analyze Electrodermal Activity (EDA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/rsp_rrv/rsp_rrv.html">Respiratory Rate Variability (RRV)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/eog_analyze/eog_analyze.html">Analyze Electrooculography (EOG)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/signal_simulation/signal_simulation.html">Simulate Artificial Physiological Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ppg_report/ppg_report.html">Save Preprocessing Reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/eeg_power/eeg_power.html">EEG Power in Frequency Bands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/eeg_complexity/eeg_complexity.html">EEG Complexity Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/eeg_microstates/eeg_microstates.html">EEG Microstates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/misc_fit_function/misc_fit_function.html">Fit a function to a non-linear pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/misc_epochs_create/misc_epochs_create.html">Create epochs</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../functions/index.html">Functions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/bio.html">Bio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/ecg.html">ECG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/ppg.html">PPG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/hrv.html">HRV</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/rsp.html">RSP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/eda.html">EDA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/emg.html">EMG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/eog.html">EOG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/eeg.html">EEG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/video.html">Video Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/microstates.html">Microstates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/signal.html">Signal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/events.html">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/epochs.html">Epochs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/data.html">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/complexity.html">Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/markov.html">Markov Chains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/stats.html">Stats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/misc.html">Misc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../functions/benchmark.html">Benchmarking</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../resources/index.html">Resources</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../resources/learn_python.html">Learn Python in 10 minutes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../resources/contributing.html">Contributing guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../resources/recording.html">Recording good quality signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../resources/resources.html">Additional Resources</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../studies/index.html">Studies</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference external" href="https://www.mdpi.com/1424-8220/21/12/3998">HRV Review</a></li>
<li class="toctree-l2"><a class="reference external" href="https://psyarxiv.com/mwa6x/">HRV Indices</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9307944/">HRV Tutorial</a></li>
<li class="toctree-l2"><a class="reference external" href="https://onlinelibrary.wiley.com/doi/10.1111/ejn.15800">Complexity Review</a></li>
<li class="toctree-l2"><a class="reference external" href="https://www.mdpi.com/1099-4300/24/8/1036">Complexity Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../studies/complexity_eeg.html">EEG Complexity: Parameters Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../studies/erp_gam.html">EEG Analysis with GAMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../studies/ecg_benchmark.html">ECG Benchmark</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../studies/eog_blinktemplate.html">EOG blink template</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/neuropsychology/NeuroKit">Repository</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/neuropsychology/NeuroKit" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/neuropsychology/NeuroKit/issues/new?title=Issue%20on%20page%20%2F_modules/neurokit2/ecg/ecg_findpeaks.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for neurokit2.ecg.ecg_findpeaks</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pywt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bisect</span><span class="w"> </span><span class="kn">import</span> <span class="n">insort</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..signal</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">signal_findpeaks</span><span class="p">,</span>
    <span class="n">signal_plot</span><span class="p">,</span>
    <span class="n">signal_sanitize</span><span class="p">,</span>
    <span class="n">signal_smooth</span><span class="p">,</span>
    <span class="n">signal_zerocrossings</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">NeuroKitWarning</span>


<div class="viewcode-block" id="ecg_findpeaks">
<a class="viewcode-back" href="../../../functions/ecg.html#neurokit2.ecg.ecg_findpeaks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ecg_findpeaks</span><span class="p">(</span>
    <span class="n">ecg_cleaned</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;neurokit&quot;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;**Locate R-peaks**</span>

<span class="sd">    Low-level function used by :func:`ecg_peaks` to identify R-peaks in an ECG signal using a</span>
<span class="sd">    different set of algorithms. Use the main function and see its documentation for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ecg_cleaned : Union[list, np.array, pd.Series]</span>
<span class="sd">        See :func:`ecg_peaks()`.</span>
<span class="sd">    sampling_rate : int</span>
<span class="sd">        See :func:`ecg_peaks()`.</span>
<span class="sd">    method : string</span>
<span class="sd">        See :func:`ecg_peaks()`.</span>
<span class="sd">    show : bool</span>
<span class="sd">        If ``True``, will return a plot to visualizing the thresholds used in the algorithm.</span>
<span class="sd">        Useful for debugging.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Additional keyword arguments, usually specific for each ``method``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    info : dict</span>
<span class="sd">        A dictionary containing additional information, in this case the</span>
<span class="sd">        samples at which R-peaks occur, accessible with the key ``&quot;ECG_R_Peaks&quot;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ecg_peaks, .signal_fixpeaks</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Try retrieving right column</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ecg_cleaned</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ecg_cleaned</span> <span class="o">=</span> <span class="n">ecg_cleaned</span><span class="p">[</span><span class="s2">&quot;ECG_Clean&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">NameError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ecg_cleaned</span> <span class="o">=</span> <span class="n">ecg_cleaned</span><span class="p">[</span><span class="s2">&quot;ECG_Raw&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NameError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                <span class="n">ecg_cleaned</span> <span class="o">=</span> <span class="n">ecg_cleaned</span><span class="p">[</span><span class="s2">&quot;ECG&quot;</span><span class="p">]</span>

    <span class="c1"># Sanitize input</span>
    <span class="n">ecg_cleaned</span> <span class="o">=</span> <span class="n">signal_sanitize</span><span class="p">(</span><span class="n">ecg_cleaned</span><span class="p">)</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># remove capitalised letters</span>

    <span class="c1"># Run peak detection algorithm</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_findmethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">ecg_cleaned</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error</span>

    <span class="c1"># Prepare output.</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ECG_R_Peaks&quot;</span><span class="p">:</span> <span class="n">rpeaks</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">info</span></div>



<span class="c1"># Returns the peak detector function by name</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_findmethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;nk&quot;</span><span class="p">,</span> <span class="s2">&quot;nk2&quot;</span><span class="p">,</span> <span class="s2">&quot;neurokit&quot;</span><span class="p">,</span> <span class="s2">&quot;neurokit2&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_neurokit</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pantompkins&quot;</span><span class="p">,</span> <span class="s2">&quot;pantompkins1985&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_pantompkins</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;nabian&quot;</span><span class="p">,</span> <span class="s2">&quot;nabian2018&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_nabian2018</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gamboa2008&quot;</span><span class="p">,</span> <span class="s2">&quot;gamboa&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_gamboa</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ssf&quot;</span><span class="p">,</span> <span class="s2">&quot;slopesumfunction&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_ssf</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;zong&quot;</span><span class="p">,</span> <span class="s2">&quot;zong2003&quot;</span><span class="p">,</span> <span class="s2">&quot;wqrs&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_zong</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;hamilton&quot;</span><span class="p">,</span> <span class="s2">&quot;hamilton2002&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_hamilton</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;christov&quot;</span><span class="p">,</span> <span class="s2">&quot;christov2004&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_christov</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;engzee&quot;</span><span class="p">,</span> <span class="s2">&quot;engzee2012&quot;</span><span class="p">,</span> <span class="s2">&quot;engzeemod&quot;</span><span class="p">,</span> <span class="s2">&quot;engzeemod2012&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_engzee</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;manikandan&quot;</span><span class="p">,</span> <span class="s2">&quot;manikandan2012&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_manikandan</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;elgendi&quot;</span><span class="p">,</span> <span class="s2">&quot;elgendi2010&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_elgendi</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;kalidas2017&quot;</span><span class="p">,</span> <span class="s2">&quot;swt&quot;</span><span class="p">,</span> <span class="s2">&quot;kalidas&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_kalidas</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;khamis2016&quot;</span><span class="p">,</span> <span class="s2">&quot;unsw&quot;</span><span class="p">,</span> <span class="s2">&quot;khamis&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_khamis</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;martinez2004&quot;</span><span class="p">,</span> <span class="s2">&quot;martinez&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_WT</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;rodrigues2020&quot;</span><span class="p">,</span> <span class="s2">&quot;rodrigues2021&quot;</span><span class="p">,</span> <span class="s2">&quot;rodrigues&quot;</span><span class="p">,</span> <span class="s2">&quot;asi&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_rodrigues</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;vg&quot;</span><span class="p">,</span> <span class="s2">&quot;vgraph&quot;</span><span class="p">,</span> <span class="s2">&quot;fastnvg&quot;</span><span class="p">,</span> <span class="s2">&quot;emrich&quot;</span><span class="p">,</span> <span class="s2">&quot;emrich2023&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_visibilitygraph</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;koka2022&quot;</span><span class="p">,</span> <span class="s2">&quot;koka&quot;</span><span class="p">]:</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;koka2022&#39; method has been replaced by &#39;emrich2023&#39;.&quot;</span>
            <span class="s2">&quot; Please replace method=&#39;koka2022&#39; by method=&#39;emrich2023&#39;.&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="n">NeuroKitWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_visibilitygraph</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;promac&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_ecg_findpeaks_promac</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;NeuroKit error: ecg_findpeaks(): &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; not implemented.&quot;</span>
        <span class="p">)</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Probabilistic Methods-Agreement via Convolution (ProMAC)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_promac</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">promac_methods</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;neurokit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gamboa&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ssf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;zong&quot;</span><span class="p">,</span>
        <span class="s2">&quot;engzee&quot;</span><span class="p">,</span>
        <span class="s2">&quot;elgendi&quot;</span><span class="p">,</span>
        <span class="s2">&quot;manikandan&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kalidas&quot;</span><span class="p">,</span>
        <span class="s2">&quot;martinez&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rodrigues&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
    <span class="n">gaussian_sd</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Probabilistic Methods-Agreement via Convolution (ProMAC).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : Union[list, np.array, pd.Series]</span>
<span class="sd">        The (cleaned) ECG channel, e.g. as returned by `ecg_clean()`.</span>
<span class="sd">    sampling_rate : int</span>
<span class="sd">        The sampling frequency of `ecg_signal` (in Hz, i.e., samples/second).</span>
<span class="sd">        Defaults to 1000.</span>
<span class="sd">    show : bool</span>
<span class="sd">        If True, will return a plot to visualizing the thresholds used in the algorithm.</span>
<span class="sd">        Useful for debugging.</span>
<span class="sd">    promac_methods : list of string</span>
<span class="sd">        The algorithms to be used for R-peak detection. See the list of acceptable algorithms for</span>
<span class="sd">        the &#39;ecg_peaks&#39; function.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        The tolerance for peak acceptance. This value is a percentage of the signal&#39;s maximum</span>
<span class="sd">        value. Only peaks found above this tolerance will be finally considered as actual peaks.</span>
<span class="sd">    gaussian_sd : int</span>
<span class="sd">        The standard deviation of the Gaussian distribution used to represent the peak location</span>
<span class="sd">        probability. This value should be in millisencods and is usually taken as the size of</span>
<span class="sd">        QRS complexes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="n">promac_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">promac_methods</span>
    <span class="p">]</span>  <span class="c1"># remove capitalised letters</span>
    <span class="n">error_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Stores the failed methods</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">promac_methods</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_findmethod</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_promac_addconvolve</span><span class="p">(</span>
                <span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">gaussian_sd</span><span class="o">=</span><span class="n">gaussian_sd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">error_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not valid.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">error_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> error: </span><span class="si">{</span><span class="n">error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Rescale</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">convoluted</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Remove below threshold</span>
    <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Find peaks</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">signal_findpeaks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">height_min</span><span class="o">=</span><span class="n">threshold</span><span class="p">)[</span><span class="s2">&quot;Peaks&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">signal_plot</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;ECG&quot;</span><span class="p">:</span> <span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;Convoluted&quot;</span><span class="p">:</span> <span class="n">convoluted</span><span class="p">}),</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="p">[</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span>
        <span class="p">]</span>  <span class="c1"># pylint: disable=W0106</span>

    <span class="c1"># I am not sure if mandatory print the best option</span>
    <span class="k">if</span> <span class="n">error_list</span><span class="p">:</span>  <span class="c1"># empty?</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">error_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">peaks</span>


<span class="c1"># _ecg_findpeaks_promac_addmethod + _ecg_findpeaks_promac_convolve</span>
<span class="c1"># Joining them makes parameters exposition more consistent</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_promac_addconvolve</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">gaussian_sd</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">peaks</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># SD is defined as a typical QRS size, which for adults if 100ms</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">*</span> <span class="n">gaussian_sd</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">sd</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">sd</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sd</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span>
    <span class="p">)</span>

    <span class="n">x</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># NeuroKit</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_neurokit</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">smoothwindow</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">avgwindow</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
    <span class="n">gradthreshweight</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
    <span class="n">minlenweight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
    <span class="n">mindelay</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;All tune-able parameters are specified as keyword arguments.</span>

<span class="sd">    The `signal` must be the highpass-filtered raw ECG with a lowcut of .5 Hz.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">__</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Compute the ECG&#39;s gradient as well as the gradient threshold. Run with</span>
    <span class="c1"># show=True in order to get an idea of the threshold.</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">absgrad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
    <span class="n">smooth_kernel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">smoothwindow</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">avg_kernel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">avgwindow</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">smoothgrad</span> <span class="o">=</span> <span class="n">signal_smooth</span><span class="p">(</span><span class="n">absgrad</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">smooth_kernel</span><span class="p">)</span>
    <span class="n">avggrad</span> <span class="o">=</span> <span class="n">signal_smooth</span><span class="p">(</span><span class="n">smoothgrad</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">avg_kernel</span><span class="p">)</span>
    <span class="n">gradthreshold</span> <span class="o">=</span> <span class="n">gradthreshweight</span> <span class="o">*</span> <span class="n">avggrad</span>
    <span class="n">mindelay</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="n">mindelay</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">smoothgrad</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">gradthreshold</span><span class="p">)</span>

    <span class="c1"># Identify start and end of QRS complexes.</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">smoothgrad</span> <span class="o">&gt;</span> <span class="n">gradthreshold</span>
    <span class="n">beg_qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">qrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end_qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beg_qrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># Throw out QRS-ends that precede first QRS-start.</span>
    <span class="n">end_qrs</span> <span class="o">=</span> <span class="n">end_qrs</span><span class="p">[</span><span class="n">end_qrs</span> <span class="o">&gt;</span> <span class="n">beg_qrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="c1"># Identify R-peaks within QRS (ignore QRS that are too short).</span>
    <span class="n">num_qrs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beg_qrs</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">end_qrs</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">end_qrs</span><span class="p">[:</span><span class="n">num_qrs</span><span class="p">]</span> <span class="o">-</span> <span class="n">beg_qrs</span><span class="p">[:</span><span class="n">num_qrs</span><span class="p">])</span> <span class="o">*</span> <span class="n">minlenweight</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qrs</span><span class="p">):</span>
        <span class="n">beg</span> <span class="o">=</span> <span class="n">beg_qrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end_qrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">len_qrs</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">beg</span>

        <span class="k">if</span> <span class="n">len_qrs</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Find local maxima and their prominence within QRS.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">locmax</span><span class="p">,</span> <span class="n">props</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">locmax</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Identify most prominent local maximum.</span>
            <span class="n">peak</span> <span class="o">=</span> <span class="n">beg</span> <span class="o">+</span> <span class="n">locmax</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;prominences&quot;</span><span class="p">])]</span>
            <span class="c1"># Enforce minimum delay between peaks.</span>
            <span class="k">if</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mindelay</span><span class="p">:</span>
                <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>

    <span class="n">peaks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="n">peaks</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Convert to int</span>
    <span class="k">return</span> <span class="n">peaks</span>

<span class="c1"># =============================================================================</span>
<span class="c1"># Kahmis</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_khamis</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;UNSW QRS detection algorithm, developed by Khamis et al. (2016).</span>
<span class="sd">    Designed for both clinical ECGs and poorer quality telehealth ECGs.</span>
<span class="sd">    Adapted from the original MATLAB implementation by Khamis et al. (available under a CC0 licence).</span>
<span class="sd">    This Python implementation written by Sharon Yuen Shan Ho, Zixuan Ding, David C. Wong, and Peter H. Charlton,</span>
<span class="sd">    as reported in Ho et al. (2025).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - Khamis, H., Weiss, R., Xie, Y., Chang, C. W., Lovell, N. H., &amp; Redmond, S. J. (2016).</span>
<span class="sd">      QRS detection algorithm for telehealth electrocardiogram recordings.</span>
<span class="sd">      IEEE Transactions on Biomedical Engineering, 63(7), 1377–1388.</span>
<span class="sd">      https://doi.org/10.1109/TBME.2016.2549060</span>

<span class="sd">    - Khamis, H., Weiss, R., Xie, Y., Chang, C. W., Lovell, N. H., &amp; Redmond, S. J. (2016).</span>
<span class="sd">      TELE ECG Database: 250 Telehealth ECG Records (Collected Using Dry Metal Electrodes) with Annotated QRS and Artifact</span>
<span class="sd">      Masks, and MATLAB Code for the UNSW Artifact Detection and UNSW QRS Detection Algorithms.</span>
<span class="sd">      Harvard Dataverse, https://doi.org/doi:10.7910/DVN/QTG0EP</span>

<span class="sd">    - Ho, S. et al. (2025).</span>
<span class="sd">      Accurate RR-interval extraction from single-lead, telehealth electrocardiogram signals.</span>
<span class="sd">      medRxiv 2025.03.10.25323655.</span>
<span class="sd">      https://doi.org/10.1101/2025.03.10.25323655</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Additional functions ------------------------------------------------------------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">turning_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="c1">##</span>
        <span class="c1"># turning_points</span>
        <span class="c1"># Helper function - finds the locations of peaks and troughs of x</span>
        <span class="c1"># according to the threshold</span>
        <span class="c1">#</span>
        <span class="c1"># Original version Stephen Redmond</span>
        <span class="c1"># Modified by Philip de Chazal 30/5/07</span>
        <span class="c1">#</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># tps=1 when at a peak and tps=-1 when at a through, tps=0 elsewhere</span>
        <span class="n">tps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">tpidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># index of all turning points</span>
        <span class="n">pkth</span> <span class="o">=</span> <span class="n">tps</span><span class="p">[</span><span class="n">tpidx</span><span class="p">]</span>

        <span class="c1"># start searching for turning point using threshold</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inpeak</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">possibleidx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">confirmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pkth</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tpidx</span><span class="p">):</span>

            <span class="c1"># The aim of the following code is to eliminate all the local peaks and</span>
            <span class="c1"># troughs. A local peak or trough occurs when the height difference</span>
            <span class="c1"># between a peak and trough is less than &#39;threshold&#39;s</span>

            <span class="c1"># find first pk/tr</span>
            <span class="k">if</span> <span class="n">inpeak</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">inpeak</span> <span class="o">=</span> <span class="n">pkth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">possibleidx</span> <span class="o">=</span> <span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="c1"># if looking for peak</span>
            <span class="k">if</span> <span class="n">inpeak</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ref</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># peak found when next trough is more then threshold away from</span>
                <span class="c1"># current peak</span>
                <span class="n">confirmed</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">possibleidx</span> <span class="o">*</span> <span class="n">tps</span><span class="p">[</span><span class="n">possibleidx</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># this lower point could be next trough</span>
                <span class="n">possibleidx</span> <span class="o">=</span> <span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">inpeak</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">inpeak</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">ref</span><span class="p">:</span>
                <span class="n">possibleidx</span> <span class="o">=</span> <span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="c1"># if looking for trough</span>
            <span class="k">if</span> <span class="n">inpeak</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># trough found when next peak is more then threshold away from</span>
                <span class="c1"># current trough</span>
                <span class="n">confirmed</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">possibleidx</span> <span class="o">*</span> <span class="n">tps</span><span class="p">[</span><span class="n">possibleidx</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># this higher point could be next peak</span>
                <span class="n">possibleidx</span> <span class="o">=</span> <span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">inpeak</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">inpeak</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">possibleidx</span><span class="p">]:</span>
                <span class="n">possibleidx</span> <span class="o">=</span> <span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tpidx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">confirmed</span> <span class="o">=</span> <span class="n">confirmed</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">confirmed</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">confirmed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_rr_interval</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
        <span class="n">rr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_sections</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qrs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">range_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">qrs</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">range_vals</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">rr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">qrs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_sections</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">rr_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rr_list</span><span class="p">)</span>
        <span class="n">rr_list</span> <span class="o">=</span> <span class="n">rr_list</span><span class="p">[</span><span class="n">rr_list</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">fs</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rr_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m_rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rr_list</span><span class="p">)</span>
            <span class="n">n_rr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rr_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m_rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">n_rr</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">m_rr</span><span class="p">,</span> <span class="n">rr_list</span><span class="p">,</span> <span class="n">n_rr</span><span class="p">,</span> <span class="n">n_sections</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">smashECG</span><span class="p">(</span><span class="n">ECG</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="c1"># smashECG</span>
        <span class="c1"># Helper function - splits ECG into clean sections according to the mask</span>
        <span class="c1"># mask is the sample locations of null signal</span>

        <span class="n">expandedMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ECG</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Length of ECG + 2</span>
        <span class="n">expandedMask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">expandedMask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">expandedMask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">startend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">expandedMask</span><span class="p">)</span>
        <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">startend</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">startend</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">smashedECG</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">starts</span><span class="p">)):</span>
            <span class="n">smashedECG</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ECG</span><span class="p">[</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">ends</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">smashedECG</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">smashedFFT</span><span class="p">(</span><span class="n">smashedECG</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="c1"># removed plotting functionality from MATLAB implementation</span>
        <span class="n">Pxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smashedECG</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">smashedECG</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Flatten to 1D array</span>
            <span class="c1"># Number of 2s windows (P) in data rounded up</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">*</span> <span class="n">P</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">))</span>

            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Center the data</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">y</span>

            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">M</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># Normalize by area</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">+</span> <span class="n">A</span>

            <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">/</span> <span class="n">P</span>
            <span class="n">Pxx</span> <span class="o">=</span> <span class="n">Pxx</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">)</span>

        <span class="n">F</span> <span class="o">=</span> <span class="n">Pxx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">F</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sortfilt1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">N1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">N2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">N2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">N1</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">N2</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">((</span><span class="n">p</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">A</span><span class="p">))</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">B</span><span class="p">])</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">P</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">myfiltfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y</span>


    <span class="c1"># Bandpass filtering</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cleansignal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">do_original_filtering</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1"># cleansignal</span>
        <span class="c1"># Helper function:</span>
        <span class="c1"># baseline removal then high pass (0.7 Hz) filtering</span>
        <span class="c1"># followed by low pass (20 Hz) filtering</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># reshape so that it is the same dimension as baseline</span>

        <span class="c1"># Remove baseline</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">meddata</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">baseline</span>

        <span class="c1"># here, we removed the hard-coded FIR filter coefficients (and LP filter order 7), and instead calculate filter</span>
        <span class="c1"># coefficients. In the original implementation hard-coded FIR filter coefficients (with LP filter order 7) were used</span>
        <span class="c1"># for sampling frequencies between 400 and 600 Hz, whereas they were calculated for sampling frequencies outside this</span>
        <span class="c1"># range (with LP filter order 8).</span>

        <span class="c1"># hpf - used to eliminate dc component or low frequency drift.</span>
        <span class="k">if</span> <span class="n">do_original_filtering</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.7</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
            <span class="n">hpdata</span> <span class="o">=</span> <span class="n">myfiltfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">meddata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sos</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.7</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">)</span>
            <span class="n">hpdata</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">meddata</span><span class="p">)</span>

        <span class="c1"># low pass linear phase filter</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">20</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">)</span>
        <span class="n">lphpdata</span> <span class="o">=</span> <span class="n">myfiltfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">hpdata</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lphpdata</span>

    <span class="k">if</span> <span class="n">sampling_rate</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;This function requires a sampling rate of at least 50 Hz&#39;</span><span class="p">)</span>

    <span class="n">finalmask</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># The original MATLAB implementation allowed a mask to optionally be inputted.</span>

    <span class="c1"># Clean up Signal - hi pass, then low pass filter</span>
    <span class="n">lphpdata</span> <span class="o">=</span> <span class="n">cleansignal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># Differentiator (to emphasise QRS)</span>
    <span class="n">NumDiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">diffdata</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">NumDiff</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lphpdata</span><span class="p">)</span>

    <span class="c1"># Sort filter</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">lphpdata</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">bot</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">lphpdata</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">envelope</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bot</span><span class="p">)</span>
    <span class="n">envelope</span><span class="p">[</span><span class="n">envelope</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">feature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diffdata</span> <span class="o">*</span> <span class="n">envelope</span><span class="p">)</span>

    <span class="n">fc</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">((</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.0037</span><span class="p">)</span> <span class="o">/</span> <span class="n">fc</span>
    <span class="n">Nh</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>  <span class="c1"># Heuristic for Hamming window 3dB point</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">Nh</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Approx fc Hz low pass</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">diffpower1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">feature</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">smashedSig</span> <span class="o">=</span> <span class="n">smashECG</span><span class="p">(</span><span class="n">diffpower1</span><span class="p">,</span> <span class="n">finalmask</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">smashedFFT</span><span class="p">(</span><span class="n">smashedSig</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">14</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">13</span><span class="p">)</span> <span class="o">*</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">14</span>
    <span class="n">range_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">f</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">range_indices</span><span class="p">])</span>
    <span class="n">fftHRfreq</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">range_indices</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]]</span>

    <span class="c1"># Update smoother feature signal</span>
    <span class="n">HRmin</span> <span class="o">=</span> <span class="mf">1.5</span>  <span class="c1"># Hz: 90 BPM  (don&#39;t want to go much below this, will miss ectopics otherwise!)</span>
    <span class="n">HRmax</span> <span class="o">=</span> <span class="mf">4.0</span>  <span class="c1"># Hz: 240 BPM  (Shouldn&#39;t see much above this)</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">HRmin</span><span class="p">,</span> <span class="n">fftHRfreq</span><span class="p">,</span> <span class="n">HRmax</span><span class="p">]))</span>  <span class="c1"># Kills half of second harmonic and all of the rest</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">((</span><span class="n">sampling_rate</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.0037</span><span class="p">)</span> <span class="o">/</span> <span class="n">fc</span>
    <span class="n">Nh</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>  <span class="c1"># Heuristic for Hamming window 3dB point</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">Nh</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Approx fc Hz low pass</span>
    <span class="n">diffpower2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">feature</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># Detect QRS points</span>

    <span class="c1"># Where isn&#39;t masked</span>
    <span class="c1"># Find valid indices</span>
    <span class="n">valididx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">)),</span> <span class="n">finalmask</span><span class="p">)</span>
    <span class="c1"># Maximum filter to get upper envelope</span>
    <span class="n">Wsort</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">fftHRfreq</span><span class="p">,</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">HRmax</span><span class="p">])))</span>
    <span class="n">upperenv</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">,</span> <span class="n">Wsort</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Morph Open</span>
    <span class="n">upperenv</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">upperenv</span><span class="p">,</span> <span class="n">Wsort</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Morph Close</span>
    <span class="n">lowerenv</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">,</span> <span class="n">Wsort</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Morph Open</span>
    <span class="n">lowerenv</span> <span class="o">=</span> <span class="n">sortfilt1</span><span class="p">(</span><span class="n">lowerenv</span><span class="p">,</span> <span class="n">Wsort</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Morph Close</span>
    <span class="n">QRSenv</span> <span class="o">=</span> <span class="n">upperenv</span> <span class="o">-</span> <span class="n">lowerenv</span>

    <span class="c1"># First pass: high threshold</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">featureHeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">QRSenv</span><span class="p">[</span><span class="n">valididx</span><span class="p">])</span>
    <span class="n">mainThreshold</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">featureHeight</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">mainThreshold</span> <span class="o">/</span> <span class="n">sensitivity</span>

    <span class="n">tpsidx</span> <span class="o">=</span> <span class="n">turning_points</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">tpsidx</span><span class="p">[</span><span class="n">tpsidx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">finalmask</span><span class="p">)</span>
    <span class="n">m_rr</span><span class="p">,</span> <span class="n">rr_list</span><span class="p">,</span> <span class="n">n_rr</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">calculate_rr_interval</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">finalmask</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># Stop if no qrs waves were detected (not in original matlab algorithm):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qrs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Convert to int</span>
        <span class="k">return</span> <span class="n">peaks</span>

    <span class="c1"># Back-track to find possible missed beats</span>
    <span class="c1"># Lower threshold</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">mainThreshold</span> <span class="o">/</span> <span class="n">sensitivity</span>
    <span class="n">tpsidx</span> <span class="o">=</span> <span class="n">turning_points</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">qrs2</span> <span class="o">=</span> <span class="n">tpsidx</span><span class="p">[</span><span class="n">tpsidx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Fill in gaps</span>
    <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">finalmask</span><span class="p">,</span> <span class="n">qrs</span><span class="p">)</span>
    <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newmask</span><span class="p">])</span>  <span class="c1"># convert to integer array</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">newmask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">1</span><span class="p">],</span> <span class="n">temp</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1"># Fill in sections less than 1.5*mRR seconds;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">m_rr</span><span class="p">:</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">start</span><span class="p">:(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Only keep newly found QRS between long beats</span>
    <span class="n">qrs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">qrs2</span><span class="p">,</span> <span class="n">newmask</span><span class="p">)</span>
    <span class="c1"># Add them to the old QRS (found using low sensitivity)</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">qrs2</span><span class="p">)</span>
    <span class="n">m_rr</span><span class="p">,</span> <span class="n">rr_list</span><span class="p">,</span> <span class="n">n_rr</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">calculate_rr_interval</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">finalmask</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># 3rd pass: Highest threshold</span>
    <span class="c1"># Back-track to remove possible wrong beats</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">mainThreshold</span> <span class="o">/</span> <span class="n">sensitivity</span>
    <span class="n">tpsidx</span> <span class="o">=</span> <span class="n">turning_points</span><span class="p">(</span><span class="n">diffpower2</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">qrs3</span> <span class="o">=</span> <span class="n">tpsidx</span><span class="p">[</span><span class="n">tpsidx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">qrs3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">qrs3</span><span class="p">,</span> <span class="n">finalmask</span><span class="p">)</span>

    <span class="c1"># find indices of RR intervals that are too short</span>
    <span class="n">short_rr_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qrs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">qrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">qrs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">m_rr</span><span class="p">:</span>
            <span class="n">short_rr_idx</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">qrs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">qrs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="n">qrs3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">qrs3</span><span class="p">,</span> <span class="n">short_rr_idx</span><span class="p">)</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">short_rr_idx</span><span class="p">)</span>
    <span class="n">qrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">qrs</span><span class="p">,</span> <span class="n">qrs3</span><span class="p">)</span>
    <span class="c1"># removed final call to &#39;calculate_rr_interval&#39; from MATLAB implementation as its outputs are not used</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Convert to int</span>
    <span class="k">return</span> <span class="n">peaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Pan &amp; Tompkins (1985)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_pantompkins</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Pan, J., &amp; Tompkins, W. J. (1985). A real-time QRS detection algorithm. IEEE transactions</span>
<span class="sd">      on biomedical engineering, (3), 230-236.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

    <span class="n">squared</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.12</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">mwa</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_MWA</span><span class="p">(</span><span class="n">squared</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">mwa</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">mwa_peaks</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_peakdetect</span><span class="p">(</span><span class="n">mwa</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">mwa_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mwa_peaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mwa_peaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Hamilton (2002)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_hamilton</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Hamilton, Open Source ECG Analysis Software Documentation, E.P.Limited, 2002.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.08</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.08</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">ma</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

    <span class="n">ma</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">n_pks</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">n_pks_ave</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">s_pks</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">s_pks_ave</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">QRS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">RR</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([],</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">RR_ave</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">th</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ma</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># pylint: disable=C0200,R1702</span>
        <span class="k">if</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>  <span class="c1"># pylint: disable=R1716</span>
            <span class="n">peak</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ma</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">th</span> <span class="ow">and</span> <span class="p">(</span><span class="n">peak</span> <span class="o">-</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">:</span>
                <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                <span class="n">s_pks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ma</span><span class="p">[</span><span class="n">peak</span><span class="p">])</span>
                <span class="n">s_pks_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s_pks</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">RR_ave</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">RR_ave</span><span class="p">:</span>
                    <span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">missed_peak_added</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">missed_peak</span> <span class="ow">in</span> <span class="n">missed_peaks</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">missed_peak</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.36</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">ma</span><span class="p">[</span><span class="n">missed_peak</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">th</span>
                        <span class="p">):</span>
                            <span class="n">insort</span><span class="p">(</span><span class="n">QRS</span><span class="p">,</span> <span class="n">missed_peak</span><span class="p">)</span>
                            <span class="n">missed_peak_added</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">missed_peak_added</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">QRS</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">RR</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">RR_ave</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">RR</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_pks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ma</span><span class="p">[</span><span class="n">peak</span><span class="p">])</span>
                <span class="n">n_pks_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n_pks</span><span class="p">)</span>

            <span class="n">th</span> <span class="o">=</span> <span class="n">n_pks_ave</span> <span class="o">+</span> <span class="mf">0.45</span> <span class="o">*</span> <span class="p">(</span><span class="n">s_pks_ave</span> <span class="o">-</span> <span class="n">n_pks_ave</span><span class="p">)</span>

    <span class="n">QRS</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">QRS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">QRS</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">QRS</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Slope Sum Function (SSF) - Zong et al. (2003)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_ssf</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/PIA-</span>
<span class="sd">    Group/BioSPPy/blob/e65da30f6379852ecb98f8e2e0c9b4b5175416c3/biosppy/signals/ecg.py#L448.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Doesn&#39;t really seems to work</span>

    <span class="c1"># convert to samples</span>
    <span class="n">winB</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">before</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">winA</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">after</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">Rset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

    <span class="c1"># diff</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">dx</span><span class="p">[</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># detection</span>
    <span class="p">(</span><span class="n">idx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">))</span>
    <span class="n">didx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx0</span><span class="p">)</span>

    <span class="c1"># search</span>
    <span class="n">sidx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">didx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sidx</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">item</span> <span class="o">-</span> <span class="n">winB</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">item</span> <span class="o">+</span> <span class="n">winA</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">])</span> <span class="o">+</span> <span class="n">a</span>
        <span class="n">Rset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># output</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span>
    <span class="n">rpeaks</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Zong (2003) - WQRS</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_zong</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mf">0.13</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Zong, W., Moody, G. B., &amp; Jiang, D. (2003, September). A robust open-source algorithm to</span>
<span class="sd">      detect onset and duration of QRS complexes. In Computers in Cardiology, 2003 (pp. 737-740).</span>
<span class="sd">      IEEE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 1. Filter signal</span>
    <span class="c1"># TODO: Should remove this step? It&#39;s technically part of cleaning,</span>
    <span class="c1"># Not sure it is integral to the peak-detection per se. Opinions are welcome.</span>
    <span class="n">order</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1"># Cutoff normalized by nyquist frequency</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

    <span class="c1"># Curve length transformation</span>
    <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">window</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">w</span> <span class="p">:</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Pad with the first value</span>
    <span class="n">clt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">tmp</span><span class="p">])</span>

    <span class="c1"># Find adaptive threshold</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sampling_rate</span>

    <span class="c1"># Apply fast moving window average with 1D convolution</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">clt</span><span class="p">,</span> <span class="p">(</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_size</span><span class="p">),</span> <span class="s2">&quot;valid&quot;</span><span class="p">)</span>

    <span class="c1"># Check that ret is at least as large as the window</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">window_size</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The signal must be at least </span><span class="si">{</span><span class="n">window_size</span><span class="si">}</span><span class="s2"> samples long for peak detection with the Zong method. &quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="n">NeuroKitWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span><span class="p">):</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">i</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">window_size</span>

    <span class="c1"># Find peaks</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clt</span><span class="p">)):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">*</span> <span class="mf">0.35</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="ow">and</span> <span class="n">clt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Christov (2004)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_christov</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Ivaylo I. Christov, Real time electrocardiogram QRS detection using combined adaptive</span>
<span class="sd">      threshold, BioMedical Engineering OnLine 2004, vol. 3:28, 2004.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_taps</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">total_taps</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">MA1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.028</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.028</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">total_taps</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">MA2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">MA1</span><span class="p">)</span>

    <span class="n">Y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">MA2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">MA2</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">MA2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.040</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.040</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">total_taps</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">MA3</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">MA3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">total_taps</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">ms50</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.05</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ms200</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ms1200</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ms350</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.35</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">newM5</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">M_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">MM</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_slope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">ms1200</span> <span class="o">-</span> <span class="n">ms200</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">F_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">RR</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Rm</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">R_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">MFR</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">MFR_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">QRS</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MA3</span><span class="p">)):</span>  <span class="c1"># pylint: disable=C0200</span>
        <span class="c1"># M</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">MA3</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">MM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">MM</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">:</span>
            <span class="n">newM5</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">MA3</span><span class="p">[</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">newM5</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">MM</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newM5</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">MM</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">newM5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newM5</span> <span class="o">=</span> <span class="n">MM</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">MM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newM5</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">MM</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms1200</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">*</span> <span class="n">M_slope</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms1200</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span>

        <span class="c1"># F</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">ms350</span><span class="p">:</span>
            <span class="n">F_section</span> <span class="o">=</span> <span class="n">MA3</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">ms350</span> <span class="p">:</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">max_latest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">F_section</span><span class="p">[</span><span class="o">-</span><span class="n">ms50</span><span class="p">:])</span>
            <span class="n">max_earliest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">F_section</span><span class="p">[:</span><span class="n">ms50</span><span class="p">])</span>
            <span class="n">F</span> <span class="o">+=</span> <span class="p">(</span><span class="n">max_latest</span> <span class="o">-</span> <span class="n">max_earliest</span><span class="p">)</span> <span class="o">/</span> <span class="mf">150.0</span>

        <span class="c1"># R</span>
        <span class="k">if</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">Rm</span><span class="p">)):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">Rm</span><span class="p">))</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Rm</span><span class="p">:</span>
            <span class="n">dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">))</span> <span class="o">/</span> <span class="mf">1.4</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">dec</span>

        <span class="n">MFR</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">F</span> <span class="o">+</span> <span class="n">R</span>
        <span class="n">M_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">F_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
        <span class="n">R_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">MFR_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MFR</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">MA3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MFR</span><span class="p">:</span>
            <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span> <span class="ow">and</span> <span class="n">MA3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">MFR</span><span class="p">:</span>
            <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">QRS</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">RR</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="n">RR</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Rm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">RR</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">QRS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">QRS</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">QRS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">QRS</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">QRS</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Continuous Wavelet Transform (CWT) - Martinez et al. (2004)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_WT</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># first derivative of the Gaissian signal</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
    <span class="n">cwtmatr</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">pywt</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="s2">&quot;gaus1&quot;</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># For wt of scale 2^4</span>
    <span class="n">signal_4</span> <span class="o">=</span> <span class="n">cwtmatr</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">epsilon_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">signal_4</span><span class="p">)))</span>
    <span class="n">peaks_4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal_4</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">epsilon_4</span><span class="p">)</span>

    <span class="c1"># For wt of scale 2^3</span>
    <span class="n">signal_3</span> <span class="o">=</span> <span class="n">cwtmatr</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">epsilon_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">signal_3</span><span class="p">)))</span>
    <span class="n">peaks_3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal_3</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">epsilon_3</span><span class="p">)</span>
    <span class="c1"># Keep only peaks_3 that are nearest to peaks_4</span>
    <span class="n">peaks_3_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)):</span>  <span class="c1"># pylint: disable=C0200</span>
        <span class="n">peaks_distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks_3</span><span class="p">)</span>
        <span class="n">peaks_3_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">peaks_3</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">peaks_distance</span><span class="p">)]</span>

    <span class="c1"># For wt of scale 2^2</span>
    <span class="n">signal_2</span> <span class="o">=</span> <span class="n">cwtmatr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">epsilon_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">signal_2</span><span class="p">)))</span>
    <span class="n">peaks_2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal_2</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">epsilon_2</span><span class="p">)</span>
    <span class="c1"># Keep only peaks_2 that are nearest to peaks_3</span>
    <span class="n">peaks_2_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)):</span>
        <span class="n">peaks_distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peaks_3_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks_2</span><span class="p">)</span>
        <span class="n">peaks_2_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">peaks_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">peaks_distance</span><span class="p">)]</span>

    <span class="c1"># For wt of scale 2^1</span>
    <span class="n">signal_1</span> <span class="o">=</span> <span class="n">cwtmatr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">epsilon_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">signal_1</span><span class="p">)))</span>
    <span class="n">peaks_1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal_1</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">epsilon_1</span><span class="p">)</span>
    <span class="c1"># Keep only peaks_1 that are nearest to peaks_2</span>
    <span class="n">peaks_1_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peaks_4</span><span class="p">)):</span>
        <span class="n">peaks_distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peaks_2_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks_1</span><span class="p">)</span>
        <span class="n">peaks_1_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">peaks_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">peaks_distance</span><span class="p">)]</span>

    <span class="c1"># Find R peaks</span>
    <span class="n">max_R_peak_dist</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index_cur</span><span class="p">,</span> <span class="n">index_next</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">peaks_1_keep</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">peaks_1_keep</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">correct_sign</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">signal_1</span><span class="p">[</span><span class="n">index_cur</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">signal_1</span><span class="p">[</span><span class="n">index_next</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># pylint: disable=R1716</span>
        <span class="n">near</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_next</span> <span class="o">-</span> <span class="n">index_cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_R_peak_dist</span>  <span class="c1"># limit 2</span>
        <span class="k">if</span> <span class="n">near</span> <span class="ow">and</span> <span class="n">correct_sign</span><span class="p">:</span>
            <span class="n">rpeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">signal_zerocrossings</span><span class="p">(</span><span class="n">signal_1</span><span class="p">[</span><span class="n">index_cur</span> <span class="p">:</span> <span class="n">index_next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">index_cur</span>
            <span class="p">)</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Gamboa (2008)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_gamboa</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/PIA-</span>
<span class="sd">    Group/BioSPPy/blob/e65da30f6379852ecb98f8e2e0c9b4b5175416c3/biosppy/signals/ecg.py#L834.</span>

<span class="sd">    - Gamboa, H. (2008). Multi-modal behavioral biometrics based on HCI and electrophysiology</span>
<span class="sd">      (Doctoral dissertation, Universidade Técnica de Lisboa).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">TH</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>

    <span class="n">v0</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">F</span> <span class="o">&gt;</span> <span class="n">TH</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">F</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">TH</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">nrm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">v0</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)])</span>
    <span class="n">norm_signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nrm</span><span class="p">)</span>

    <span class="n">d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">norm_signal</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="n">d2</span><span class="p">))))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="p">)</span>  <span class="c1"># pylint: disable=E1130</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">-</span><span class="n">d2</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># pylint: disable=E1130</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># convert to samples</span>
        <span class="n">v_100ms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">v_300ms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">previous</span> <span class="o">&gt;</span> <span class="n">v_300ms</span><span class="p">:</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">rpeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">v_100ms</span><span class="p">)])</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">)))</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Elgendi et al. (2010)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_elgendi</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Elgendi, Mohamed &amp; Jonkman, Mirjam &amp; De Boer, Friso. (2010). Frequency Bands Effects on QRS</span>
<span class="sd">      Detection. The 3rd International Conference on Bio-inspired Systems and Signal Processing</span>
<span class="sd">      (BIOSIGNALS2010). 428-431.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">window1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.12</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">mwa_qrs</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_MWA</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">window1</span><span class="p">)</span>

    <span class="n">window2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.6</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">mwa_beat</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_MWA</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">window2</span><span class="p">)</span>

    <span class="n">blocks</span> <span class="o">=</span> <span class="n">mwa_qrs</span> <span class="o">&gt;</span> <span class="n">mwa_beat</span>

    <span class="n">QRS</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">qrs_duration_threshold</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.08</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">rr_distance_threshold</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="k">if</span> <span class="n">prev</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">elif</span> <span class="n">prev</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">qrs_duration_threshold</span><span class="p">:</span>
                <span class="n">detection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">start</span>
                <span class="k">if</span> <span class="n">QRS</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">detection</span> <span class="o">-</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rr_distance_threshold</span><span class="p">:</span>
                        <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">detection</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">detection</span><span class="p">)</span>

    <span class="n">QRS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">QRS</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">QRS</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Engzee Modified (2012)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_engzee</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - C. Zeelenberg, A single scan algorithm for QRS detection and feature extraction, IEEE Comp.</span>
<span class="sd">      in Cardiology, vol. 6, pp. 37-42, 1979</span>
<span class="sd">    - A. Lourenco, H. Silva, P. Leite, R. Lourenco and A. Fred, &quot;Real Time Electrocardiogram</span>
<span class="sd">      Segmentation for Finger Based ECG Biometrics&quot;, BIOSIGNALS 2012, pp. 49-54, 2012.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">engzee_fake_delay</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)):</span>
        <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span>

    <span class="n">ci</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">low_pass</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

    <span class="n">low_pass</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">ms200</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ms1200</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ms160</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.16</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">neg_threshold</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">M_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neg_m</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">MM</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_slope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">ms1200</span> <span class="o">-</span> <span class="n">ms200</span><span class="p">)</span>

    <span class="n">QRS</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">thi_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">thi</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">thf_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">thf</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">newM5</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">low_pass</span><span class="p">)):</span>  <span class="c1"># pylint: disable=C0200</span>
        <span class="c1"># M</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">low_pass</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">MM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">MM</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">:</span>
            <span class="n">newM5</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">low_pass</span><span class="p">[</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">newM5</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">MM</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">newM5</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">MM</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">newM5</span> <span class="ow">and</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">:</span>
            <span class="n">MM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newM5</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">MM</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms1200</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span> <span class="o">*</span> <span class="n">M_slope</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms1200</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MM</span><span class="p">)</span>

        <span class="n">M_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">neg_m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">thi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">thi</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">QRS</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">QRS</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms200</span> <span class="ow">and</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">QRS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">thi_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">thi</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">thi</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">thi_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms160</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">M</span> <span class="ow">and</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">M</span><span class="p">:</span>
                <span class="c1"># thf_list.append(i)</span>
                <span class="n">thf</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">thf</span> <span class="ow">and</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">M</span><span class="p">:</span>
                <span class="n">thf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="n">low_pass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">M</span> <span class="ow">and</span> <span class="n">thf</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">thi</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">thf</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">elif</span> <span class="n">thi</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">thi_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ms160</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">thi</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">thf</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="n">neg_threshold</span><span class="p">:</span>
            <span class="n">unfiltered_section</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">thi_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span> <span class="p">:</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">r_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">engzee_fake_delay</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">unfiltered_section</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">thi_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">thi</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">thf</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">r_peaks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
        <span class="mi">0</span>
    <span class="p">)</span>  <span class="c1"># removing the 1st detection as it 1st needs the QRS complex amplitude for the threshold</span>
    <span class="n">r_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r_peaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r_peaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Shannon energy R-peak detection - Manikandan and Soman (2012)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_manikandan</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/hongzuL/A-novel-method-for-detecting-R-peaks-in-electrocardiogram-signal/</span>

<span class="sd">    A (hopefully) fixed version of https://github.com/nsunami/Shannon-Energy-R-Peak-Detection</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Preprocessing ------------------------------------------------------------</span>
    <span class="c1"># Forward and backward filtering using filtfilt.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cheby1_bandpass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nyq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">fs</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">lowcut</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">highcut</span> <span class="o">/</span> <span class="n">nyq</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">cheby1</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">rp</span><span class="o">=</span><span class="n">rp</span><span class="p">,</span> <span class="n">Wn</span><span class="o">=</span><span class="p">[</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="c1"># Running mean filter function</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">running_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">cumsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cumsum</span><span class="p">[</span><span class="n">N</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cumsum</span><span class="p">[:</span><span class="o">-</span><span class="n">N</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Apply Chebyshev Type I Bandpass filter</span>
    <span class="c1"># Low cut frequency = 6 Hz</span>
    <span class="c1"># High cut frequency = 18</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">cheby1_bandpass_filter</span><span class="p">(</span>
        <span class="n">signal</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span>
    <span class="p">)</span>

    <span class="c1"># Eq. 1: First-order differencing difference</span>
    <span class="n">dn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">filtered</span>

    <span class="c1"># If the signal is flat then return an empty array rather than error out</span>
    <span class="c1"># with a divide by zero error.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dn</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># Eq. 2</span>
    <span class="n">dtn</span> <span class="o">=</span> <span class="n">dn</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dn</span><span class="p">)))</span>

    <span class="c1"># The absolute value, energy value, Shannon entropy value, and Shannon energy value</span>
    <span class="c1"># # Eq. 3</span>
    <span class="c1"># an = np.abs(dtn)</span>
    <span class="c1"># # Eq. 4</span>
    <span class="c1"># en = an**2</span>
    <span class="c1"># # Eq. 5</span>
    <span class="c1"># sen = -np.abs(dtn) * np.log10(np.abs(dtn))</span>
    <span class="c1"># Eq. 6</span>
    <span class="n">sn</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dtn</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dtn</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Apply rectangular window</span>
    <span class="c1"># Length should be approximately the same as the duration of possible wider QRS complex</span>
    <span class="c1"># Normal QRS duration is .12 sec, so we overshoot with 0.15 sec</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">window_len</span>  <span class="c1"># Make odd</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">boxcar</span><span class="p">(</span><span class="n">window_len</span><span class="p">)</span>

    <span class="c1"># The filtering operation is performed in both the forward and reverse directions</span>
    <span class="n">see</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span>
    <span class="n">see</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">see</span><span class="p">)</span>
    <span class="n">see</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">see</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>
    <span class="n">see</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">see</span><span class="p">)</span>

    <span class="c1"># Hilbert Transformation</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">see</span><span class="p">))</span>

    <span class="c1"># Moving Average to remove low frequency drift</span>
    <span class="c1"># 2.5 sec from Manikanda in 360 Hz (900 samples)</span>
    <span class="c1"># 2.5 sec in 500 Hz == 1250 samples</span>
    <span class="n">ma_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">ma_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">running_mean</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">ma_len</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ma_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Get the difference between the Hilbert signal and the MA filtered signal</span>
    <span class="n">zn</span> <span class="o">=</span> <span class="n">ht</span> <span class="o">-</span> <span class="n">ma_out</span>

    <span class="c1"># R-Peak Detection ---------------------------------------------------------</span>
    <span class="c1"># Look for points crossing zero</span>

    <span class="c1"># Find points crossing zero upwards (negative to positive)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">zn</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># Prepare a container for windows</span>
    <span class="n">idx_search</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">id_maxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">search_window_half</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">window_len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
        <span class="n">lows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">search_window_half</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">highs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">search_window_half</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">highs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
            <span class="n">highs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">highs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">highs</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">highs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">ekg_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lows</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">highs</span><span class="p">))</span>
        <span class="n">idx_search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ekg_window</span><span class="p">)</span>
        <span class="n">ekg_window_wave</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">ekg_window</span><span class="p">]</span>
        <span class="n">id_maxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">id_maxes</span><span class="p">,</span>
            <span class="n">ekg_window</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ekg_window_wave</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ekg_window_wave</span><span class="p">))[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Stationary Wavelet Transform  (SWT) - Kalidas and Tamil (2017)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_kalidas</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    - Vignesh Kalidas and Lakshman Tamil (2017). Real-time QRS detector using Stationary Wavelet Transform</span>
<span class="sd">      for Automated ECG Analysis. In: 2017 IEEE 17th International Conference on Bioinformatics and</span>
<span class="sd">      Bioengineering (BIBE). Uses the Pan and Tompkins thresolding.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signal_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

    <span class="n">swt_level</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="n">swt_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding</span><span class="p">),</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">padding</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Padding greater than 1000 required</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">swt_ecg</span> <span class="o">=</span> <span class="n">pywt</span><span class="o">.</span><span class="n">swt</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;db3&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">swt_level</span><span class="p">)</span>
    <span class="n">swt_ecg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">swt_ecg</span><span class="p">)</span>
    <span class="n">swt_ecg</span> <span class="o">=</span> <span class="n">swt_ecg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">squared</span> <span class="o">=</span> <span class="n">swt_ecg</span> <span class="o">*</span> <span class="n">swt_ecg</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">sos</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;sos&quot;</span><span class="p">)</span>
    <span class="n">filtered_squared</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">squared</span><span class="p">)</span>

    <span class="c1"># Drop padding to avoid detecting peaks inside it (#456)</span>
    <span class="n">filtered_squared</span> <span class="o">=</span> <span class="n">filtered_squared</span><span class="p">[:</span><span class="n">signal_length</span><span class="p">]</span>

    <span class="n">filt_peaks</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_peakdetect</span><span class="p">(</span><span class="n">filtered_squared</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">filt_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filt_peaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filt_peaks</span>


<span class="c1"># ===========================================================================</span>
<span class="c1"># Nabian et al. (2018)</span>
<span class="c1"># ===========================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_nabian2018</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;R peak detection method by Nabian et al. (2018) inspired by the Pan-Tompkins algorithm.</span>

<span class="sd">    - Nabian, M., Yin, Y., Wormwood, J., Quigley, K. S., Barrett, L. F., Ostadabbas, S. (2018).</span>
<span class="sd">      An Open-Source Feature Extraction Tool for the Analysis of Peripheral Physiological Data.</span>
<span class="sd">      IEEE Journal of Translational Engineering in Health and Medicine, 6, 1-11.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">):</span>
        <span class="n">ecg_window</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">window_size</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]</span>
        <span class="n">rpeak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ecg_window</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rpeak</span><span class="p">):</span>
            <span class="n">peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">peaks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># min_distance = 200</span>

    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># ASI (FSM based 2020)</span>
<span class="c1"># =============================================================================</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_rodrigues</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Segmenter by Tiago Rodrigues, inspired by on Gutierrez-Rivas (2015) and Sadhukhan (2012).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - Gutiérrez-Rivas, R., García, J. J., Marnane, W. P., &amp; Hernández, A. (2015). Novel real-time</span>
<span class="sd">      low-complexity QRS complex detector based on adaptive thresholding. IEEE Sensors Journal,</span>
<span class="sd">      15(10), 6036-6043.</span>

<span class="sd">    - Sadhukhan, D., &amp; Mitra, M. (2012). R-peak detection algorithm for ECG using double difference</span>
<span class="sd">      and RR interval processing. Procedia Technology, 4, 873-877.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="mi">128</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">Nd</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Pth</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.7</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span> <span class="o">+</span> <span class="mf">2.7</span>
    <span class="c1"># Pth = 3, optimal for fs = 250 Hz</span>
    <span class="n">Rmin</span> <span class="o">=</span> <span class="mf">0.26</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ramptotal</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Double derivative squared</span>
    <span class="n">diff_ecg</span> <span class="o">=</span> <span class="p">[</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">Nd</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nd</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))]</span>
    <span class="n">ddiff_ecg</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff_ecg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_ecg</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_ecg</span><span class="p">))]</span>
    <span class="n">squar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">ddiff_ecg</span><span class="p">)</span>

    <span class="c1"># Integrate moving window</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">processed_ecg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">squar</span><span class="p">)</span>
    <span class="n">tf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_ecg</span><span class="p">)</span>
    <span class="n">rpeakpos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># R-peak finder FSM</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tf</span><span class="p">:</span>  <span class="c1"># ignore last sample of recording</span>
        <span class="c1"># State 1: looking for maximum</span>
        <span class="n">tf1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">Rmin</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">Rpeakamp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tf1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tf</span><span class="p">:</span>
            <span class="c1"># Rpeak amplitude and position</span>
            <span class="k">if</span> <span class="n">processed_ecg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Rpeakamp</span><span class="p">:</span>
                <span class="n">Rpeakamp</span> <span class="o">=</span> <span class="n">processed_ecg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">rpeakpos</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">Ramptotal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">19</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ramptotal</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rpeakamp</span>
        <span class="n">rpeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rpeakpos</span><span class="p">)</span>

        <span class="c1"># State 2: waiting state</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tf1</span> <span class="o">-</span> <span class="n">rpeakpos</span>
        <span class="n">tf2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">tf2</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># State 3: decreasing threshold</span>
        <span class="n">Thr</span> <span class="o">=</span> <span class="n">Ramptotal</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tf</span> <span class="ow">and</span> <span class="n">processed_ecg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Thr</span><span class="p">:</span>
            <span class="n">Thr</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Pth</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Fast Visibility Graph Detector - by Emrich et al. (2023)</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_visibilitygraph</span><span class="p">(</span>
    <span class="n">signal</span><span class="p">,</span>
    <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">window_seconds</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">window_overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">accelerated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Accelerated R-Peak Detector Using Visibility Graphs by Emrich et al. (2023). Implements the FastNVG algorithm,</span>
<span class="sd">    allowing fast and sample precise R-peak detection.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - J. Emrich, T. Koka, S. Wirth and M. Muma, &quot;Accelerated Sample-Accurate R-Peak</span>
<span class="sd">      Detectors Based on Visibility Graphs,&quot; 31st European Signal Processing</span>
<span class="sd">      Conference (EUSIPCO), 2023, pp. 1090-1094, doi: 10.23919/EUSIPCO58844.2023.10290007,</span>
<span class="sd">      https://ieeexplore.ieee.org/document/10290007</span>

<span class="sd">    - T. Koka and M. Muma (2022), Fast and Sample Accurate R-Peak Detection for Noisy ECG Using</span>
<span class="sd">      Visibility Graphs. In: 2022 44th Annual International Conference of the IEEE Engineering</span>
<span class="sd">      in Medicine &amp; Biology Society (EMBC). Uses the Pan and Tompkins thresholding.</span>

<span class="sd">    - https://github.com/JonasEmrich/vg-beat-detectors</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Try loading ts2vg</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">ts2vg</span>
    <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">import_error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;NeuroKit error: ecg_findpeaks(): the &#39;ts2vg&#39; module is required for&quot;</span>
            <span class="s2">&quot; this method to run. Please install it first (`pip install ts2vg`).&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">import_error</span>

    <span class="c1"># Initialize variables</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>  <span class="c1"># Signal length</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_seconds</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>  <span class="c1"># Length of window segment</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Left segment boundary</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">M</span>  <span class="c1"># Right segment boundary</span>
    <span class="n">dM</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">window_overlap</span> <span class="o">*</span> <span class="n">M</span><span class="p">))</span>  <span class="c1"># Size of segment overlap</span>
    <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(((</span><span class="n">N</span> <span class="o">-</span> <span class="n">R</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">dM</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># Number of segments</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># Empty array to store the weights</span>
    <span class="n">BETA</span> <span class="o">=</span> <span class="mf">0.55</span>  <span class="c1"># Target number of nonzero elements in the resulting weight vector</span>

    <span class="c1"># if the input signal is flat, return an empty array, otherwise the visiblity graph will fail</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="c1"># If input length is smaller than window, compute only one segment of this length</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
        <span class="n">M</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span>
        <span class="n">n_segments</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Do computation in small segments</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_segments</span><span class="p">):</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">L</span><span class="p">:</span><span class="n">R</span><span class="p">]</span>

        <span class="c1"># Select indicies and values to construct the visibility graph</span>
        <span class="k">if</span> <span class="n">accelerated</span><span class="p">:</span>
            <span class="c1"># Compute the threshold for the segment</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="c1"># Find local maxima</span>
            <span class="n">indices_maxima</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">segment</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">segment_maxima</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="n">indices_maxima</span><span class="p">]</span>
            <span class="c1"># Select local maxima above the threshold</span>
            <span class="n">greater</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">segment_maxima</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices_maxima</span><span class="p">[</span><span class="n">greater</span><span class="p">]</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="n">segment_maxima</span><span class="p">[</span><span class="n">greater</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span>

        <span class="c1"># Compute the adjacency matrix to the directed visibility graph</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ts2vg</span><span class="o">.</span><span class="n">NaturalVG</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="s2">&quot;top_to_bottom&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Compute the ECG weights using k-Hop-paths</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">BETA</span><span class="p">:</span>
            <span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">_w</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">_w</span><span class="p">)):</span>
                <span class="k">break</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">_w</span>

        <span class="c1"># Update weight vector by merging overlaping segments</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">elif</span> <span class="n">N</span> <span class="o">-</span> <span class="n">dM</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">L</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;=</span> <span class="n">dM</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">w</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;=</span> <span class="n">dM</span><span class="p">]</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;=</span> <span class="n">dM</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">L</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&gt;</span> <span class="n">dM</span><span class="p">]]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">indices</span> <span class="o">&gt;</span> <span class="n">dM</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Update segment boundaries</span>
        <span class="n">L</span> <span class="o">+=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">dM</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">dM</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">+=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">dM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">N</span>

    <span class="c1"># Weigh signal with obtained weights and use thresholding algorithm for peak localization</span>
    <span class="n">weighted_signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">*</span> <span class="n">weights</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">_ecg_findpeaks_visgraphthreshold</span><span class="p">(</span><span class="n">weighted_signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">rpeaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rpeaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rpeaks</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Utilities</span>
<span class="c1"># =============================================================================</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_MWA</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Based on https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    Optimized for vectorized computation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span><span class="p">)</span>

    <span class="c1"># Scipy&#39;s uniform_filter1d is a fast and accurate way of computing</span>
    <span class="c1"># moving averages. By default it computes the averages of `window_size`</span>
    <span class="c1"># elements centered around each element in the input array, including</span>
    <span class="c1"># `(window_size - 1) // 2` elements after the current element (when</span>
    <span class="c1"># `window_size` is even, the extra element is taken from before). To</span>
    <span class="c1"># return causal moving averages, i.e. each output element is the average</span>
    <span class="c1"># of window_size input elements ending at that position, we use the</span>
    <span class="c1"># `origin` argument to shift the filter computation accordingly.</span>
    <span class="n">mwa</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">uniform_filter1d</span><span class="p">(</span>
        <span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="p">)</span>

    <span class="c1"># Compute actual moving averages for the first `window_size - 1` elements,</span>
    <span class="c1"># which the uniform_filter1d function computes using padding. We want</span>
    <span class="c1"># those output elements to be averages of only the input elements until</span>
    <span class="c1"># that position.</span>
    <span class="n">head_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="n">mwa</span><span class="p">[:</span><span class="n">head_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="n">head_size</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span> <span class="n">head_size</span><span class="p">,</span> <span class="n">head_size</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">mwa</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_peakdetect</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Based on https://github.com/berndporr/py-ecg-detectors/</span>

<span class="sd">    Optimized for vectorized computation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_peak_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>
    <span class="n">min_missed_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">sampling_rate</span><span class="p">)</span>

    <span class="n">signal_peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">SPKI</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">NPKI</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">last_peak</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># NOTE: Using plateau_size=(1,1) here avoids detecting flat peaks and</span>
    <span class="c1"># maintains original py-ecg-detectors behaviour. Flat peaks are typically</span>
    <span class="c1"># found in measurement artifacts where the signal saturates at maximum</span>
    <span class="c1"># recording amplitude. Such cases should not be detected as peaks. If we</span>
    <span class="c1"># do encounter recordings where even normal R peaks are flat, then changing</span>
    <span class="c1"># this to something like plateau_size=(1, sampling_rate // 10) might make</span>
    <span class="c1"># sense. See also https://github.com/neuropsychology/NeuroKit/pull/450.</span>
    <span class="n">peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">detection</span><span class="p">,</span> <span class="n">plateau_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
        <span class="n">peak_value</span> <span class="o">=</span> <span class="n">detection</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span>

        <span class="n">threshold_I1</span> <span class="o">=</span> <span class="n">NPKI</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">SPKI</span> <span class="o">-</span> <span class="n">NPKI</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">peak_value</span> <span class="o">&gt;</span> <span class="n">threshold_I1</span> <span class="ow">and</span> <span class="n">peak</span> <span class="o">&gt;</span> <span class="n">last_peak</span> <span class="o">+</span> <span class="n">min_peak_distance</span><span class="p">:</span>
            <span class="n">signal_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>

            <span class="c1"># RR_missed threshold is based on the previous eight R-R intervals</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">RR_ave</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">])</span> <span class="o">//</span> <span class="mi">8</span>
                <span class="n">RR_missed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.66</span> <span class="o">*</span> <span class="n">RR_ave</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">last_peak</span> <span class="o">&gt;</span> <span class="n">RR_missed</span><span class="p">:</span>
                    <span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="n">last_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">index</span><span class="p">]</span>
                    <span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">missed_peaks</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">missed_peaks</span> <span class="o">&gt;</span> <span class="n">last_peak</span> <span class="o">+</span> <span class="n">min_missed_distance</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">missed_peaks</span> <span class="o">&lt;</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">min_missed_distance</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">threshold_I2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">threshold_I1</span>
                    <span class="n">missed_peaks</span> <span class="o">=</span> <span class="n">missed_peaks</span><span class="p">[</span><span class="n">detection</span><span class="p">[</span><span class="n">missed_peaks</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_I2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missed_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_peaks</span><span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">detection</span><span class="p">[</span><span class="n">missed_peaks</span><span class="p">])</span>
                        <span class="p">]</span>
                        <span class="n">signal_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>

            <span class="n">last_peak</span> <span class="o">=</span> <span class="n">peak</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">index</span>

            <span class="n">SPKI</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">peak_value</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">SPKI</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NPKI</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">peak_value</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">NPKI</span>

    <span class="k">return</span> <span class="n">signal_peaks</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ecg_findpeaks_visgraphthreshold</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">sampling_frequency</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Based on the python implementation [3] of the thresholding proposed by Pan and Tompkins in [4]. Modifications</span>
<span class="sd">    were made with respect to the application of R-peak detection using visibility graphs and the k-Hop paths metric.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [3] https://github.com/berndporr/py-ecg-detectors</span>
<span class="sd">    [4] J. Pan and W. J. Tompkins, “A Real-Time QRS Detection Algorithm”, IEEE Transactions on Biomedical</span>
<span class="sd">     Engineering, vol. BME-32, Mar. 1985. pp. 230-236.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialise variables</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">sampling_frequency</span><span class="p">)</span>
    <span class="n">signal_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">min_distance</span><span class="p">]</span>
    <span class="n">noise_peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Learning Phase, 2sec</span>
    <span class="n">spki</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sampling_frequency</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.25</span>
    <span class="p">)</span>  <span class="c1"># running estimate of signal level</span>
    <span class="n">npki</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sampling_frequency</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="p">)</span>  <span class="c1"># running estimate of noise level</span>
    <span class="n">threshold_I1</span> <span class="o">=</span> <span class="n">spki</span>

    <span class="c1"># iterate over the whole array / series</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># skip first and last elements</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># detect peak candidates based on a rising + falling slope</span>
            <span class="k">if</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># peak candidates should be greater than signal threshold</span>
                <span class="k">if</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_I1</span><span class="p">:</span>
                    <span class="c1"># distance to last peak is greater than minimum detection distance</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_frequency</span><span class="p">:</span>
                        <span class="n">signal_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">spki</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">spki</span>
                    <span class="c1"># candidate is close to last detected peak -&gt; check if current candidate is better choice</span>
                    <span class="k">elif</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">sampling_frequency</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="c1"># compare slope of last peak with current candidate</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="p">):</span>  <span class="c1"># test greater slope -&gt; qrs</span>
                            <span class="n">spki</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">spki</span> <span class="o">-</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="p">)</span> <span class="o">/</span> <span class="mf">0.875</span>  <span class="c1"># reset threshold</span>
                            <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="n">spki</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">spki</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">noise_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">npki</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">noise_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">npki</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># not a peak -&gt; label as noise and update noise level</span>
                        <span class="n">npki</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">npki</span>

                    <span class="c1"># back search for missed peaks</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
                        <span class="n">RR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">:])</span>
                        <span class="n">RR_ave</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">RR</span><span class="p">))</span>
                        <span class="n">RR_missed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.66</span> <span class="o">*</span> <span class="n">RR_ave</span><span class="p">)</span>

                        <span class="c1"># if time difference of the last two signal peaks found is too large</span>
                        <span class="k">if</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">RR_missed</span><span class="p">:</span>
                            <span class="n">threshold_I2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">threshold_I1</span>
                            <span class="c1"># get range of candidates and apply noise threshold</span>
                            <span class="n">missed_section_peaks</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span>
                                <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_distance</span><span class="p">,</span>
                                <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_distance</span><span class="p">,</span>
                            <span class="p">)</span>
                            <span class="n">missed_section_peaks</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">p</span>
                                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">missed_section_peaks</span>
                                <span class="k">if</span> <span class="n">weight</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_I2</span>
                            <span class="p">]</span>

                            <span class="c1"># add the largest sample in missed interval to peaks</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missed_section_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">missed_peak</span> <span class="o">=</span> <span class="n">missed_section_peaks</span><span class="p">[</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">missed_section_peaks</span><span class="p">])</span>
                                <span class="p">]</span>
                                <span class="n">signal_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">signal_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_peak</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># not a peak -&gt; label as noise and update noise level</span>
                    <span class="n">npki</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.875</span> <span class="o">*</span> <span class="n">npki</span>

                <span class="n">threshold_I1</span> <span class="o">=</span> <span class="n">npki</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">spki</span> <span class="o">-</span> <span class="n">npki</span><span class="p">)</span>

    <span class="c1"># remove first dummy elements</span>
    <span class="k">if</span> <span class="n">signal_peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="n">min_distance</span><span class="p">:</span>
        <span class="n">signal_peaks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal_peaks</span><span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href="https://dominiquemakowski.github.io/">Dominique Makowski</a> and the <a href="https://github.com/neuropsychology/NeuroKit/blob/master/AUTHORS.rst">Team</a>. This documentation is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> license.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020–2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>